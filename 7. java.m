(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Options[LaunchGVMFabricAnalyzer]={"InitialPeakMAD"->1.0,"InitialValleyMAD"->1.0};
LaunchGVMFabricAnalyzer[OptionsPattern[]]:=Manipulate[Module[{img=$stockImages[stockKey],dims=ImageDimensions[$stockImages[stockKey]],roi,prof,peaks,valleys,intRange,imageView,plot},roi={Round[x],Round[y],Round[w],Round[h]};prof=calculateProfile[img,roi];peaks=findPeaks[prof,peakMAD];valleys=findValleys[prof,valleyMAD];intRange=With[{mn=Min[prof],mx=Max[prof]},If[mn==mx,{mn-1,mx+1},{mn,mx}]];imageView=Show[img,Graphics[Evaluate[{EdgeForm[{Directive[Opacity[0.8],Yellow],Thick}],FaceForm[None],Rectangle[{roi[[1]],dims[[2]]-(roi[[2]]+roi[[4]])},{roi[[1]]+roi[[3]],dims[[2]]-roi[[2]]}]}]],ImageSize->300,PlotLabel->Style["Observable State of the Ether",14,FontFamily->"Courier"]];plot=ListLinePlot[Transpose[{prof,Range[Length[prof]]}],PlotRange->{intRange,{1,Length[prof]}},ScalingFunctions->{None,"Reverse"},AspectRatio->1,ImageSize->300,PlotTheme->"Scientific",GridLines->Automatic,Frame->True,FrameLabel->{"Information Balance","Causal Path Index"},PlotLabel->Style["Token Balance Profile",14,FontFamily->"Courier"],PlotStyle->Directive[Thick,Gray],Epilog->Join[({Opacity[0.2],Darker[Green],Rectangle[{intRange[[1]],#1[[1]]},{intRange[[2]],#1[[2]]}]}&)/@peaks,({Opacity[0.2],Darker[Blue],Rectangle[{intRange[[1]],#1[[1]]},{intRange[[2]],#1[[2]]}]}&)/@valleys],PlotLegends->PointLegend[{Darker[Green],Darker[Blue]},{"Forward Progress (Peak)","Reverse Progress (Valley)"}]];Grid[{{imageView,plot}},Spacings->{2,0},Frame->True,FrameStyle->LightGray]],Delimiter,Style["Fabric Analysis Console",Bold,16],{{stockKey,First[Keys[$stockImages]],"Observed Fabric:"},Keys[$stockImages],ControlType->PopupMenu},OpenerView[{"Scout Parameters (ROI)",Column[{Control[{{x,1,"x"},1,Dynamic[ImageDimensions[$stockImages[stockKey]][[1]]-w+1],1}],Control[{{y,1,"y"},1,Dynamic[ImageDimensions[$stockImages[stockKey]][[2]]-h+1],1}],Control[{{w,32,"width"},1,Dynamic[ImageDimensions[$stockImages[stockKey]][[1]]],1}],Control[{{h,32,"height"},1,Dynamic[ImageDimensions[$stockImages[stockKey]][[2]]],1}]}]}],OpenerView[{"Hazard Detection Thresholds",Column[{Control[{{valleyMAD,OptionValue["InitialValleyMAD"],"Valley MAD"},0.1,5.0,0.1,Appearance->"Labeled"}],Control[{{peakMAD,OptionValue["InitialPeakMAD"],"Peak MAD"},0.1,5.0,0.1,Appearance->"Labeled"}]}]}],ControlPlacement->Left,TrackedSymbols->{stockKey,x,y,w,h,valleyMAD,peakMAD}];
LaunchGVMFabricAnalyzer[]


ClearAll[getPosition,safeWD,numericQ,toDegrees];
getPosition[str_String]:=Module[{pos},pos=Quiet[Check[GeoPosition[str],$Failed]];If[pos===$Failed,pos=Quiet[Check[With[{r=Interpreter["Location"][str]},Which[Head[r]===GeoPosition,r,Head[r]===Entity,EntityValue[r,"Position"],True,$Failed]],$Failed]]];If[pos===$Failed,pos=Quiet[Check[GeoPosition[CityData[str,"Coordinates"]],$Failed]]];pos];
safeWD[ent_,prop_]:=Quiet[Check[WeatherData[ent,prop],Missing[]]];
numericQ[x_]:=NumericQ[x]||QuantityQ[x];
toDegrees[q_]:=Which[QuantityQ[q],QuantityMagnitude[UnitConvert[q,"Degrees"]],NumericQ[q],q,True,Missing[]];
DynamicModule[{loc="Chicago",latlon=Missing[],nowDegC=Missing[],nowCond=Missing[],ts24=Missing[],hi=Association[],data=Association[],astro=Association[],error=False},Column[{Row[{InputField[Dynamic[loc],String,FieldSize->28,ContinuousAction->True],Spacer[5],Button["Update",error=False;Module[{pos=getPosition[StringTrim[loc]],vals,pairs},If[pos===$Failed,error=True;Return[]];latlon=Normal[pos];nowDegC=With[{t=safeWD[pos,"Temperature"]},If[QuantityQ[t],Round[QuantityMagnitude[UnitConvert[t,"DegreesCelsius"]]],Missing[]]];nowCond=safeWD[pos,"Conditions"];ts24=safeWD[pos,{"Temperature",{Now,Now+Quantity[24,"Hours"]}}];ts24=If[Head[ts24]===TimeSeries,UnitConvert[ts24,"DegreesCelsius"],Missing[]];vals=If[Head[ts24]===TimeSeries,Normal[ts24][[All,2]],{}];pairs=If[Head[ts24]===TimeSeries,Normal[ts24],{}];hi=Association["HiTemp"->If[FailureQ[Quiet[Max[vals]]],Missing[],Round[Max[vals]]],"LoTemp"->If[FailureQ[Quiet[Min[vals]]],Missing[],Round[Min[vals]]],"HiTime"->If[vals==={},Missing[],Lookup[pairs,Max[vals]]],"LoTime"->If[vals==={},Missing[],Lookup[pairs,Min[vals]]]];KeyValueMap[Module[{raw=safeWD[pos,#1]},If[raw=!=Missing[],AssociateTo[data,#2[[1]]->#2[[2]][raw]]]]&,Association["UVIndex"->{"UV",Identity},"VisibilityDistance"->{"VisKm",Function[q,Round[QuantityMagnitude[UnitConvert[q,"Kilometers"]]]]},"WindSpeed"->{"WindKmH",Function[q,Round[QuantityMagnitude[UnitConvert[q,("Kilometers")/("Hours")]]]]},"WindDirection"->{"WindDeg",toDegrees},"RelativeHumidity"->{"Humidity%",Function[q,Round[QuantityMagnitude[UnitConvert[q,"Percent"]]]]},"Pressure"->{"PressurehPa",Function[q,Round[QuantityMagnitude[UnitConvert[q,"Hectopascals"]]]]},"CloudCover"->{"Cloud%",Function[q,Round[QuantityMagnitude[UnitConvert[q,"Percent"]]]]},"PrecipitationProbability"->{"Precip%",Function[p,Round[p 100]]}]];astro=Association["Sunrise"->safeWD[pos,"SunriseTime"],"Sunset"->safeWD[pos,"SunsetTime"]];]],Spacer[6],Dynamic[If[error,Style["location not found",Red],Spacer[0]]]}],Divider[],Dynamic[If[MissingQ[nowDegC],Style["(press Update)",Italic,Gray],Grid[{{Style["Current Weather",14,Bold,Darker[Blue]]},{Row[{nowDegC," \[Degree]C"}]},{If[MissingQ[nowCond],"\[LongDash]",nowCond]},{"High:  "<>If[MissingQ[hi["HiTemp"]],"\[LongDash]",ToString[hi["HiTemp"]]<>" \[Degree]C"]<>"  @ "<>If[MissingQ[hi["HiTime"]],"\[LongDash]",DateString[hi["HiTime"],{"Hour12",":","Minute"," AMPM"}]]},{"Low:   "<>If[MissingQ[hi["LoTemp"]],"\[LongDash]",ToString[hi["LoTemp"]]<>" \[Degree]C"]<>"  @ "<>If[MissingQ[hi["LoTime"]],"\[LongDash]",DateString[hi["LoTime"],{"Hour12",":","Minute"," AMPM"}]]},{"Lat/Lon: "<>If[ListQ[latlon],Row[{NumberForm[latlon[[1]],{6,4}],"\[Degree], ",NumberForm[latlon[[2]],{6,4}],"\[Degree]"}],"\[LongDash]"]},{"Local: "<>DateString[Now,{"TimeShort","  ","DayNameShort"}]}},Alignment->Left,Spacings->{2,.6}]]],Spacer[10],Dynamic[If[Head[ts24]===TimeSeries,Column[{Style["Next 24 h temperature",12,Bold,Gray],ListLinePlot[ts24,PlotRange->All,PlotMarkers->Automatic,InterpolationOrder->1,AxesLabel->{"Time","\[Degree]C"},ImageSize->Medium]}],""]],Spacer[10],Dynamic[Module[{rows={}},KeyValueMap[AppendTo[rows,{#1<>":",#2}]&,KeySort[DeleteMissing[KeyTake[data,{"UV","Humidity%","Cloud%","PressurehPa","VisKm","WindKmH","Precip%"}]]]];If[KeyExistsQ[data,"WindDeg"],Module[{deg=data["WindDeg"],lbl={"N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSW","SW","WSW","W","WNW","NW","NNW"}},AppendTo[rows,{"Direction:",lbl[[Mod[Round[deg/22.5],16,1]]]<>" ("<>ToString[deg]<>"\[Degree])"}]]];Grid[Prepend[rows,{Style["Highlights",12,Bold,Gray]}],Alignment->{Left,Right},Frame->{None,{None,{2->GrayLevel[.9]}}},Spacings->{2,1}]]],Spacer[10],Dynamic[If[DeleteMissing[astro]===Association[],"",Grid[{{Style["Sunrise & Sunset",12,Bold,Gray]},{"Sunrise:",If[MissingQ[astro["Sunrise"]],"\[LongDash]",DateString[astro["Sunrise"],{"Hour12",":","Minute"," AMPM"}]]},{"Sunset:",If[MissingQ[astro["Sunset"]],"\[LongDash]",DateString[astro["Sunset"],{"Hour12",":","Minute"," AMPM"}]]}},Alignment->Left,Spacings->{2,.8}]]]},Spacings->2]]


ClearAll["Global`*"];
isPrimeQ=PrimeQ;
timed[tag_,expr_]:=Module[{t0=AbsoluteTime[],val,dt},val=expr;dt=AbsoluteTime[]-t0;Print[Row[{tag," finished in ",NumberForm[dt,{6,3}]," s."}]];val];
getPrimeFactors[n_Integer?Positive]:=FactorInteger[n][[All,1]];
rad124[n_Integer?Positive]:=rad124[n]=Times@@getPrimeFactors[n];
solvePE124[]:=timed["PE-124 (Original)",Module[{pairs},pairs=Table[{n,rad124[n]},{n,10^5}];Print["answer (10 000th): ",First[SortBy[pairs,{Last,First}][[10000]]]]]];
solvePE95[]:=timed["PE-95 (Original)",Module[{limit=10^6,sigma=Developer`ToPackedArray[DivisorSigma[1,Range[10^6]]-Range[10^6]],mark=ConstantArray[0,10^6],longestLen=0,longestMin=0,bag,list,n,idx,pos,cycLen},Do[If[mark[[n]]=!=0,Continue[]];bag=Internal`Bag[];idx=n;While[1<idx<=limit&&mark[[idx]]==0,mark[[idx]]=-1;Internal`StuffBag[bag,idx];idx=sigma[[idx]];];list=Internal`BagPart[bag,All];If[idx<=limit&&mark[[idx]]==-1,pos=FirstPosition[list,idx][[1]];cycLen=Length[list]-pos+1;If[cycLen>longestLen,longestLen=cycLen;longestMin=Min[Take[list,{pos,-1}]];];];mark[[list]]=1;,{n,2,limit}];Print["smallest element of longest chain: ",longestMin];]];
solvePE357[]:=timed["PE-357 (Original)",Module[{nMax=100000000,sum=0,n,divs},Do[n=2 k;If[PrimeQ[n+1]&&Mod[n,4]==0,divs=Rest[Most[Divisors[n]]];If[AllTrue[divs,PrimeQ[#1+n/#1]&],sum+=n]],{k,1,nMax/2-1,2}];Print["sum: ",sum];]];
solvePE124WithVisuals[]:=Module[{pairs,sortedPairs},Print[Style["--- Solving Project Euler 124 with Visuals ---","Section",Bold]];Print["Step 1: Calculate rad(n), the product of distinct prime factors."];Print[TableForm[Table[{n,getPrimeFactors[n],rad124[n]},{n,1,15}],TableHeadings->{None,{"n","Prime Factors","rad(n)"}}]];pairs=Table[{n,rad124[n]},{n,10^5}];Print["Step 2: Create pairs of {n, rad(n)} for n up to 100,000. (Sample shown)"];Print[Short[pairs,5]];sortedPairs=SortBy[pairs,{Last,First}];Print["Step 3: Sort the pairs first by rad(n), then by n. (Sample shown)"];Print[Short[sortedPairs,5]];Print[Style["Final Answer:",Bold]];Print["The 10,000th element in the sorted list is {n, rad(n)} = ",sortedPairs[[10000]]];Print["So the answer is n = ",First[sortedPairs[[10000]]]];Print[Style["Visualization:",Bold]];Print[ListPlot[Take[pairs,1000],PlotLabel->"rad(n) vs. n for n=1 to 1000",AxesLabel->{"n","rad(n)"},PlotTheme->"Scientific",ImageSize->Medium,PlotStyle->Opacity[0.5]]];];
solvePE95WithVisuals[]:=timed["PE-95 (Visual)",Module[{limit=10^6,sigma,mark=ConstantArray[0,10^6],longestLen=0,longestChain={},bag,list,n,idx,pos,currentChain},Print[Style["--- Solving Project Euler 95 with Visuals ---","Section",Bold]];sigma=Developer`ToPackedArray[DivisorSigma[1,Range[limit]]-Range[limit]];Print["Step 1: Pre-calculate array of proper divisor sums, \[Sigma](n)-n. (First 25 shown)"];Print[TableForm[Take[sigma,25],TableHeadings->{Range[25],{"\[Sigma](n)-n"}}]];Print["Step 2: Search for amicable chains. New longest chains will be printed as they are found."];Do[If[mark[[n]]=!=0,Continue[]];bag=Internal`Bag[];idx=n;While[1<idx<=limit&&mark[[idx]]==0,mark[[idx]]=-1;Internal`StuffBag[bag,idx];idx=sigma[[idx]];];list=Internal`BagPart[bag,All];If[idx<=limit&&mark[[idx]]==-1,pos=FirstPosition[list,idx];If[Head[pos]===List,pos=pos[[1]];currentChain=Take[list,{pos,-1}];If[Length[currentChain]>longestLen,longestLen=Length[currentChain];longestChain=currentChain;Print["Found new longest chain of length ",longestLen,": ",longestChain];];];];mark[[list]]=1;,{n,2,limit}];Print[Style["Final Answer:",Bold]];Print["The longest chain found has length: ",Length[longestChain]];Print["The smallest element of this chain is: ",Min[longestChain]];Print[Style["Visualization:",Bold]];Print[GraphPlot[Rule@@@Partition[longestChain,2,1,1],VertexLabeling->True,PlotLabel->"Longest Amicable Chain Found",ImageSize->Large]];]];
solvePE357WithVisuals[]:=timed["PE-357 (Visual)",Module[{nMax=100000,sum=0,n,divs,test,qualifyingNumbers={}},Print[Style["--- Solving Project Euler 357 with Visuals (up to n=100,000) ---","Section",Bold]];Print["Searching for numbers 'n' where for every divisor 'd', d + n/d is prime."];Do[n=2 k;If[!PrimeQ[n+1],Continue[]];divs=Rest[Most[Divisors[n]]];test=AllTrue[divs,PrimeQ[#1+n/#1]&];If[test,sum+=n;AppendTo[qualifyingNumbers,n];Print[Style[Row[{"Found qualifying number: n = ",n}],Bold,Green],"\n  Divisors: ",Most[Divisors[n]],"\n  Checks (d+n/d): ",(#1+n/#1&)/@Most[Divisors[n]],"\n  Current Sum: ",sum]],{k,1,nMax/2-1}];Print[Style["Final Answer:",Bold]];Print["The sum of all qualifying numbers up to ",nMax," is: ",sum];Print[Style["Visualization:",Bold]];Print[ListPlot[qualifyingNumbers,PlotLabel->"Distribution of Qualifying Numbers",AxesLabel->{"Index","Qualifying Number n"},PlotTheme->"Detailed",ImageSize->Medium]];]];
solvePE124WithVisuals[];
Print["\n",TextString[LineSeparator],"\n"];
solvePE95WithVisuals[];
Print["\n",TextString[LineSeparator],"\n"];
solvePE357WithVisuals[];


ClearAll[isPrimeQ,timed,getPrimeFactors,rad124,solvePE124,solvePE95,solvePE357];
isPrimeQ=PrimeQ;
timed[tag_,expr_]:=Module[{t0=AbsoluteTime[],val,dt},val=expr;dt=AbsoluteTime[]-t0;Print[Row[{tag," finished in ",NumberForm[dt,{6,3}]," s."}]];val];
getPrimeFactors[n_Integer?Positive]:=FactorInteger[n][[All,1]];
rad124[n_Integer?Positive]:=rad124[n]=Times@@getPrimeFactors[n];
solvePE124[]:=timed["PE-124",Module[{pairs},pairs=Table[{n,rad124[n]},{n,10^5}];Print["answer (10 000th): ",First[SortBy[pairs,{Last,First}][[10000]]]]]];
solvePE95[]:=timed["PE-95",Module[{limit=10^6,sigma=Developer`ToPackedArray[DivisorSigma[1,Range[10^6]]-Range[10^6]],mark=ConstantArray[0,10^6],longestLen=0,longestMin=0,bag,list,n,idx,pos,cycLen},Do[If[mark[[n]]=!=0,Continue[]];bag=Internal`Bag[];idx=n;While[1<idx<=limit&&mark[[idx]]==0,mark[[idx]]=-1;Internal`StuffBag[bag,idx];idx=sigma[[idx]];];list=Internal`BagPart[bag,All];If[idx<=limit&&mark[[idx]]==-1,pos=FirstPosition[list,idx][[1]];cycLen=Length[list]-pos+1;If[cycLen>longestLen,longestLen=cycLen;longestMin=Min[Take[list,{pos,-1}]]];];mark[[list]]=1;,{n,2,limit}];Print["smallest element of longest chain: ",longestMin];]];
solvePE357[]:=timed["PE-357",Module[{nMax=100000000,sum=0,n,divs},Do[n=2 k;If[PrimeQ[n+1]&&Mod[n,4]==0,divs=Rest[Most[Divisors[n]]];If[AllTrue[divs,PrimeQ[#1+n/#1]&],sum+=n]],{k,1,nMax/2-1,2}];Print["sum: ",sum];]];
solvePE124[];
solvePE95[];


BeginPackage["DaedaelusSignals`"];
FetchOHLCV::usage="FetchOHLCV[ticker, start, end] fetches OHLCV data. This function establishes the foundational record; as described in the Daedalus framework, each transaction must carry a known, bounded amount of entropy, ensuring every interaction is atomic and unambiguous.";
AddSMA::usage="AddSMA[data, n] appends an n-period Simple Moving Average column (\"SMAn\") to the dataset. This is a reversible transformation applied to the data vector.";
AddRSI::usage="AddRSI[data, n] appends an n-period Relative Strength Index column (\"RSIn\") to the dataset. This is another reversible transformation applied to the data vector.";
PlotVolumeChart::usage="PlotVolumeChart[data] creates a bar chart visualizing the volume signal, providing clear, unambiguous feedback on market activity. Each bar represents a discrete, self-contained unit of transactional volume.";
PlotSMAChart::usage="PlotSMAChart[data, n] plots the closing price and its n-period SMA.";
PlotRSIChart::usage="PlotRSIChart[data, n] plots the n-period RSI with standard overbought/oversold lines at 70/30.";
PlotIndicators::usage="PlotIndicators[data, nSMA, nRSI] produces a two-panel dashboard: price+SMA on top, RSI below, to provide a consolidated view of the derived signals.";
Begin["`Private`"];
FetchOHLCV[ticker_String,start_DateObject,end_DateObject]:=Module[{ts,raw},ts=FinancialData[ticker,"OHLCV",{start,end}];raw=Normal[ts];raw/. {date_,{o_,h_,l_,c_,v_}}:>Association["Ticker"->ticker,"Date"->date,"Open"->o,"High"->h,"Low"->l,"Close"->c,"Volume"->v]];
RelativeStrengthIndex[vec_List,n_Integer?Positive]:=Module[{d,up,dn,g,l,rs},d=Differences[vec];up=Clip[d,{0,\[Infinity]}];dn=-Clip[d,{-\[Infinity],0}];g=MovingAverage[up,n];l=MovingAverage[dn,n];rs=g/Replace[l,0.->$MachineEpsilon];Join[ConstantArray[Missing[],n],100-100/(1+rs)]];
AddRSI[data_List,n_Integer?Positive]:=Module[{cl,rsi},cl=QuantityMagnitude[Lookup[data,"Close"]];rsi=RelativeStrengthIndex[cl,n];MapThread[Append[#1,"RSI"<>ToString[n]->#2]&,{data,rsi}]];
AddSMA[data_List,n_Integer?Positive]:=Module[{cl,sma},cl=QuantityMagnitude[Lookup[data,"Close"]];sma=MovingAverage[cl,n];sma=Join[ConstantArray[Missing[],n-1],sma];MapThread[Append[#1,"SMA"<>ToString[n]->#2]&,{data,sma}]];
PlotVolumeChart[data_List]:=Module[{vol=({#Date,QuantityMagnitude[#Volume]}&)/@data,ticker},ticker=Lookup[data[[1]],"Ticker",""];BarChart[vol,AspectRatio->1/3,ImageSize->Large,PlotLabel->Style[ticker<>" Volume",16,Bold],ChartStyle->Blue]];
PlotSMAChart[data_List,n_Integer]:=Module[{dates,closes,sma},dates=Lookup[data,"Date"];closes=QuantityMagnitude/@Lookup[data,"Close"];sma=Lookup[data,"SMA"<>ToString[n]];DateListPlot[{Transpose[{dates,closes}],Transpose[{dates,sma}]},PlotLegends->{"Close","SMA "<>ToString[n]},Frame->True,ImageSize->Large,PlotLabel->"Price + SMA "<>ToString[n],GridLines->{None,Automatic}]];
PlotRSIChart[data_List,n_Integer]:=Module[{dates,rsi},dates=Lookup[data,"Date"];rsi=Lookup[data,"RSI"<>ToString[n]];DateListPlot[Transpose[{dates,rsi}],PlotRange->{0,100},Frame->True,ImageSize->Large,PlotLabel->"RSI "<>ToString[n],GridLines->{None,{30,70}},GridLinesStyle->Directive[Dashed,Gray]]];
PlotIndicators[data_List,nSMA_Integer,nRSI_Integer]:=Column[{PlotSMAChart[data,nSMA],PlotRSIChart[data,nRSI]},Spacings->2];
End[];
Protect@@Names["DaedaelusSignals`*"];
EndPackage[];
Needs["DaedaelusSignals`"];
data=FetchOHLCV["AAPL",DateObject[{2024,1,1}],DateObject[]];
data2=AddRSI[AddSMA[data,20],14];
Last[data2]
PlotVolumeChart[data2]
PlotIndicators[data2,20,14]
Dataset[data2]


ClearAll[GCParseDateTime,GCParseFloat];
GCParseDateTime[dt_DateObject]:=dt;
GCParseDateTime[iso_]:=Module[{s=ToString[iso],dt},dt=Quiet[Check[DateObject[s,TimeZone->0],$Failed]];If[Head[dt]===DateObject,dt,Message[GCParseDateTime::bad,iso];$Failed]];
GCParseDateTime::bad="Could not parse ISO timestamp `1`.";
GCParseFloat[str_]:=Module[{clean=StringReplace[ToString[str],", "->""]},If[StringMatchQ[clean,NumberString],ToExpression[clean],Missing["NotAvailable"]]];
ClearAll[GraphQLQuery];
GraphQLQuery[___]:=Association["entities"->{Association["id"->"1","name"->"Cell A (Theseus)","createdAt"->"2021-01-15T10:00:00Z"],Association["id"->"2","name"->"Cell B (Ariadne)","createdAt"->"2021-02-20T14:30:00Z"],Association["id"->"3","name"->"Cell C (Icarus)","createdAt"->"2021-03-18T09:15:00Z"]},"entity"->Association["id"->"2","name"->"Cell B (Ariadne)","description"->"Ariadne Routing Protocol Node","updatedAt"->"2021-04-01T12:00:00Z"]];
ClearAll[listEntities,getEntityById];
listEntities[]:=GraphQLQuery[][["entities"]][[All,"name"]];
getEntityById[id_String]:=Module[{data=GraphQLQuery[],ent},ent=SelectFirst[data[["entities"]],#1["id"]==id&,$Failed];If[ent===$Failed,Return[$Failed]];Association["id"->ent[["id"]],"name"->ent[["name"]],"description"->data[["entity"]][["description"]],"updatedAt"->GCParseDateTime[data[["entity"]][["updatedAt"]]]]];
entities=listEntities[];
Print["Entities: ",entities];
BarChart[ConstantArray[1,Length[entities]],ChartLabels->Placed[entities,Axis,Rotate[#1,\[Pi]/6]&],PlotLabel->Style["Initial Cell Population in Groundplane",18,Bold],AxesLabel->{"Cell Agents","Count"},ChartStyle->"DarkRainbow",ImageSize->Large,LabelStyle->{Black,Bold}]
entity=getEntityById["2"];
Grid[Prepend[Normal[entity]/. (key_->val_):>{Style[key,Bold],val},{Style["Attribute",Bold],Style["Value",Bold]}],Frame->All,Alignment->Left,Background->{None,{LightGray,White}},ItemStyle->Directive[FontSize->12],Spacings->{2,1},Dividers->{Black,{2->Gray}}]
dates=GCParseDateTime/@GraphQLQuery[][["entities"]][[All,"createdAt"]];
points=Thread[{dates,Range[Length[dates]]}];
DateListPlot[MapThread[Callout[#1,#2,Above]&,{points,entities}],Joined->False,PlotMarkers->{"\[FilledCircle]",12},PlotTheme->"Marketing",PlotStyle->ColorData["DarkRainbow"][3],PlotLabel->Style["Causal Timeline of Cell Initialization Events",18,Bold],FrameLabel->{"Event Timestamp (UTC)","Causal Sequence"},ImageSize->Large,AspectRatio->1/2,LabelStyle->{Black,Bold}]


data=GraphQLQuery[]["entities"];
dataset=SortBy[(Association["Date"->GCParseDateTime[#createdAt],"Name"->#name]&)/@data,#Date&];
dates=dataset[[All,"Date"]];
names=dataset[[All,"Name"]];
levels=Range[Length[dataset]];
points=Transpose[{dates,levels}];
DateListPlot[points,Joined->True,PlotMarkers->{Graphics[{EdgeForm[Black],Disk[{0,0},.015]}],15},PlotTheme->"Detailed",Frame->True,FrameLabel->{Style["Creation Date",14,Bold,FontFamily->"Times"],Style["Project",14,Bold,FontFamily->"Times"]},FrameTicks->{Automatic,Table[{levels[[i]],names[[i]]},{i,Length[levels]}],None,None},GridLines->{Automatic,None},GridLinesStyle->Directive[GrayLevel[.8],Dashed],Epilog->MapIndexed[With[{pt=points[[First[#2]]],nm=names[[First[#2]]]},Text[Style[nm,Italic,12,FontFamily->"Helvetica"],pt+{Quantity[5,"Days"],0},{-1,0}]]&,points],ImageSize->600,PlotRangePadding->Scaled[.05],PlotLabel->Style["Timeline of Entity Creation",16,Bold,FontFamily->"Times"]]


BeginPackage["DaedalusTokenDynamicsModel`"];
interactionLog::usage="interactionLog is a Dataset representing a log of token-exchange interactions between agents.";
AnalyzeInteractionTopologies::usage="AnalyzeInteractionTopologies[] draws the Elbow-Method curve (k \[Element] 2\:202510) and prints descriptive statistics for the k = 3 topology clusters.";
Begin["`Private`"];
numAgents=500;
interactionLog=Dataset[Table[Association["Q1_active"->RandomChoice[{0,1}],"Q2_active"->RandomChoice[{0,1}],"Q3_active"->RandomChoice[{0,1}],"Q4_active"->RandomChoice[{0,1}],"total_tokens_exchanged"->RandomInteger[{10,200}],"tokens_on_mfr_channel"->RandomInteger[{0,50}],"tokens_on_local_channel"->RandomInteger[{0,50}],"confinement_zone"->RandomChoice[{1,2}],"agentID"->i,"large_appliance_count"->RandomInteger[{0,15}],"small_appliance_count"->RandomInteger[{0,15}],"pet_count"->RandomInteger[{0,5}],"members_in_agent_group"->RandomInteger[{1,8}],"agent_income_level"->RandomInteger[{1,14}],"head_agent_avg_work_hours"->RandomInteger[{0,140}],"weekday_interaction_percentage"->RandomReal[{0,1}],"residence_status_code"->RandomInteger[{1,3}],"year"->RandomChoice[{2023,2024}]],{i,numAgents}]];
AnalyzeInteractionTopologies[]:=Module[{cols,raw,nums,scaled,elbowData,elbowPlot,k=3,labels,labeled,groups,summaries},cols={"large_appliance_count","pet_count","members_in_agent_group","agent_income_level","head_agent_avg_work_hours","weekday_interaction_percentage","residence_status_code"};raw=Normal[interactionLog[All,cols]];nums=Values/@raw;scaled=Transpose[Standardize/@Transpose[nums]];elbowData=Table[{kc,Total[ClusteringComponents[scaled,kc,Method->"KMeans"][[3]]]},{kc,2,10}];elbowPlot=ListLinePlot[elbowData,PlotLabel->"Elbow Method for Identifying Agent Topologies",AxesLabel->{"Clusters (k)","Total WCSS"},GridLines->Automatic,ImageSize->Medium,PlotTheme->"Scientific"];Print[elbowPlot];labels=ClusteringComponents[scaled,k,Method->"KMeans"];labeled=MapThread[Append[#1,"TopologyCluster"->#2]&,{raw,labels}];groups=GroupBy[labeled,#1["TopologyCluster"]&];summaries=Association[KeyValueMap[Function[{cl,grp},cl->Association["AgentCount"->Length[grp],"Centroid"->AssociationThread[cols,Round[Table[Mean[grp[[All,key]]],{key,cols}],0.01]]]],groups]];Print[Style["Descriptive Statistics by Topology Cluster (k = 3)","Subtitle"]];Print[Dataset[summaries]];];
End[];
EndPackage[];


Needs["DaedalusTokenDynamicsModel`"]
AnalyzeInteractionTopologies[]


ClearAll[makeDataset,MakeLineupInterface,normalize];
normalize[values_List,ranges_Association]:=MapThread[Rescale[#1,#2]&,{values,Lookup[ranges,Keys[ranges]]}];
makeDataset[players_List,n_Integer]:=Module[{combinations,data},combinations=Subsets[players,{n}];Association[(Module[{playerKeys=("player"<>ToString[#1]&)/@Range[0,n-1],metrics,key},metrics=Association["clinch_rating"->RandomReal[{0.5,1.0}],"eff_fg_value"->RandomReal[{0.4,0.65}],"reb_rate_value"->RandomReal[{0.3,0.7}],"to_rate_value"->RandomReal[{0.08,0.2}],"ft_rate_value"->RandomReal[{0.15,0.4}],"off_rating"->RandomReal[{95,125}],"def_rating"->RandomReal[{95,125}],"num_poss"->RandomInteger[{50,500}]];key=StringRiffle[Sort[#1],"|"];key->Join[AssociationThread[playerKeys,#1],metrics]]&)/@combinations]];
playerList={"K. Durant","D. Booker","B. Beal","J. Nurkic","G. Allen","E. Gordon","R. O'Neale","D. Eubanks","J. Okogie","N. Little"};
ds1=makeDataset[playerList,1];
ds2=makeDataset[playerList,2];
ds3=makeDataset[playerList,3];
ds4=makeDataset[playerList,4];
ds5=makeDataset[playerList,5];
MakeLineupInterface[data1_,data2_,data3_,data4_,data5_]:=DynamicModule[{players=playerList,selected=Association[],minMaxRanges=Association["clinch_rating"->{0.5,1.0},"eff_fg_value"->{0.4,0.65},"reb_rate_value"->{0.3,0.7},"to_rate_value"->{0.08,0.2},"ft_rate_value"->{0.15,0.4},"off_rating"->{95,125},"def_rating"->{95,125}]},Column[{Style["Select Up to 5 Players to Create a Lineup",16,Bold],Dynamic[Grid[Partition[Function[p,Row[{Checkbox[Dynamic[selected[p],(selected[p]=#;If[Total[Boole[Values[selected]]]>5,selected[p]=False])&]],p}]]/@players,UpTo[5]],Alignment->Left]],Dynamic[Module[{selPlayers=Keys@Select[selected,TrueQ],len,lineupData,row,metrics,labels,pts,summary,normalizedMetrics},len=Length[selPlayers];lineupData=Switch[len,1,data1,2,data2,3,data3,4,data4,5,data5,_,Association[]];row=Lookup[lineupData,StringRiffle[Sort[selPlayers],"|"],Missing[]];Which[len==0,"Please select 1 to 5 players to see lineup statistics.",MissingQ[row],"No data available for this specific player combination.",True,metrics={"clinch_rating","eff_fg_value","reb_rate_value","to_rate_value","ft_rate_value","off_rating","def_rating"};labels={"Clinch","FG%","Reb","TO","FT","OffEff","DefEff"};pts={row["def_rating"],row["off_rating"]};normalizedMetrics=normalize[Lookup[row,metrics],minMaxRanges];summary=AssociationThread[{"Clinch Rating","Effective FG%","Rebounding Rate","Turnover Rate","Free Throw Rate","Off. Efficiency","Def. Efficiency","# Possessions"},Lookup[row,Append[metrics,"num_poss"]]];Column[{ListPlot[{pts},AxesLabel->{"Defensive Efficiency","Offensive Efficiency"},PlotStyle->PointSize[Large],GridLines->Automatic],Dataset[summary]}]]]]}]]
MakeLineupInterface[ds1,ds2,ds3,ds4,ds5]


ClearAll[CreateCell,SimulatedAnnealingExplorer];
CreateCell[id_]:="Cell "<>ToString[id];
SimulatedAnnealingExplorer[problem_Association]:=Module[{ef,nf,current,best,currentValue,bestValue,temp,coolingRate,steps,history,delta,expArg,acceptanceProb},ef=problem["EvaluationFunction"];nf=problem["NeighborFunction"];current=problem["InitialInstance"];temp=problem["InitialTemperature"];coolingRate=problem["CoolingRate"];steps=problem["Steps"];best=current;currentValue=bestValue=ef[current];history={bestValue};Do[Module[{neighbor,neighborValue},neighbor=nf[current];neighborValue=ef[neighbor];delta=neighborValue-currentValue;If[delta>0,current=neighbor;currentValue=neighborValue,expArg=delta/temp;acceptanceProb=If[expArg<-700,0,Exp[expArg]];If[RandomReal[]<acceptanceProb,current=neighbor;currentValue=neighborValue;];];If[currentValue>bestValue,best=current;bestValue=currentValue;];AppendTo[history,bestValue];temp*=coolingRate;],{steps}];Association["History"->history]];
cells=CreateCell/@Range[10];
edges=RandomSample[UndirectedEdge@@@Subsets[cells,{2}],18];
lattice=Graph[cells,edges,VertexLabels->"Name",GraphLayout->"SpringEmbedding"];
travelingSalesmanProblem=Association["EvaluationFunction"->Function[route,-Total[(GraphDistance[lattice,##1]&)@@@Partition[route,2,1,{1,1}]]],"NeighborFunction"->Function[route,Module[{r=route,i,j},{i,j}=RandomSample[Range[Length[r]],2];r[[{i,j}]]=r[[{j,i}]];r]],"InitialInstance"->RandomSample[VertexList[lattice]],"InitialTemperature"->1000,"CoolingRate"->0.995,"Steps"->5000];
solution=SimulatedAnnealingExplorer[travelingSalesmanProblem];
ListLinePlot[solution["History"],PlotTheme->"Detailed",PlotStyle->{Thick,ColorData["TemperatureMap"][0.6]},Filling->Axis,FillingStyle->Opacity[0.2],PlotMarkers->{Automatic,6},Frame->True,FrameLabel->{"Step (Discrete Time \\(t\\))","Best Fitness \\(f_{\\mathrm{best}}(t)\\)",None,None},LabelStyle->{FontFamily->"Helvetica",FontSize->14},GridLines->Automatic,GridLinesStyle->Dashed,PlotRangePadding->Scaled[0.02],ImageSize->{800,350}]


resourceAllocationContracts=Dataset[{Association["flow"->"Distribution","quarter"->"Q1","budget"->390000,"actual"->375000],Association["flow"->"Distribution","quarter"->"Q2","budget"->395000,"actual"->382000],Association["flow"->"Distribution","quarter"->"Q3","budget"->400000,"actual"->390000],Association["flow"->"Distribution","quarter"->"Q4","budget"->410000,"actual"->408000],Association["flow"->"Facilities","quarter"->"Q1","budget"->675000,"actual"->693000],Association["flow"->"Facilities","quarter"->"Q2","budget"->800000,"actual"->837000],Association["flow"->"Facilities","quarter"->"Q3","budget"->750000,"actual"->713000],Association["flow"->"Facilities","quarter"->"Q4","budget"->750000,"actual"->790000],Association["flow"->"HR","quarter"->"Q1","budget"->350000,"actual"->346000],Association["flow"->"HR","quarter"->"Q2","budget"->350000,"actual"->342000],Association["flow"->"HR","quarter"->"Q3","budget"->350000,"actual"->340000],Association["flow"->"HR","quarter"->"Q4","budget"->350000,"actual"->367000],Association["flow"->"IS","quarter"->"Q1","budget"->950000,"actual"->925000],Association["flow"->"IS","quarter"->"Q2","budget"->850000,"actual"->890000],Association["flow"->"IS","quarter"->"Q3","budget"->875000,"actual"->976000],Association["flow"->"IS","quarter"->"Q4","budget"->900000,"actual"->930000]}];
resourceAllocationContracts
dataForPlot=GroupBy[Normal[resourceAllocationContracts],#flow&,(Tooltip[{Switch[#quarter,"Q1",1,"Q2",2,"Q3",3,"Q4",4],#budget-#actual},"Budget: "<>ToString[#budget]<>"\nActual: "<>ToString[#actual]<>"\n\[CapitalDelta]: "<>ToString[#budget-#actual]]&)/@#1&];
ListLinePlot[Values[dataForPlot],PlotLegends->Keys[dataForPlot],PlotTheme->"Detailed",FrameLabel->{"Fiscal Quarter","Resource \[CapitalDelta] (Budget \[Minus] Actual)"},PlotLabel->Style["Quarterly Resource Flow Imbalance",Bold,16],GridLines->{None,{{0,Directive[Gray,Dashed]}}},PlotStyle->{RGBColor[0.368,0.507,0.710],RGBColor[1.000,0.540,0.350],RGBColor[0.250,0.730,0.540],RGBColor[0.980,0.600,0.200]},PlotMarkers->{Automatic,12},Ticks->{{1->"Q1",2->"Q2",3->"Q3",4->"Q4"},Automatic},ImageSize->Large]
parsedTemporalData={{DateObject[{2021,1,15}],42},{DateObject[{2021,2,15}],57},{DateObject[{2021,3,15}],63},{DateObject[{2021,4,15}],59},{DateObject[{2021,5,15}],68}};
DateListPlot[parsedTemporalData,PlotTheme->"Web",FrameLabel->{"Date","State Value"},PlotLabel->Style["Temporal State Evolution (A FITO Model)",Bold,16],ImageSize->Large,PlotStyle->Directive[Thick,RGBColor[0.368,0.507,0.710]]]


dataQ={{"Q1",390000,375000},{"Q2",675000,693000},{"Q3",350000,346000},{"Q4",950000,925000}};
quarters=dataQ[[All,1]];
qBudget=dataQ[[All,2]];
qActual=dataQ[[All,3]];
delta=qBudget-qActual;
BarChart[delta,ChartLabels->quarters,ChartStyle->"Pastel",AxesLabel->{"Quarter","Budget \[Dash] Actual"},PlotLabel->"Quarterly Budget vs Actual Delta",ImageSize->Large]
data1={{"1-May-12",58.13},{"30-Apr-12",53.98},{"27-Apr-12",67.00},{"26-Apr-12",89.70},{"25-Apr-12",99.00},{"24-Apr-12",130.28},{"23-Apr-12",166.70},{"20-Apr-12",234.98},{"19-Apr-12",345.44},{"18-Apr-12",443.34},{"17-Apr-12",543.70},{"16-Apr-12",580.13},{"13-Apr-12",605.23},{"12-Apr-12",622.77},{"11-Apr-12",626.20},{"10-Apr-12",628.44},{"9-Apr-12",636.23},{"5-Apr-12",633.68},{"4-Apr-12",624.31},{"3-Apr-12",629.32},{"2-Apr-12",618.63},{"30-Mar-12",599.55},{"29-Mar-12",609.86},{"28-Mar-12",617.62},{"27-Mar-12",614.48},{"26-Mar-12",606.98}};
stock1=data1/. {d_String,v_}:>{DateObject[DateList[{d,{"Day","-","MonthNameShort","-","YearShort"}}]],v};
DateListPlot[stock1,Joined->True,PlotMarkers->Automatic,AxesLabel->{"Date","Close Price"},PlotLabel->"Stock Close Prices (Apr\[Dash]May 2012)",ImageSize->Large]
data2={{"24-Apr-07",93.24},{"25-Apr-07",95.35},{"26-Apr-07",98.84},{"27-Apr-07",99.92},{"30-Apr-07",99.80},{"1-May-07",99.47},{"2-Jul-07",121.26},{"3-Jul-07",127.17},{"5-Jul-07",132.75},{"6-Jul-07",132.30},{"9-Jul-07",130.33},{"10-Jul-07",132.35},{"11-Jul-07",132.39},{"12-Jul-07",134.07},{"13-Jul-07",137.73},{"16-Jul-07",138.10},{"17-Jul-07",138.91},{"18-Jul-07",138.12},{"19-Jul-07",140.00},{"20-Jul-07",143.75},{"23-Jul-07",143.70},{"24-Jul-07",134.89},{"25-Jul-07",137.26},{"26-Jul-07",146.00},{"27-Jul-07",143.85},{"30-Jul-07",141.43},{"31-Jul-07",131.76},{"1-Aug-07",135.00},{"2-Aug-07",136.49},{"3-Aug-07",131.85},{"6-Aug-07",135.25},{"7-Aug-07",135.03},{"8-Aug-07",134.01},{"9-Aug-07",126.39},{"10-Aug-07",125.00},{"13-Aug-07",127.79},{"14-Aug-07",124.03},{"15-Aug-07",119.90},{"16-Aug-07",117.05},{"17-Aug-07",122.06},{"20-Aug-07",122.22},{"21-Aug-07",127.57},{"22-Aug-07",132.51},{"23-Aug-07",131.07},{"24-Aug-07",135.30},{"27-Aug-07",132.25},{"28-Aug-07",126.82},{"29-Aug-07",134.08},{"30-Aug-07",136.25},{"31-Aug-07",138.48},{"4-Sep-07",144.16},{"5-Sep-07",136.76},{"6-Sep-07",135.01},{"7-Sep-07",131.77},{"10-Sep-07",136.71},{"11-Sep-07",135.49},{"12-Sep-07",136.85},{"13-Sep-07",137.20},{"14-Sep-07",138.81},{"17-Sep-07",138.41},{"18-Sep-07",140.92},{"19-Sep-07",140.77},{"20-Sep-07",140.31},{"21-Sep-07",144.15},{"24-Sep-07",148.28},{"25-Sep-07",153.18},{"26-Sep-07",152.77},{"27-Sep-07",154.50},{"28-Sep-07",153.47},{"1-Oct-07",156.34},{"2-Oct-07",158.45},{"3-Oct-07",157.92},{"4-Oct-07",156.24},{"5-Oct-07",161.45},{"8-Oct-07",167.91}};


engText=ToLowerCase[Import["https://raw.githubusercontent.com/GT-CSE6240/proj2/master/data/eng.txt","Text"]];
frnText=ToLowerCase[Import["https://raw.githubusercontent.com/GT-CSE6240/proj2/master/data/frn.txt","Text"]];
chars=Characters[engText]\[Union]Characters[frnText];
charToIdx=AssociationThread[chars->Range[Length[chars]]];
cCount=Length[chars];
maxLen=5;step=3;
makeSeqs[text_]:=Module[{chs=Characters[text],n},n=Length[chs];Table[chs[[i;;i+maxLen-1]],{i,1,n-maxLen,step}]];
engSeqs=makeSeqs[engText];
frnSeqs=makeSeqs[frnText];
vectorize[seqs_]:=Table[Table[UnitVector[cCount,charToIdx[seqs[[i,j]]]],{j,maxLen}],{i,Length[seqs]}];
Xeng=vectorize[engSeqs];
Xfrn=vectorize[frnSeqs];
SeedRandom[1337];
split80[data_]:=Module[{r=RandomSample[data],n},n=Round[0.8 Length[r]];{Take[r,n],Drop[r,n]}];
{XengTrain,XengTest}=split80[Xeng];
{XfrnTrain,XfrnTest}=split80[Xfrn];
lstmNet=NetChain[{LongShortTermMemoryLayer[128],LinearLayer[cCount],SoftmaxLayer[]}];
YengTrainIdx=charToIdx/@Last/@engSeqs[[1;;Length[XengTrain]]];
YfrnTrainIdx=charToIdx/@Last/@frnSeqs[[1;;Length[XfrnTrain]]];
engNet=NetTrain[lstmNet,XengTrain->YengTrainIdx,BatchSize->128,MaxTrainingRounds->5];
frnNet=NetTrain[lstmNet,XfrnTrain->YfrnTrainIdx,BatchSize->128,MaxTrainingRounds->5];
engTest=RandomSample[engSeqs,Min[100,Length[engSeqs]]];
frnTest=RandomSample[frnSeqs,Min[100,Length[frnSeqs]]];
testSeqs=Join[engTest,frnTest];
trueLabels=Join[ConstantArray[1,Length[engTest]],ConstantArray[0,Length[frnTest]]];
scoreSeq[net1_,net2_,seq_]:=Module[{ll1=0.,ll2=0.,window,idx,d1,d2},window=ConstantArray[ConstantArray[0.,cCount],maxLen];Do[idx=charToIdx[ch];d1=net1[window];ll1+=Log[d1[[idx]]];d2=net2[window];ll2+=Log[d2[[idx]]];window=Append[Rest[window],UnitVector[cCount,idx]],{ch,seq}];Exp[ll1]-Exp[ll2]];
scores=(scoreSeq[engNet,frnNet,#1]&)/@testSeqs;
thresholds=Sort[DeleteDuplicates[scores]];
nPos=Count[trueLabels,1];nNeg=Count[trueLabels,0];
roc=Table[{Count[Transpose[{trueLabels,scores}],{0,s_}/;s>t]/nNeg,Count[Transpose[{trueLabels,scores}],{1,s_}/;s>t]/nPos},{t,thresholds}];
fprs=roc[[All,1]];tprs=roc[[All,2]];
auc=Total[1/2 (Most[tprs]+Rest[tprs]) Differences[fprs]];
ListLinePlot[roc,AxesLabel->{"False Positive Rate","True Positive Rate"},PlotRange->{{0,1},{0,1}},PlotLabel->Row[{"ROC Curve    AUC = ",NumberForm[auc,{4,3}]}],GridLines->Automatic]


Print["Fetching and preprocessing data..."];
engText=ToLowerCase[Import["https://raw.githubusercontent.com/GT-CSE6240/proj2/master/data/eng.txt","Text"]];
frnText=ToLowerCase[Import["https://raw.githubusercontent.com/GT-CSE6240/proj2/master/data/frn.txt","Text"]];
allChars=Characters[engText]\[Union]Characters[frnText];
vocabSize=Length[allChars];
charToIdx=AssociationThread[allChars->Range[vocabSize]];
Print["Shared vocabulary size: ",vocabSize];
charFreqVector[text_]:=Module[{counts},counts=Counts[Characters[text]];Normalize[Lookup[counts,allChars,0],Total]];
Print["Computing frequency vectors for training..."];
engFreq=charFreqVector[engText];
frnFreq=charFreqVector[frnText];
classify[text_]:=Module[{vec,engSim,frnSim},vec=charFreqVector[text];engSim=vec . engFreq;frnSim=vec . frnFreq;If[engSim>frnSim,"English","French"]];
Print["Preparing test substrings..."];
maxlen=20;
engTestSubs=RandomSample[StringPartition[engText,maxlen,1],100];
frnTestSubs=RandomSample[StringPartition[frnText,maxlen,1],100];
combinedSubs=Join[engTestSubs,frnTestSubs];
trueLabels=Join[ConstantArray["English",100],ConstantArray["French",100]];
Print["Classifying test samples..."];
predictedLabels=classify/@combinedSubs;
correct=Count[Transpose[{trueLabels,predictedLabels}],{x_,x_}];
accuracy=N[correct/Length[combinedSubs]];
Print["Classification accuracy: ",PercentForm[accuracy,3]];
Print["Confusion Matrix:"];
confMatrixData={{"Actual \\ Predicted","English","French"},{"English",Count[Transpose[{trueLabels,predictedLabels}],{"English","English"}],Count[Transpose[{trueLabels,predictedLabels}],{"English","French"}]},{"French",Count[Transpose[{trueLabels,predictedLabels}],{"French","English"}],Count[Transpose[{trueLabels,predictedLabels}],{"French","French"}]}};
confMatrix=Grid[confMatrixData,Frame->All,Alignment->Center,Background->{None,{LightBlue}}];
confMatrix


ClearAll["Global`*"];
SeedRandom[1234];
trainingDataSubset=10000;
rawData=ResourceData["MNIST","TrainingData"];
realImages=Take[rawData,trainingDataSubset][[All,1]];
data=(Flatten[ImageData[#1]]&)/@realImages;
latentDim=100;
makeLatent[n_]:=RandomReal[{-1,1},{n,latentDim}];
generator=NetChain[{LinearLayer[64,"Input"->latentDim],Ramp,LinearLayer[784],Tanh},"Input"->latentDim];
discriminator=NetChain[{LinearLayer[32,"Input"->784],Ramp,LinearLayer[1],LogisticSigmoid,ReshapeLayer[{}]},"Input"->784];
gan=NetGANOperator[{generator,discriminator}];
trainedGAN=NetTrain[gan,Association["Sample"->data,"Latent"->makeLatent[Length[data]]],BatchSize->512,MaxTrainingRounds->50];
trainedGenerator=NetExtract[trainedGAN,"Generator"];
n=16;
indices=RandomSample[Range[Length[realImages]],n];
originals=realImages[[indices]];
fakeVecs=trainedGenerator[makeLatent[n]];
fakeImgs=(Image[Partition[#1,28],"Real"]&)/@fakeVecs;
pairs=Transpose[{originals,fakeImgs}];
GraphicsGrid[Partition[Flatten[pairs],4],Spacings->{1,1},Frame->All,FrameStyle->GrayLevel[0.7],ImageSize->Large]
n=16;
indices=RandomSample[Range[Length[realImages]],n];
originals=realImages[[indices]];
fakeVecs=trainedGenerator[makeLatent[n]];
fakeImgs=(Image[Partition[#1,28],"Real"]&)/@fakeVecs;
reconstruct[img_Image]:=img
reconstructedImgs=reconstruct/@originals;
triples=Transpose[{originals,fakeImgs,reconstructedImgs}];
header={Style["Original",Bold,14],Style["Generated",Bold,14],Style["Reconstructed",Bold,14]};
GraphicsGrid[Prepend[Partition[Flatten[triples],3],header],Spacings->{1,1},Frame->All,FrameStyle->GrayLevel[0.7],ImageSize->Large]


mat={{28.1,24,0.55},{42.3,29,0.40},{34.0,32,0.15},{40.7,30,0.22},{39.9,28,0.35},{31.5,26,0.48},{36.2,31,0.18},{45.1,27,0.60},{29.8,23,0.70},{44.0,33,0.12},{33.3,25,0.50},{38.7,30,0.28},{41.9,34,0.10},{27.4,22,0.65},{35.8,29,0.42}};
vars={"Latitude","ACTMedian","AdmissionRate"};
lines=(Thread[{Range[Length[#1]],#1}]&)/@mat;
colors=Table[ColorData["Pastel"][i],{i,0,1,1/(Length[mat]-1)}];
ListLinePlot[lines,PlotRange->All,PlotStyle->({Thickness[0.002],Opacity[0.70],#1}&)/@colors,Frame->True,FrameStyle->{GrayLevel[0.8],Thin},FrameTicks->{Table[{i,vars[[i]]},{i,Length[vars]}],None,None,None},Ticks->None,GridLines->None,Background->Transparent,ImageSize->600,LabelStyle->{FontFamily->"Helvetica",GrayLevel[0.3],12},PlotLabel->Style["College Scorecard \[LongDash] Showing "<>ToString[Length[mat]]<>" rows",14,FontFamily->"Helvetica",GrayLevel[0.40]]]


data1=Table[Sin[x]+0.2 RandomReal[],{x,0,2 \[Pi],0.1}];
data2=Table[Cos[x]+0.2 RandomReal[],{x,0,2 \[Pi],0.1}];
ListPlot[Transpose[{data1,data2}],PlotStyle->PointSize[Medium],AxesLabel->{"predictions","targets"},PlotLabel->"Scatter: predictions vs targets"]
sharpeRatio[perf_List]:=Mean[perf]/StandardDeviation[perf];
pl=Accumulate[RandomVariate[NormalDistribution[0,1],200]];
ListLinePlot[pl,AxesLabel->{"Time","Cumulative P/L"},PlotLabel->Row[{"Sharpe = ",NumberForm[sharpeRatio[Differences[pl]],3]}]]
minMaxNormalize[data_List]:=Rescale[data,{Min[data],Max[data]},{0,1}];
standardize[data_List]:=Standardize[data];
x=RandomVariate[NormalDistribution[5,2],100];
Show[ListLinePlot[x,PlotLabel->"raw data"],ListLinePlot[minMaxNormalize[x],PlotStyle->Red,PlotLabel->"min\[Dash]max \[RightArrow] [0,1]"],ListLinePlot[standardize[x],PlotStyle->Blue,PlotLabel->"standardize \[RightArrow] mean 0, std 1"]]
gaussianize[data_List]:=Module[{r},r=(Ordering[Ordering[data]]-0.5)/Length[data];(InverseCDF[NormalDistribution[0,1],#1]&)/@r];
y=RandomReal[{0,1},200];
ListLinePlot[{Sort[y],Sort[gaussianize[y]]},PlotLegends->{"sorted uniform","gaussianized"},AxesLabel->{"Index","Value"}]
orthogonalize[v_List,u_List]:=Module[{proj},proj=(v . u u)/u . u;v-proj];
u={1,2};
v={3,1};
Graphics[{Thick,Blue,Arrow[{{0,0},v}],Thick,Green,Arrow[{{0,0},u}],Thick,Red,Arrow[{{0,0},orthogonalize[v,u]}]},Axes->True,PlotLabel->"blue = v, green = u, red = v \[Perpendicular] u"]


pred=RandomVariate[NormalDistribution[],100];
targ=pred+0.5 RandomVariate[NormalDistribution[0,1],100];
ListPlot[Transpose[{pred,targ}],PlotStyle->PointSize[Medium],AxesLabel->{"predictions","targets"},PlotLabel->"pred vs targ"]
u=RandomReal[{0,1},200];
gU=(InverseCDF[NormalDistribution[0,1],#1]&)/@u;
pU=(Sign[#1] Abs[#1]^1.5&)/@gU;
Histogram[{u,gU,pU},ChartLegends->{"uniform","gaussianized","gauss^1.5"},PlotLabel->"Transformations"]
uVec={1,2};
vVec={3,1};
orthogonalComponent[v_,u_]:=v-(v . u u)/u . u;
Graphics[{Thick,Blue,Arrow[{{0,0},vVec}],Thick,Green,Arrow[{{0,0},uVec}],Thick,Red,Arrow[{{0,0},orthogonalComponent[vVec,uVec]}]},Axes->True,PlotLabel->"blue = v, green = u, red = v\[UpTee]u"]


Manipulate[Module[{d2,pts,colors,scintillatePts,pearson,spearman,bg=Black},d2=Switch[type,"Linear",d1+RandomReal[{-noise,noise},100],"Monotonic (Non-Linear)",d1^3+RandomReal[{-noise,noise},100],"Uncorrelated",RandomReal[1,100]];pts=Transpose[{d1,d2}];colors=Table[Blend[{Cyan,Blue,Pink,Yellow,GrayLevel[0.3]},Mod[i/Length[pts]+RandomReal[{-0.03,0.03}],1]],{i,Length[pts]}];scintillatePts=Table[{Glow[colors[[i]]],Opacity[0.22],Disk[pts[[i]],0.025],Opacity[1],EdgeForm[None],Style[Disk[pts[[i]],0.012],colors[[i]]]},{i,Length[pts]}];pearson=pearsonCorrelation[d1,d2];spearman=spearmanCorrelation[d1,d2];Grid[{{Style[type<>" Data",Bold,16,White],\[SpanFromLeft]},{Graphics[{{bg,Rectangle[{0,0},{1,1}]},scintillatePts},PlotRange->{{0,1},{Min[d2]-0.1,Max[d2]+0.1}},ImageSize->400,Axes->True,AxesStyle->White,Frame->True,FrameStyle->White,AxesLabel->{Style["d1",14,White],Style["d2",14,White]},Background->bg],Column[{Row[{Style["Pearson:  ",16,Cyan],Style[NumberForm[pearson,{3,2}],16,White]}],Row[{Style["Spearman: ",16,Cyan],Style[NumberForm[spearman,{3,2}],16,White]}]},Spacings->1]}},Alignment->Center,Spacings->2,Background->Black]],{{type,"Linear","Data Structure"},{"Linear","Monotonic (Non-Linear)","Uncorrelated"}},{{noise,0.1,"Noise"},0,1,Appearance->"Labeled"},ControlPlacement->Top,TrackedSymbols:>{type,noise},Initialization:>(pearsonCorrelation[p_List,t_List]:=Correlation[p,t];spearmanCorrelation[p_List,t_List]:=Module[{n=Length[p],rp,rt,dsq},rp=Ordering[Ordering[p]];rt=Ordering[Ordering[t]];dsq=(rp-rt)^2;1-(6 Total[dsq])/(n (n^2-1))];SeedRandom[123];d1=Sort[RandomReal[1,100]];),FrameMargins->-5.3,ControlPlacement->Top]


nb=EvaluationNotebook[];
SetOptions[nb,Background->RGBColor[0.1,0.1,0.1]];
ResourceFunction["DarkMode"][];


nb=EvaluationNotebook[];
SetOptions[nb,StyleDefinitions->"Default.nb",DefaultNewCellStyle->"Input",Background->Automatic];
OptionRemove[nb,Background];
