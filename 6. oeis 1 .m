(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization::Regular:: *)
V0.6 OPEN ATOMIC ETHERNET
OPEN COMPUTE PROJECT - OAE WORKSTREAM


(* ::Code::Initialization:: *)
"Perfection is achieved not when there is nothing more to add, but when there is nothing left to take away."
	- ANTOINE DE SAINT-EXUP\[CapitalEAcute]RY
	
The primary goal of \[CapitalAE]thernet is to re-examine the foundational assumptions made by Ethernet five decades ago, and ask whether they remain valid within today's racks and chiplet modules.

Just as RISC processors transformed computing by embracing simplicity and focus, so too must we consider whether a "reduced" protocol can lead to a network that is formally verifiable, inherently transactional, and radically simpler.

We adopt the same spirit as the original Ethernet pioneers: start from first principles, strip down to essentials, and then \[LongDash] only then \[LongDash] ask how best to interoperate with the world we inherit.


(* ::Code::Initialization:: *)
"Perfection is achieved not when there is nothing more to add, but when there is nothing left to take away."  Guided by Saint-Exup\[EAcute]ry's maxim, \[CapitalAE]thernet starts where classic Ethernet began\[LongDash]at bedrock\[LongDash]but it refuses to rebuild the same house.  We begin by choosing our question carefully, because "the what question you ask is more important than how you answer the question" ; the question we pose is whether yesterday's contention-based link is even the right abstraction for today's racks and chiplets.  We look for the kind of "paradigmatic advance" after which "the fruit is hanging right there, easy to get" , echoing how RISC showed that ruthless reduction can unlock both clarity and speed.  Achieving this means thinking like Boltzmann, the archetypal "first-principles kinda guy," who stripped problems to their essentials before rebuilding them on firmer ground .  In that same spirit, \[CapitalAE]thernet pares the protocol to what must remain\[LongDash]provable transactionality, explicit causality\[LongDash]so that only afterward do we ask how best to interoperate with the complex world we inherit.


k1=2;gamma1=0.2;
k2=1.5;gamma2=0.1;
k3=2.5;gamma3=0.2;
G1init=0.2;G2init=0.3;G3init=0.1;
tmax=50;
nPoints=1000;
tVals=Subdivide[0,tmax,nPoints];
eqns={Derivative[1][G1][t]==k1/(1+G3[t]^2)-gamma1 G1[t],Derivative[1][G2][t]==k2/(1+G1[t]^2)-gamma2 G2[t],Derivative[1][G3][t]==k3/(1+G2[t]^2)-gamma3 G3[t],G1[0]==G1init,G2[0]==G2init,G3[0]==G3init};
sols=NDSolveValue[eqns,{G1,G2,G3},{t,0,tmax}];
G1Vals=sols[[1]]/@tVals;
G2Vals=sols[[2]]/@tVals;
G3Vals=sols[[3]]/@tVals;
plots={ListLinePlot[Transpose[{tVals,G1Vals}],PlotStyle->Blue,PlotLabel->Style["G\:2081",Bold,14,Blue],AxesLabel->{None,"Number"},GridLines->Automatic,ImageSize->Large,Frame->True],ListLinePlot[Transpose[{tVals,G2Vals}],PlotStyle->Red,PlotLabel->Style["G\:2082",Bold,14,Red],AxesLabel->{None,"Number"},GridLines->Automatic,ImageSize->Large,Frame->True],ListLinePlot[Transpose[{tVals,G3Vals}],PlotStyle->Green,PlotLabel->Style["G\:2083",Bold,14,Darker[Green]],AxesLabel->{"Time","Number"},GridLines->Automatic,ImageSize->Large,Frame->True]};
GraphicsGrid[Partition[plots,1],Spacings->{0,0.7},Dividers->All]


ClearAll[SahasEncode,SahasDecode,SahasAddSymbolsToEdges,SahasStringKeyToRealKey,SahasLongKeyToRealKey,SahasAllCharacters,SahasCharToIndex,SahasIndexToChar,SahasQuestionMarkIndex];
SahasAllCharacters:="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"<>"0123456789"<>"\:0410\:0411\:0412\:0413\:0414\:0415\:0401\:0416\:0417\:0418\:0419\:041a\:041b\:041c\:041d\:041e\:041f\:0420\:0421\:0422\:0423\:0424\:0425\:0426\:0427\:0428\:0429\:042a\:042b\:042c\:042d\:042e\:042f"<>"\:0430\:0431\:0432\:0433\:0434\:0435\:0451\:0436\:0437\:0438\:0439\:043a\:043b\:043c\:043d\:043e\:043f\:0440\:0441\:0442\:0443\:0444\:0445\:0446\:0447\:0448\:0449\:044a\:044b\:044c\:044d\:044e\:044f"<>"!@#$%^&*()-_=+[]{};:'\",<.>/?\\|`~ ";
SahasCharList:=Characters[SahasAllCharacters];
SahasCharToIndex:=AssociationThread[SahasCharList,Range[0,Length[SahasCharList]-1]];
SahasIndexToChar:=AssociationThread[Range[0,Length[SahasCharList]-1],SahasCharList];
SahasQuestionMarkIndex:=SahasCharToIndex["?"];
SahasEncode[input_String]:=Module[{cti=SahasCharToIndex,qidx=SahasQuestionMarkIndex},Lookup[cti,Characters[input],qidx]];
SahasDecode[encoded_List]:=Module[{itc=SahasIndexToChar},StringJoin[Lookup[itc,encoded,"?"]]];
SahasAddSymbolsToEdges[text_String]:=Module[{len=StringLength[text],firstSymbol,secondSymbol},firstSymbol=FromCharacterCode[Mod[len,26]+65];secondSymbol=FromCharacterCode[Mod[7 len,26]+65];firstSymbol<>text<>secondSymbol];
SahasStringKeyToRealKey[key_String]:=Module[{keySub,numbers,newKey},keySub=StringTake[key,UpTo[127]];numbers=SahasEncode[keySub];numbers=Replace[numbers,0->1,{1}];newKey=Total[numbers]+Times@@Take[numbers,UpTo[6]];SahasLongKeyToRealKey[newKey]];
SahasLongKeyToRealKey[key_Integer]:=Module[{maxUlong=2^64-1},maxUlong-Mod[key,2^64]];
ClearAll[SahasGenerateHash,SahasHasher];
SahasGenerateHash[inputText_String,realKey_Integer,cyrillicLetters_:False]:=Module[{availableSymbols,digits,getNumber=0,j=0,piramid,result={},n,piramidCopy,l},availableSymbols=If[cyrillicLetters,128,62];digits=IntegerDigits[realKey];digits=Reverse[digits];piramid=SahasEncode[inputText];n=Quotient[255,Length[piramid]]+1;Do[piramidCopy=piramid;While[True,getNumber=getNumber+digits[[Mod[j,Length[digits],1]]];j=j+1;AppendTo[result,Abs[Mod[piramidCopy[[Mod[getNumber,Length[piramidCopy],1]]]+getNumber,availableSymbols]]];If[Length[piramidCopy]==1,Break[]];For[l=1,l<=Length[piramidCopy]-1,l++,piramidCopy[[l]]=piramidCopy[[l]]+piramidCopy[[l+1]];];piramidCopy=Most[piramidCopy];],{i,1,n}];SahasDecode[result]];
SahasHasher[inputText_String,key_String,cyrillicLetters_:False]:=Module[{realKey},realKey=SahasStringKeyToRealKey[key];SahasGenerateHash[inputText,realKey,cyrillicLetters]];
SahasHasher[inputText_String,key_Integer,cyrillicLetters_:False]:=Module[{realKey},realKey=SahasLongKeyToRealKey[key];SahasGenerateHash[inputText,realKey,cyrillicLetters]];
SahasHasher["HelloWorld","mySecretKey"]
SahasHasher["HelloWorld",1234567890]
SahasHasher["HelloWorld","mySecretKey",True]
SahasEncode["Text"]
SahasDecode[{10,0,2}]
SahasStringKeyToRealKey["key"]
SahasLongKeyToRealKey[12345]


vectorize[x_,len_]:=ArrayReshape[Transpose[x],{len,1}];
invVectorize[x_,{r_,c_}]:=Transpose[ArrayReshape[x,{c,r}]];
k[\[Nu]_,l_,x_,y_]:=If[Norm[x-y]==0,1,Exp[-(Norm[x-y]/l)]];
Kint[X1_,X2_,l_]:=Table[k[1/2,l,X1[[i]],X2[[j]]],{i,Length[X1]},{j,Length[X2]}];
KK[tildeX_,M1_]:=Module[{A},A=Kint[tildeX,tildeX,1];KroneckerProduct[M1,A]];
rbcACmat[{\[Beta]_,\[Delta]_,\[Theta]_,\[Rho]_,aPar_,\[Gamma]_}]:=Module[{\[Eta],L1,L2,K11,K12,K22,S1,S2,S3,S4,S5,S6,MatPi,W,U,Cmat,CmatStar,ysteady,csteady,hstead},\[Eta]=1.0051;L1=(\[Eta]-\[Beta] (1-\[Delta]))/(\[Beta] \[Eta] \[Theta]^2);L2=(\[Rho] (\[Eta]-\[Beta] (1-\[Delta])))/(\[Eta]-\[Beta] (1-\[Theta]) (1-\[Delta]));K11=(\[Eta]-\[Beta] (1-\[Theta]) (1-\[Delta]))/(\[Beta] \[Eta] \[Theta]);K12=(\[Beta] \[Eta] \[Theta]^2-\[Eta]+\[Beta] (1-\[Theta]^2) (1-\[Delta]))/(\[Beta] \[Eta] \[Theta]^2);K22=(\[Eta] \[Theta])/(\[Eta]-\[Beta] (1-\[Theta]) (1-\[Delta]));S1=(K22-K11)/K12;S2=((K22-K11) L1-K12 L2)/(K12 (K11-\[Rho]));S3=K22;S4=(K12 L2)/(K22-K11)+((K22-\[Rho]) ((K22-K11) L1-K12 L2))/((K22-K11) (K11-\[Rho]));S5={1-((1-\[Theta]) S1)/\[Theta],S1+((\[Eta]/\[Beta]-1+\[Delta]) (\[Theta]-S1))/(\[Theta]^2 (\[Eta]-1+\[Delta])),1-S1/\[Theta]};S6={1/\[Theta]-((1-\[Theta]) S2)/\[Theta],S2+((\[Eta]/\[Beta]-1+\[Delta]) (1-S2))/(\[Theta]^2 (\[Eta]-1+\[Delta])),1/\[Theta]-S2/\[Theta]};U=Transpose[{Flatten[{S5,S1}],Flatten[{S6,S2}]}];MatPi={{S3,S4},{0,\[Rho]}};ysteady=(aPar^(1/(1-\[Theta])) (\[Theta]/(\[Eta]/\[Beta]-1+\[Delta]))^(\[Theta]/(1-\[Theta])) (1-\[Theta]))/(\[Gamma] (1-(\[Theta] (\[Eta]-1+\[Delta]))/(\[Eta]/\[Beta]-1+\[Delta])));csteady=(1-(\[Theta] (\[Eta]-1+\[Delta]))/(\[Eta]/\[Beta]-1+\[Delta])) ysteady;hstead=(1-\[Theta])/(\[Gamma] (1-(\[Theta] (\[Eta]-1+\[Delta]))/(\[Eta]/\[Beta]-1+\[Delta])));Cmat=Drop[U,{2}];CmatStar={{Log[ysteady]},{Log[hstead]},{Log[csteady]}};{MatPi,Cmat,CmatStar}];
spmatSigma[T_,dim_]:=Module[{idT,idDim},idT=IdentityMatrix[T,SparseArray];idDim=IdentityMatrix[dim,SparseArray];KroneckerProduct[Flatten[Table[KroneckerProduct[idDim,Transpose[{idT[[i]]}]],{i,T}],1],idDim]];
spmatL[M1_,T_]:=Module[{},KroneckerProduct[IdentityMatrix[T,SparseArray],Flatten[Table[KroneckerProduct[IdentityMatrix[T,SparseArray],Transpose[{M1[[1;;All,i]]}]],{i,Length[M1]}],1]]];
funcHM[KM_,dim_,T_]:=Module[{},KroneckerProduct[Flatten[Table[KroneckerProduct[IdentityMatrix[dim,SparseArray],Transpose[{KM[[1;;All,i]]}]],{i,T}],1],IdentityMatrix[dim,SparseArray]]];
logit[u_]:=Module[{x},x=SetPrecision[u,50];Log[x/(1-x)]];
invLogit[u_]:=Module[{x},x=SetPrecision[u,50];E^x/(1+E^x)];
linTanTransf[u_]:=Module[{x},x=SetPrecision[u,50];Tan[(x \[Pi])/2]];
invLinTanTransf[u_]:=Module[{x},x=SetPrecision[u,50];ArcTan[x]/(\[Pi]/2)];
reparametrizationMatern[L_]:=Log[L];
reparametrizationMaternInv[tilL_]:=Exp[tilL];
reparametrizationF[{\[Beta]_,\[Delta]_,\[Theta]_,\[Rho]_,aPar_,\[Gamma]_}]:={logit[\[Beta]],logit[\[Delta]],logit[\[Theta]],logit[\[Rho]],Log[aPar],Log[\[Gamma]]};
reparametrizationFInv[{til\[Beta]_,til\[Delta]_,til\[Theta]_,til\[Rho]_,tilaPar_,til\[Gamma]_}]:={invLogit[til\[Beta]],invLogit[til\[Delta]],invLogit[til\[Theta]],invLogit[til\[Rho]],Exp[tilaPar],Exp[til\[Gamma]]};
reparametrizationFQS[{Q_,Sigma_}]:=If[Dimensions[Q]=={2,2},{DiagonalMatrix[Log[Diagonal[Q]]],DiagonalMatrix[Log[Diagonal[Sigma]]]},{Log[Q],Log[Sigma]}];
reparametrizationFQSInv[{tilQ_,tilSigma_}]:=If[Dimensions[tilQ]=={2,2},{DiagonalMatrix[Exp[Diagonal[tilQ]]],DiagonalMatrix[Exp[Diagonal[tilSigma]]]},{Exp[tilQ],Exp[tilSigma]}];
ntil\[Beta]=.;ntil\[Delta]=.;ntil\[Theta]=.;ntil\[Rho]=.;ntilaPar=.;ntil\[Gamma]=.;
{Astruct,Cmatstruct,CmatStarstruct}=rbcACmat[reparametrizationFInv[{ntil\[Beta],ntil\[Delta],ntil\[Theta],ntil\[Rho],ntilaPar,ntil\[Gamma]}]];
derAstruct[{til\[Beta]_,til\[Delta]_,til\[Theta]_,til\[Rho]_,tilaPar_,til\[Gamma]_}]:=Table[\!\(
\*SubscriptBox[\(\[PartialD]\), \({{ntil\[Beta], ntil\[Delta], ntil\[Theta], ntil\[Rho], ntilaPar, ntil\[Gamma]}}\)]\(Astruct[[i, j]]\)\),{i,2},{j,2}]/. {ntil\[Beta]->til\[Beta],ntil\[Delta]->til\[Delta],ntil\[Theta]->til\[Theta],ntil\[Rho]->til\[Rho],ntilaPar->tilaPar,ntil\[Gamma]->til\[Gamma]};
derCmatstruct[{til\[Beta]_,til\[Delta]_,til\[Theta]_,til\[Rho]_,tilaPar_,til\[Gamma]_}]:=Table[\!\(
\*SubscriptBox[\(\[PartialD]\), \({{ntil\[Beta], ntil\[Delta], ntil\[Theta], ntil\[Rho], ntilaPar, ntil\[Gamma]}}\)]\(Cmatstruct[[i, j]]\)\),{i,3},{j,2}]/. {ntil\[Beta]->til\[Beta],ntil\[Delta]->til\[Delta],ntil\[Theta]->til\[Theta],ntil\[Rho]->til\[Rho],ntilaPar->tilaPar,ntil\[Gamma]->til\[Gamma]};
derCmatStarstruct[{til\[Beta]_,til\[Delta]_,til\[Theta]_,til\[Rho]_,tilaPar_,til\[Gamma]_}]:=Table[\!\(
\*SubscriptBox[\(\[PartialD]\), \({{ntil\[Beta], ntil\[Delta], ntil\[Theta], ntil\[Rho], ntilaPar, ntil\[Gamma]}}\)]\(CmatStarstruct[[i, j]]\)\),{i,3},{j,1}]/. {ntil\[Beta]->til\[Beta],ntil\[Delta]->til\[Delta],ntil\[Theta]->til\[Theta],ntil\[Rho]->til\[Rho],ntilaPar->tilaPar,ntil\[Gamma]->til\[Gamma]};
derKM[X1T_,tilL_]:=Table[k[1/2,Exp[tilL],X1T[[i]],X1T[[j]]] Norm[X1T[[i]]-X1T[[j]]] Exp[-tilL],{i,Length[X1T]},{j,Length[X1T]}];
upperTriangular[v_,n_]:=Module[{i=0},Array[If[#1>#2,0,v[[++i]]]&,{n,n}]];
transitionDrawPG[xt1_,A_,Q_]:=RandomVariate[MultinormalDistribution[Flatten[A . xt1],Q]];
positivizeMatrix[X_]:=Module[{res,auxsystDP,duDP,wDP,lenRes,powerDP},res=0.5 (X+Transpose[X]);If[!PositiveDefiniteMatrixQ[res]||MatrixRank[res]!=Length[res],auxsystDP=Eigensystem[res];duDP=DiagonalMatrix[auxsystDP[[1]]];wDP=ReplacePart[duDP,{i_,i_}/;duDP[[i,i]]<=0:>0];lenRes=Length[res];powerDP=30;While[!PositiveDefiniteMatrixQ[res]||MatrixRank[res]!=lenRes,res=Transpose[auxsystDP[[2]]] . (wDP+IdentityMatrix[lenRes] $MinMachineNumber 2^-powerDP) . auxsystDP[[2]];res=0.5 (res+Transpose[res]);powerDP--;];];res];
logMultinormalDens[x_,mean_,var2_]:=Module[{t,det,var},var=positivizeMatrix[var2];t=Quiet[0.5 (x-mean) . LinearSolve[var,x-mean,Method->"Cholesky"]];det=(2 \[Pi])^Length[var] Det[var]^0.5;-t-Log[det]];
logCondNormal[vecy1T_,X1T_,t1_,t2_,M1PG_,tilL_,CmatPG_,CmatStarPG_,SigmaPG_]:=Module[{fvecy1T,vecy1tminus1,vecytT,mean,mean1tminus1,meantT,X1t2,varMat,varMatTT,varMat1t,varMat1tT,meancond,varcond,t,det},fvecy1T=Flatten[vecy1T];vecy1tminus1=fvecy1T[[1;;3 t1]];vecytT=fvecy1T[[3 t1+1;;3 t2]];mean=Flatten[KroneckerProduct[IdentityMatrix[t2],CmatPG] . ArrayReshape[X1T,{2 t2,1}]+KroneckerProduct[ConstantArray[1,t2],IdentityMatrix[3]] . CmatStarPG];mean1tminus1=mean[[1;;3 t1]];meantT=mean[[3 t1+1;;All]];X1t2=X1T[[1;;t2]];varMat=positivizeMatrix[KroneckerProduct[Kint[X1t2,X1t2,Exp[tilL]],M1PG]+KroneckerProduct[IdentityMatrix[t2],SigmaPG]];varMatTT=varMat[[3 t1+1;;All,3 t1+1;;All]];varMat1t=varMat[[1;;3 t1,1;;3 t1]];varMat1tT=varMat[[1;;3 t1,3 t1+1;;All]];meancond=Quiet[Flatten[meantT+Transpose[varMat1tT] . LinearSolve[varMat1t,vecy1tminus1-mean1tminus1]]];varcond=Quiet[varMatTT-Transpose[varMat1tT] . LinearSolve[varMat1t,varMat1tT]];varcond=positivizeMatrix[varcond];t=Quiet[0.5 (vecytT-meancond) . LinearSolve[varcond,vecytT-meancond,Method->"Cholesky"]];det=(2 \[Pi])^Length[varcond] Det[varcond]^0.5;-t-Log[det]];
newMeanEcon[___]:="Not defined here.";
newMeanVars[___]:="Not defined here.";
newMeanL[___]:="Not defined here.";
newMeanM1[___]:="Not defined here.";
logMarginalLikelihood[vecy1T_,X1T_,T_,{M1_,{til\[Beta]_,til\[Delta]_,til\[Theta]_,til\[Rho]_,tilaPar_,til\[Gamma]_},tilL_,{tilQMat_,tilSigmaMat_}}]:=Module[{vecx1TLik,ALik,CmatLik,CmatStarLik,QLik,SigmaLik,KMLik,resLik,x2TLik,x1T1Lik,vecx2TLik,vecx1T1Lik},vecx1TLik=ArrayReshape[X1T,{Times@@Dimensions[X1T],1}];{ALik,CmatLik,CmatStarLik}=rbcACmat[reparametrizationFInv[{til\[Beta],til\[Delta],til\[Theta],til\[Rho],tilaPar,til\[Gamma]}]];{QLik,SigmaLik}=reparametrizationFQSInv[{tilQMat,tilSigmaMat}];If[T==1,KMLik={{1}};resLik=logMultinormalDens[X1T[[1]],{0,0},IdentityMatrix[2]]+logMultinormalDens[Flatten[vecy1T],Flatten[KroneckerProduct[IdentityMatrix[T],CmatLik] . Flatten[vecx1TLik]+KroneckerProduct[ConstantArray[1,T],IdentityMatrix[3]] . CmatStarLik],KroneckerProduct[KMLik,M1]+KroneckerProduct[IdentityMatrix[T],SigmaLik]]];If[T>=2,x2TLik=Drop[X1T,1];x1T1Lik=Drop[X1T,-1];vecx2TLik=ArrayReshape[x2TLik,{Times@@Dimensions[x2TLik],1}];vecx1T1Lik=ArrayReshape[x1T1Lik,{Times@@Dimensions[x1T1Lik],1}];KMLik=Kint[X1T,X1T,Exp[tilL]];resLik=logMultinormalDens[X1T[[1]],{0,0},IdentityMatrix[2]]+logMultinormalDens[Flatten[vecx2TLik],Flatten[KroneckerProduct[IdentityMatrix[T-1],ALik] . vecx1T1Lik],KroneckerProduct[IdentityMatrix[T-1],QLik]]+logMultinormalDens[Flatten[vecy1T],Flatten[KroneckerProduct[IdentityMatrix[T],CmatLik] . vecx1TLik+KroneckerProduct[ConstantArray[1,T],IdentityMatrix[3]] . CmatStarLik],KroneckerProduct[KMLik,M1]+KroneckerProduct[IdentityMatrix[T],SigmaLik]]];resLik];
multi\[CapitalGamma][p_,a_]:=\[Pi]^(1/4 p (p-1)) \!\(
\*UnderoverscriptBox[\(\[Product]\), \(j = 1\), \(p\)]\(Gamma[a + 
\*FractionBox[\(1 - j\), \(2\)]]\)\);
logDensInvWish[\[CapitalSigma]_,\[Nu]_,X2_]:=Module[{len,Xdens,cond,logpropconst},len=Length[\[CapitalSigma]];Xdens=0.5 (X2+Transpose[X2]);cond=0.5 Tr[\[CapitalSigma] . Inverse[Xdens]];logpropconst=Log[Abs[Det[\[CapitalSigma]]]^(\[Nu]/2)]-Log[2^((\[Nu] len)/2) multi\[CapitalGamma][len,\[Nu]/2]]+Log[Norm[Det[Xdens]]^(-(1/2) (\[Nu]+len+1))];-cond+logpropconst];
logChangEaves[X_]:=Module[{len,Xdens},len=Length[X];Xdens=0.5 (X+Transpose[X]);Log[Norm[Det[Xdens]]^(-0.5 (len+1))]+Log[1/Norm[Det[IdentityMatrix[len]+Xdens Inverse[Xdens]]]^0.5]];
absDetJacob[{til\[Beta]_,til\[Delta]_,til\[Theta]_,til\[Rho]_,tilaPar_,til\[Gamma]_},tilL_,{tilQMat_,tilSigmaMat_}]:=Abs[(Exp[til\[Beta]] Exp[til\[Delta]] Exp[til\[Theta]] Exp[til\[Rho]] Exp[tilaPar+til\[Gamma]+tilL] Times@@Exp[Diagonal[tilQMat]] Times@@Exp[Diagonal[tilSigmaMat]])/((1+Exp[til\[Beta]])^2 (1+Exp[til\[Delta]])^2 (1+Exp[til\[Theta]])^2 (1+Exp[til\[Rho]])^2)];
logPriorTheta[{M1_,{til\[Beta]_,til\[Delta]_,til\[Theta]_,til\[Rho]_,tilaPar_,til\[Gamma]_},tilL_,{tilQMat_,tilSigmaMat_}}]:=Module[{\[Beta]prior,\[Delta]prior,\[Theta]prior,\[Rho]prior,aParprior,\[Gamma]prior,Qprior,Sigmaprior},{\[Beta]prior,\[Delta]prior,\[Theta]prior,\[Rho]prior,aParprior,\[Gamma]prior}=reparametrizationFInv[{til\[Beta],til\[Delta],til\[Theta],til\[Rho],tilaPar,til\[Gamma]}];{Qprior,Sigmaprior}=reparametrizationFQSInv[{tilQMat,tilSigmaMat}];Log[PDF[BetaDistribution[9.9,1.7],\[Beta]prior] PDF[BetaDistribution[1,10],\[Delta]prior] PDF[BetaDistribution[5,10],\[Theta]prior] PDF[BetaDistribution[9.9,1.7],\[Rho]prior] PDF[GammaDistribution[10,0.5],aParprior] PDF[GammaDistribution[0.25,0.1],\[Gamma]prior] PDF[GammaDistribution[2,2],Exp[tilL]] PDF[InverseGammaDistribution[2.5,0.5],Qprior[[1,1]]] PDF[InverseGammaDistribution[2.5,0.5],Qprior[[2,2]]] PDF[InverseGammaDistribution[2.5,0.5],Sigmaprior[[1,1]]] PDF[InverseGammaDistribution[2.5,0.5],Sigmaprior[[2,2]]] PDF[InverseGammaDistribution[2.5,0.5],Sigmaprior[[3,3]]] absDetJacob[{til\[Beta],til\[Delta],til\[Theta],til\[Rho],tilaPar,til\[Gamma]},tilL,{tilQMat,tilSigmaMat}]]+logDensInvWish[IdentityMatrix[3],15,M1]];
pathname=Quiet[Check[NotebookDirectory[],""]];
startTime=10;
endTime=15;
sizeApproxY=50;
sampleSize=5;
numParticles=5;
stepSize=0.0001;
nuM1=15;
s1M1=1;
varSize=0.1;
sizeBurnIn=1;
data={{{"","GDPC1","PCECC96","GDPIC1","CNP16OV","PNF_HOURS","","y","c","h"},{1948.,1196.5,986.7,209.8,0.102690666666667,81.67266666666667,"",2912.874263159252,2402.117037575624,198.83176660001496},{1948.25,1218.2,997.8,220.4,0.102915333333333,81.24266666666666,"",2959.2286215853906,2423.8370699539505,197.3531640895759},{1948.5,1220.8,999.7,221.1,0.103249,82.021,"",2955.9608325504364,2420.6045579133943,198.59998644054664},{1948.75,1218.1,1008.,210.1,0.103417666666667,81.39966666666668,"",2944.6129449191367,2436.7209986688204,196.77408437629873},{1949.,1187.3,1009.,178.3,0.103584333333333,79.61099999999999,"",2865.539512088388,2435.213819335622,192.14054248872958}}};
output=Drop[data[[1,All,8]],1];
consumption=Drop[data[[1,All,9]],1];
hours=Drop[data[[1,All,10]],1];
invest=output-consumption;
intercept=Table[i,{i,1,Length[output]}] Log[1.0051];
{loutput,lhours,lconsumption}={Log[output]-intercept,Log[hours],Log[consumption]-intercept};
Y1T=Transpose[{loutput,lhours,lconsumption}];
predictionNSteps[Y_,start_,end_,sz_,samp_,parts_,step_,var_,burn_]:=Module[{},Print["Prediction requested with arguments:"];Print["Y (data matrix):",Y];Print["Time interval: ",start," to ",end];Print["Other params: sz=",sz,", samp=",samp,", parts=",parts,", step=",step,", var=",var,", burn=",burn];Table[{t,Mean[Flatten[Y]]+0.01 t},{t,start,end}]];
predictionNSteps[Y1T,startTime,endTime,sizeApproxY,sampleSize,numParticles,stepSize,varSize,sizeBurnIn]


CornerCoords=Table[{0.25 IntegerDigits[i,4,2][[2]]+0.0,0.75-0.25 IntegerDigits[i,4,2][[1]]},{i,0,15}];
d=0.01;
RectCoords=Table[{{d,d}+Cor,{0.25-d,0.25-d}+Cor},{Cor,CornerCoords}];
ZeroC=RGBColor["#29AB87"];
OneC=RGBColor["#0F52BA"];
PauliText={Text[Style[ToExpression["II",TeXForm,HoldForm],Large],{0.125,1.125}],Text[Style[ToExpression["IZ",TeXForm,HoldForm],Large],{0.375,1.125}],Text[Style[ToExpression["IX",TeXForm,HoldForm],Large],{0.625,1.125}],Text[Style[ToExpression["IY",TeXForm,HoldForm],Large],{0.875,1.125}],Text[Style[ToExpression["II",TeXForm,HoldForm],Large],{-0.125,0.875}],Text[Style[ToExpression["ZI",TeXForm,HoldForm],Large],{-0.125,0.625}],Text[Style[ToExpression["XI",TeXForm,HoldForm],Large],{-0.125,0.375}],Text[Style[ToExpression["YI",TeXForm,HoldForm],Large],{-0.125,0.125}]};
DividingLines={{Gray,Line[{{0.25,0.0},{0.25,1.25}}]},{Gray,Line[{{0.5,0.0},{0.5,1.25}}]},{Gray,Line[{{0.75,0.0},{0.75,1.25}}]},{Gray,Line[{{-0.25,0.25},{1.0,0.25}}]},{Gray,Line[{{-0.25,0.5},{1.0,0.5}}]},{Gray,Line[{{-0.25,0.75},{1.0,0.75}}]},{Black,Line[{{-0.25,1.0},{1.0,1.0}}]},{Black,Line[{{0.0,0.0},{0.0,1.25}}]}};
DividingLinesRaw={{Gray,Line[{{0.25,0.0},{0.25,1.0}}]},{Gray,Line[{{0.5,0.0},{0.5,1.0}}]},{Gray,Line[{{0.75,0.0},{0.75,1.0}}]},{Gray,Line[{{0.0,0.25},{1.0,0.25}}]},{Gray,Line[{{0.0,0.5},{1.0,0.5}}]},{Gray,Line[{{0.0,0.75},{1.0,0.75}}]}};
ProjPauliTups=Tuples[{0,1},4];
ProjPauliStr={"II","IX","IY","IZ","XI","XX","XY","XZ","YI","YX","YY","YZ","ZI","ZX","ZY","ZZ"};
PauliDict=Association["II"->{{0,0},{0,0},0},"IX"->{{0,1},{0,0},0},"IY"->{{0,1},{0,1},0},"IZ"->{{0,0},{0,1},0},"XI"->{{1,0},{0,0},0},"XX"->{{1,1},{0,0},0},"XY"->{{1,1},{0,1},0},"XZ"->{{1,0},{0,1},0},"YI"->{{1,0},{1,0},0},"YX"->{{1,1},{1,0},0},"YY"->{{1,1},{1,1},0},"YZ"->{{1,0},{1,1},0},"ZI"->{{0,0},{1,0},0},"ZX"->{{0,1},{1,0},0},"ZY"->{{0,1},{1,1},0},"ZZ"->{{0,0},{1,1},0}];
Tup2BS[Tup_]:={{Tup[[1]],Tup[[3]]},{Tup[[2]],Tup[[4]]},0};
BS2Tup[BS_]:={BS[[1,1]],BS[[2,1]],BS[[1,2]],BS[[2,2]]};
R2I[A_]:=If[Length[A]==3,FromDigits[BS2Tup[A],2]+1,FromDigits[A,2]+1];
I2T[I _]:=IntegerDigits[-1+I,2,4];
RectProperties[ontic_,ind_]:={If[ontic[[2,ind]]==1,OneC,ZeroC],Rectangle[RectCoords[[ind,1]],RectCoords[[ind,2]]]};
RectList[ontic_]:=Module[{pl=R2I[ontic[[1]]]},Flatten[{Table[RectProperties[ontic,i],{i,1,16}],{Disk[{0.125-d,0.125-d}+RectCoords[[pl,1]],0.07]}}]];
FiniteStatePauli[l_]:=Table[Graphics[Join[RectList[l[[i]]],PauliText,DividingLines],PlotRange->{{-0.25,1.0},{0,1.25}},ImageSize->300],{i,Length[l]}];
FiniteStateRaw[l_]:=Table[Graphics[Join[RectList[l[[i]]],DividingLinesRaw],PlotRange->{{0,1.0},{0,1.0}},ImageSize->300],{i,Length[l]}];
BSInner[s1_,s2_]:=Mod[s1[[1]] . s2[[2]]-s2[[1]] . s1[[2]],4];
BetaFn[s1_,s2_]:=Mod[1/2 (BSInner[s1,s2]+2 \!\(
\*UnderoverscriptBox[\(\[Sum]\), \(i\), \(2\)]\((s1[[2, i]]\ \((s1[[1, i]] + s2[[1, i]])\)\ s2[[2, i]] + s1[[1, i]]\ s2[[1, i]]\ \((s1[[2, i]] + s2[[2, i]])\))\)\)),2];
stabgroup[g1_,g2_]:=Catch[If[OddQ[BSInner[g1,g2]],Throw["Error: Generators do not commute."],Mod[{{{0,0},{0,0},0},g1,g2,{g1[[1]]+g2[[1]],g1[[2]]+g2[[2]],BetaFn[g1,g2]+g1[[3]]+g2[[3]]}},2]]];
ConsistentPhase[SG_]:=Module[{\[Gamma]},\[Gamma]=RandomInteger[1,16];Do[\[Gamma][[R2I[s]]]=s[[3]],{s,SG}];\[Gamma]];
SampleLambda[S_]:=If[Length[S]>1,{BS2Tup[RandomChoice[S[[2;;4]]]],ConsistentPhase[S]},{I2T[RandomInteger[{2,16}]],ConsistentPhase[S]}];
GammaId[\[Lambda]_]:=\[Lambda];
GammaP[P_,\[Lambda]_]:=Module[{lt=\[Lambda]},Do[lt[[2,i]]=Mod[If[EvenQ[BSInner[P,Tup2BS[I2T[i]]]],0,1]+\[Lambda][[2,i]],2],{i,1,16}];lt];
HBS[i_,S_]:=Module[{s=S},s[[1,i]]=S[[2,i]];s[[2,i]]=S[[1,i]];s[[3]]=Mod[S[[3]]+S[[1,i]] S[[2,i]],2];s];
HTup[i_,S_]:=BS2Tup[HBS[i,Tup2BS[S]]];
GammaH[i_,\[Lambda]_]:=Module[{lt=\[Lambda]},lt[[1]]=HTup[i,\[Lambda][[1]]];Do[lt[[2,R2I[HTup[i,I2T[j]]]]]=Mod[HBS[i,Tup2BS[I2T[j]]][[3]]+\[Lambda][[2,j]],2],{j,1,16}];lt];
SBS[i_,S_]:=Module[{s=S},s[[2,i]]=Mod[S[[1,i]]+S[[2,i]],2];s[[3]]=Mod[S[[3]]+S[[1,i]] S[[2,i]],2];s];
STup[i_,S_]:=BS2Tup[SBS[i,Tup2BS[S]]];
GammaS[i_,\[Lambda]_]:=Module[{lt=\[Lambda]},lt[[1]]=STup[i,\[Lambda][[1]]];Do[lt[[2,R2I[STup[i,I2T[j]]]]]=Mod[SBS[i,Tup2BS[I2T[j]]][[3]]+\[Lambda][[2,j]],2],{j,1,16}];lt];
CNOTBS[a_,b_,S_]:=Module[{s=S},s[[1,b]]=Mod[S[[1,a]]+S[[1,b]],2];s[[2,a]]=Mod[S[[2,a]]+S[[2,b]],2];s[[3]]=Mod[S[[3]]+Mod[S[[1,b]]+S[[2,a]]+1,2] (S[[1,a]] S[[2,b]]),2];s];
CNOTTup[a_,b_,S_]:=BS2Tup[CNOTBS[a,b,Tup2BS[S]]];
GammaCNOT[a_,b_,\[Lambda]_]:=Module[{lt=\[Lambda]},lt[[1]]=CNOTTup[a,b,\[Lambda][[1]]];Do[lt[[2,R2I[CNOTTup[a,b,I2T[j]]]]]=Mod[CNOTBS[a,b,Tup2BS[I2T[j]]][[3]]+\[Lambda][[2,j]],2],{j,1,16}];lt];
GammaSWAP[\[Lambda]_]:=GammaCNOT[1,2,GammaCNOT[2,1,GammaCNOT[1,2,\[Lambda]]]];
GammaCZRedux[a_,b_,\[Lambda]_]:=GammaH[b,GammaCNOT[a,b,GammaH[b,\[Lambda]]]];
GammaCZ[\[Lambda]_]:=GammaH[2,GammaCNOT[1,2,GammaH[2,\[Lambda]]]];
MmtOutcome[M_,\[Lambda]_]:=If[Length[M]==3,\[Lambda][[2,FromDigits[BS2Tup[M],2]+1]]+M[[3]],\[Lambda][[2,FromDigits[M,2]+1]]];
GenerateCommutingSubset[P_,InG_]:=Select[InG,EvenQ[BSInner[Tup2BS[#1],Tup2BS[P]]]&];
GenerateACommutingSubset[P_,InG_]:=Select[InG,OddQ[BSInner[Tup2BS[#1],Tup2BS[P]]]&];
CommutingCase[M_,\[Lambda]_]:=Module[{\[Gamma]=\[Lambda][[2]]},Do[\[Gamma][[R2I[s]]]=RandomInteger[1],{s,GenerateACommutingSubset[BS2Tup[M],GenerateCommutingSubset[\[Lambda][[1]],ProjPauliTups]]}];\[Gamma][[R2I[Mod[BS2Tup[M]+\[Lambda][[1]],2]]]]=Mod[BetaFn[M,Tup2BS[\[Lambda][[1]]]]+\[Lambda][[2,R2I[M]]]+\[Lambda][[2,R2I[\[Lambda][[1]]]]],2];\[Gamma]];
AntiCommutingCase[M_,\[Lambda]_]:=Module[{\[Gamma]=\[Lambda][[2]]},Do[\[Gamma][[R2I[s]]]=RandomInteger[1],{s,GenerateACommutingSubset[BS2Tup[M],GenerateCommutingSubset[\[Lambda][[1]],ProjPauliTups]]}];Do[\[Gamma][[R2I[Mod[s+BS2Tup[M],2]]]]=Mod[BetaFn[M,Tup2BS[s]]+\[Lambda][[2,R2I[M]]]+\[Lambda][[2,R2I[s]]],2],{s,GenerateCommutingSubset[BS2Tup[M],GenerateCommutingSubset[\[Lambda][[1]],ProjPauliTups]]}];\[Gamma]];
PhaseUpdate[M_,\[Lambda]_]:=If[EvenQ[BSInner[M,Tup2BS[\[Lambda][[1]]]]],CommutingCase[M,\[Lambda]],AntiCommutingCase[M,\[Lambda]]];
OnticMeasurementUpdate[M_,\[Lambda]_]:={If[Length[M]==3,BS2Tup[M],M],PhaseUpdate[M,\[Lambda]]};
LocateMcell[M_,\[Lambda]_]:=Module[{G=RectList[\[Lambda]]},PrependTo[G[[R2I[M]]],If[EvenQ[BSInner[M,Tup2BS[\[Lambda][[1]]]]],EdgeForm[{Thickness[0.01],Green,Dashed}],EdgeForm[{Thickness[0.01],Green}]]];AppendTo[G,{Opacity[0.5],Disk[{0.125-d,0.125-d}+RectCoords[[R2I[M]]][[1]],0.07]}];G];
LocateDetUpdates[M_,\[Lambda]_]:=Module[{G=LocateMcell[M,\[Lambda]]},If[EvenQ[BSInner[M,Tup2BS[\[Lambda][[1]]]]],PrependTo[G[[R2I[Mod[BS2Tup[M]+\[Lambda][[1]],2]]]],EdgeForm[{Thickness[0.01]}]];AppendTo[G,{EdgeForm[{Thickness[0.01],Green,Dashed}],Transparent,G[[R2I[Mod[BS2Tup[M]+\[Lambda][[1]],2]]]][[3]]}];PrependTo[G[[R2I[Mod[BS2Tup[M]+\[Lambda][[1]],2]]]],Opacity[0.5]],Do[PrependTo[G[[R2I[s]]],EdgeForm[{Thickness[0.01],Purple}]];PrependTo[G[[R2I[Mod[s+BS2Tup[M],2]]]],EdgeForm[{Thickness[0.01],Purple}]];AppendTo[G,{EdgeForm[{Thickness[0.01],Green,Dashed}],Transparent,G[[R2I[Mod[s+BS2Tup[M],2]]]][[3]]}];PrependTo[G[[R2I[Mod[s+BS2Tup[M],2]]]],Opacity[0.5]],{s,GenerateCommutingSubset[BS2Tup[M],GenerateCommutingSubset[\[Lambda][[1]],ProjPauliTups]]}]];G];
LocateRandUpdates[M_,\[Lambda]_]:=Module[{G=LocateDetUpdates[M,\[Lambda]]},Do[PrependTo[G[[R2I[s]]],Opacity[0.5]],{s,GenerateACommutingSubset[BS2Tup[M],GenerateCommutingSubset[\[Lambda][[1]],ProjPauliTups]]}];G];
UpdateSteps[M_,\[Lambda]_]:={\[Lambda][[2,R2I[M]]],Graphics[{RectList[\[Lambda]],DividingLinesRaw},PlotRange->{{0,1},{0,1}}],Graphics[{LocateMcell[M,\[Lambda]],DividingLinesRaw},PlotRange->{{0,1},{0,1}}],Graphics[{LocateDetUpdates[M,\[Lambda]],DividingLinesRaw},PlotRange->{{0,1},{0,1}}],Graphics[{LocateRandUpdates[M,\[Lambda]],DividingLinesRaw},PlotRange->{{0,1},{0,1}}],Graphics[{RectList[OnticMeasurementUpdate[M,\[Lambda]]],DividingLinesRaw},PlotRange->{{0,1},{0,1}}]};
ConvertPrep[prep_]:=Module[{PBs},PBs=Table[PauliDict[StringTake[s,-2]],{s,prep}];Do[If[StringLength[prep[[i]]]==3,PBs[[i,3]]=1],{i,Length[prep]}];PBs];
ChoosePrep[prep_]:=Module[{w},w=If[Length[prep]==1,ConstantArray[1,Length[prep[[1]]]]/Length[prep[[1]]],prep[[2]]];RandomChoice[w->prep[[1]]]];
ChooseTrans[trans_]:=Module[{w},w=If[Length[trans]==1,ConstantArray[1,Length[trans[[1]]]]/Length[trans[[1]]],trans[[2]]];RandomChoice[w->trans[[1]]]];
ChooseMmt[mmt_]:=Module[{w},w=If[Length[mmt]==1,ConstantArray[1,Length[mmt[[1]]]]/Length[mmt[[1]]],mmt[[2]]];RandomChoice[w->mmt[[1]]]];
ChooseAdaptiveT[op_,outs_]:=Module[{c=ChooseTrans[op[[1]]]},Do[If[outs[[cond[[1]]]]==cond[[2]],c=ChooseTrans[cond[[3]]]],{cond,op[[2]]}];c];
ChooseAdaptiveM[op_,outs_]:=Module[{c=ChooseMmt[op[[1]]]},Do[If[outs[[cond[[1]]]]==cond[[2]],c=ChooseMmt[cond[[3]]]],{cond,op[[2]]}];c];
ImplementAdaptiveT[op_,outp_]:=Module[{opn,\[Lambda]2},opn=ChooseAdaptiveT[op,outp[[2]]];\[Lambda]2=CliffordDict[opn][Last[outp[[3]]]];{opn,\[Lambda]2}];
ImplementNonAdaptiveT[op_,outp_]:=Module[{opn,\[Lambda]2},opn=ChooseTrans[op];\[Lambda]2=CliffordDict[opn][Last[outp[[3]]]];{opn,\[Lambda]2}];
ImplementAdaptiveM[op_,outp_]:=Module[{m,res,\[Lambda]2},m=ChooseAdaptiveM[op,outp[[2]]];res=MmtOutcome[PauliDict[m],Last[outp[[3]]]];\[Lambda]2=MmtDict[m][Last[outp[[3]]]];{m,res,\[Lambda]2}];
ImplementNonAdaptiveM[op_,outp_]:=Module[{m,res,\[Lambda]2},m=ChooseMmt[op];res=MmtOutcome[PauliDict[m],Last[outp[[3]]]];\[Lambda]2=MmtDict[m][Last[outp[[3]]]];{m,res,\[Lambda]2}];
CliffordDict=Association["II"->GammaId,"IX"->Function[l,GammaP[{{0,1},{0,0},0},l]],"IY"->Function[l,GammaP[{{0,1},{0,1},0},l]],"IZ"->Function[l,GammaP[{{0,0},{0,1},0},l]],"XI"->Function[l,GammaP[{{1,0},{0,0},0},l]],"XX"->Function[l,GammaP[{{1,1},{0,0},0},l]],"XY"->Function[l,GammaP[{{1,1},{0,1},0},l]],"XZ"->Function[l,GammaP[{{1,0},{0,1},0},l]],"YI"->Function[l,GammaP[{{1,0},{1,0},0},l]],"YX"->Function[l,GammaP[{{1,1},{1,0},0},l]],"YY"->Function[l,GammaP[{{1,1},{1,1},0},l]],"YZ"->Function[l,GammaP[{{1,0},{1,1},0},l]],"ZI"->Function[l,GammaP[{{0,0},{1,0},0},l]],"ZX"->Function[l,GammaP[{{0,1},{1,0},0},l]],"ZY"->Function[l,GammaP[{{0,1},{1,1},0},l]],"ZZ"->Function[l,GammaP[{{0,0},{1,1},0},l]],"IH"->Function[l,GammaH[2,l]],"HI"->Function[l,GammaH[1,l]],"IS"->Function[l,GammaS[2,l]],"SI"->Function[l,GammaS[1,l]],"CNOT12"->Function[l,GammaCNOT[1,2,l]],"CNOT21"->Function[l,GammaCNOT[2,1,l]],"CZ"->Function[l,GammaCZ[l]]];
MmtDict=Association["II"->GammaId,"IX"->Function[l,OnticMeasurementUpdate[{{0,1},{0,0},0},l]],"IY"->Function[l,OnticMeasurementUpdate[{{0,1},{0,1},0},l]],"IZ"->Function[l,OnticMeasurementUpdate[{{0,0},{0,1},0},l]],"XI"->Function[l,OnticMeasurementUpdate[{{1,0},{0,0},0},l]],"XX"->Function[l,OnticMeasurementUpdate[{{1,1},{0,0},0},l]],"XY"->Function[l,OnticMeasurementUpdate[{{1,1},{0,1},0},l]],"XZ"->Function[l,OnticMeasurementUpdate[{{1,0},{0,1},0},l]],"YI"->Function[l,OnticMeasurementUpdate[{{1,0},{1,0},0},l]],"YX"->Function[l,OnticMeasurementUpdate[{{1,1},{1,0},0},l]],"YY"->Function[l,OnticMeasurementUpdate[{{1,1},{1,1},0},l]],"YZ"->Function[l,OnticMeasurementUpdate[{{1,0},{1,1},0},l]],"ZI"->Function[l,OnticMeasurementUpdate[{{0,0},{1,0},0},l]],"ZX"->Function[l,OnticMeasurementUpdate[{{0,1},{1,0},0},l]],"ZY"->Function[l,OnticMeasurementUpdate[{{0,1},{1,1},0},l]],"ZZ"->Function[l,OnticMeasurementUpdate[{{0,0},{1,1},0},l]]];
RunCircuit[cir_]:=Module[{out={{},{},{}},prep,grp},prep=ChoosePrep[cir[[1]]];grp=If[Length[prep]>1,stabgroup@@Take[ConvertPrep[{prep}],2],{{{0,0},{0,0},0}}];out[[1]]={prep};out[[3]]={SampleLambda[grp]};Do[Switch[op[[1]],"T",If[op[[2]],With[{t=ImplementAdaptiveT[op[[3]],out]},AppendTo[out[[1]],t[[1]]];AppendTo[out[[3]],t[[2]]];],With[{t=ImplementNonAdaptiveT[op[[3]],out]},AppendTo[out[[1]],t[[1]]];AppendTo[out[[3]],t[[2]]];]],"M",If[op[[2]],With[{m=ImplementAdaptiveM[op[[3]],out]},AppendTo[out[[1]],m[[1]]];AppendTo[out[[2]],m[[2]]];AppendTo[out[[3]],m[[3]]];],With[{m=ImplementNonAdaptiveM[op[[3]],out]},AppendTo[out[[1]],m[[1]]];AppendTo[out[[2]],m[[2]]];AppendTo[out[[3]],m[[3]]];]]],{op,Rest[cir]}];out];
RunCircuitFromInput[cir_,in0_]:=Module[{out=in0},Do[Switch[op[[1]],"T",If[op[[2]],With[{t=ImplementAdaptiveT[op[[3]],out]},AppendTo[out[[1]],t[[1]]];AppendTo[out[[3]],t[[2]]];],With[{t=ImplementNonAdaptiveT[op[[3]],out]},AppendTo[out[[1]],t[[1]]];AppendTo[out[[3]],t[[2]]];]],"M",If[op[[2]],With[{m=ImplementAdaptiveM[op[[3]],out]},AppendTo[out[[1]],m[[1]]];AppendTo[out[[2]],m[[2]]];AppendTo[out[[3]],m[[3]]];],With[{m=ImplementNonAdaptiveM[op[[3]],out]},AppendTo[out[[1]],m[[1]]];AppendTo[out[[2]],m[[2]]];AppendTo[out[[3]],m[[3]]];]]],{op,cir}];out];
CircEx={{{"IZ","ZI"}},{"T",False,{{"HI","SI"}}},{"M",False,{{"IX"}}},{"T",True,{{{"II"}},{{1,0,{{"ZX"}}}}}},{"M",False,{{"XZ","YY"},{0.5,0.5}}},{"M",True,{{{"XX"}},{{2,0,{{"IZ"}}},{2,1,{{"ZX"}}}}}}};
out1=RunCircuit[CircEx];
FiniteStatePauli[out1[[3]]]
FiniteStateRaw[out1[[3]]]


DynamicModule[{symbols={"\|01f352","\|01f347","\|01f34b","\|01f349","\|01f34a"},values=Association["\|01f352"->10,"\|01f347"->20,"\|01f34b"->30,"\|01f349"->40,"\|01f34a"->60],reelFinals,spinStart,spinning=False,godMode=False,winnings=0},reelFinals=ConstantArray["",3];spinStart=0;Deploy[Column[{Style["THE SLOTS",34,FontFamily->"Bebas Neue"],Spacer[20],Row[Table[With[{ii=ii},Dynamic[Style[If[spinning&&AbsoluteTime[]-spinStart<1.6,RandomChoice[symbols],reelFinals[[ii]]],FontSize->48],UpdateInterval->0.05]],{ii,1,3}],Spacer[20]],Spacer[20],Row[{Button["Spin",If[!spinning,spinning=True;spinStart=AbsoluteTime[];RunScheduledTask[reelFinals=Table[RandomChoice[symbols],{3}];If[godMode,reelFinals=ConstantArray[First[reelFinals],3];];If[Length[Union[reelFinals]]==1,winnings+=values[reelFinals[[1]]]];spinning=False;,{1.6,1}];],ImageSize->{80,40}],Spacer[20],Button["God's Eye",godMode=!godMode,Appearance->Dynamic[If[godMode,"Pressed","Normal"]],ImageSize->{80,40}]}],Spacer[20],Dynamic[Style["Winnings: "<>ToString[winnings],20]]},Alignment->Center]]]


ClearAll[offlineRequests,clearOfflineStorage];
offlineRequests={};
clearOfflineStorage[]:=(offlineRequests={};)
ClearAll[request];
request[method_String,url_String,params_:Association[],headers_:Association[],storeOffline_:False]:=Module[{req,res},req=HTTPRequest[url,Association["Method"->method,"Headers"->headers,"Query"->If[method==="GET",params,None],"Body"->If[method=!="GET"&&params=!=Association[],ExportString[params,"JSON"],None]]];res=URLRead[req];If[!Between[{200,299}][res["StatusCode"]],If[storeOffline,AppendTo[offlineRequests,req]];Return[$Failed];];res];
ClearAll[validateStatusCodes,validateContentType];
validateStatusCodes[resp_HTTPResponse,codes:{_Integer..}]:=Module[{},If[MemberQ[codes,resp["StatusCode"]],resp,Message[validateStatusCodes::bad,resp["StatusCode"],codes];$Failed]];
validateStatusCodes::bad="Status code `1` is not in the allowed list `2`.";
validateContentType[resp_HTTPResponse,types:{_String..}]:=Module[{hdrRules,ct},hdrRules=AssociationThread[ToLowerCase/@resp["Headers"][[All,1]],resp["Headers"][[All,2]]];ct=Lookup[hdrRules,"content-type",""];If[Or@@(StringContainsQ[ct,#1]&)/@types,resp,Message[validateContentType::bad,ct,types];$Failed]];
validateContentType::bad="Content-Type `1` did not match any of `2`.";
ClearAll[toJSON,toString];
toJSON[resp_HTTPResponse]:=ImportString[resp["Body"],"JSON"];
toString[resp_HTTPResponse,encoding_String:"UTF8"]:=FromCharacterCode[Normal[resp["Body"]],encoding];
resp=request["GET","https://jsonplaceholder.typicode.com/users",Association[],Association["Accept"->"application/json"],False];
resp=validateStatusCodes[resp,{200}];
resp=validateContentType[resp,{"application/json"}];
users=toJSON[resp];
Dataset[users]
cityCounts=Counts[Lookup[users,{"address","city"}]];
BarChart[Values[cityCounts],ChartLabels->Keys[cityCounts],PlotLabel->"Number of Users per City",LabelingFunction->Above,ImageSize->300]


ClearAll["Global`*"]
projectToPlane[{px_,py_,pz_}]:=Module[{n={1,1,1},d},d=(n . {px,py,pz}-1)/Norm[n]^2;{px,py,pz}-d n];
projectToSphere[{px_,py_,pz_}]:=Module[{r=Sqrt[px^2+py^2+pz^2]},If[r<=2,{px,py,pz},(2 {px,py,pz})/r]];
projectToHalfspace[{px_,py_,pz_}]:=If[pz<=1,{px,py,pz},{px,py,1}];
projectOrder[{f_,g_,h_}][pt_List]:=h[g[f[pt]]];
projectPSH=projectOrder[{projectToPlane,projectToSphere,projectToHalfspace}];
projectSHP=projectOrder[{projectToSphere,projectToHalfspace,projectToPlane}];
projectHPS=projectOrder[{projectToHalfspace,projectToPlane,projectToSphere}];
makeSafe[f_][pt_List]:=Module[{res=f[pt]},If[VectorQ[res,NumericQ],res,{Missing[],Missing[],Missing[]}]];
ProjectPSH=makeSafe[projectPSH];
ProjectSHP=makeSafe[projectSHP];
ProjectHPS=makeSafe[projectHPS];
pt0={2.5,0.5,-0.2};
resPSH=ProjectPSH[pt0];
resSHP=ProjectSHP[pt0];
resHPS=ProjectHPS[pt0];
regionPlot=RegionPlot3D[x+y+z<=1&&x^2+y^2+z^2<=4&&z<=1,{x,-2,2},{y,-2,2},{z,-2,2},PlotStyle->{Opacity[0.25],Orange},Mesh->None,BoxRatios->{1,1,1},PlotPoints->50,AxesLabel->{"x","y","z"},ImageSize->500];
plotOverlay[{orig_,proj_}]:=Show[regionPlot,Graphics3D[{If[VectorQ[orig,NumericQ],{Red,Sphere[orig,0.2]},{}],If[VectorQ[proj,NumericQ],{Blue,Sphere[proj,0.2],Black,Tube[{orig,proj},0.03]},{}]}],ViewPoint->{2,-2,2},ImageSize->500];
GraphicsRow[{Labeled[plotOverlay[{pt0,resPSH}],"Plane\[RightArrow]Sphere\[RightArrow]Halfspace",Top],Labeled[plotOverlay[{pt0,resSHP}],"Sphere\[RightArrow]Halfspace\[RightArrow]Plane",Top],Labeled[plotOverlay[{pt0,resHPS}],"Halfspace\[RightArrow]Plane\[RightArrow]Sphere",Top]},Spacings->Scaled[0.15],ImageSize->1600]


ClearAll["Global`*"];
CreateCell[id_]:=Association["ID"->id,"Available"->{}];
numberOfCells=4;
cellIDs=Table["Cell-"<>ToString[i],{i,numberOfCells}];
cellStates=AssociationThread[cellIDs,CreateCell/@cellIDs];
latticeEdges=UndirectedEdge@@@Partition[Append[cellIDs,First[cellIDs]],2,1];
baseGraph=Graph[cellIDs,latticeEdges];
stepSimulation[]:=Module[{prodEvents,consEvents,cell,tgt,tokenID},prodEvents=Select[{"A","B"},RandomReal[]<0.3&];Do[tokenID=CreateUUID[];tgt=First[MinimalBy[cellIDs,Length[cellStates[#1,"Available"]]&]];cellStates[tgt,"Available"]=Append[cellStates[tgt,"Available"],tokenID];,{producer,prodEvents}];consEvents=Select[{"X","Y"},RandomReal[]<0.4&];Do[cell=SelectFirst[cellIDs,Length[cellStates[#1,"Available"]]>0&];If[cell=!=Missing["NotFound"],tokenID=First[cellStates[cell,"Available"]];cellStates[cell,"Available"]=Rest[cellStates[cell,"Available"]];If[RandomReal[]<0.2,cellStates[cell,"Available"]=Append[cellStates[cell,"Available"],tokenID];];];,{consumer,consEvents}];];
DynamicModule[{running=False,task,speed=1},Column[{Row[{Button[Dynamic[If[running,"\[FilledRectangle] Pause","\[FilledRightTriangle]\:fe0e Start"]],If[!running,task=RunScheduledTask[stepSimulation[],1/speed];running=True,RemoveScheduledTask[task];running=False]],Spacer[20],"Speed (steps/sec): ",Slider[Dynamic[speed,(speed=#1;If[running,RemoveScheduledTask[task];task=RunScheduledTask[stepSimulation[],1/speed];])&],{0.1,5,0.1},Appearance->"Labeled"]}],Dynamic[Module[{availCounts},availCounts=(Length[cellStates[#1,"Available"]]&)/@cellIDs;Graph[baseGraph,VertexSize->(Scaled[0.2+0.8 Min[#1/10,1]]&)/@availCounts,VertexStyle->(ColorData["Rainbow"][Clip[#1/10,{0,1}]]&)/@availCounts,VertexLabels->Placed[AssociationThread[cellIDs,MapThread[Framed[#1<>": "<>ToString[#2],Background->White]&,{cellIDs,availCounts}]],Center],GraphLayout->"CircularEmbedding",ImageSize->500,PlotLabel->Style["D\[AE]d\[AE]lus Fabric \[LongDash] "<>DateString["TimeString"],14,Bold]]],UpdateInterval->1/10]}]]


Module[{shared,semaphore,raceVals,atomicVals,mutexVals,handshakeEvents,reqList,resList,serverResList,racePlot,atomicPlot,mutexPlot,handshakePlot,reqPlot,resPlot,serverPlot,labelStyle,plotLabelStyle},labelStyle=Directive[FontFamily->"Helvetica",FontSize->14];plotLabelStyle=Directive[FontFamily->"Helvetica",FontSize->16,Bold];shared=1;raceVals={shared=10;shared,shared};Print["RaceCondition Output:"];Print["  Writer: shared = 10"];Print["  Reader: read shared = "<>ToString[shared]];racePlot=ListLinePlot[raceVals,Joined->True,PlotMarkers->{"\[FilledCircle]",12},PlotStyle->Thick,Frame->True,FrameLabel->{Style["Step",labelStyle],Style["Shared Value",labelStyle]},PlotLabel->Style["RaceCondition Shared Value",plotLabelStyle],GridLines->Automatic,LabelStyle->labelStyle,ImageSize->400];shared=1;atomicVals={shared=10;shared,shared};Print["\nAtomicSync Output:"];Print["  Writer: shared = 10"];Print["  Reader: read shared = "<>ToString[shared]];atomicPlot=ListLinePlot[atomicVals,Joined->True,PlotMarkers->{"\[EmptyCircle]",12},PlotStyle->{Dashed,Thick},Frame->True,FrameLabel->{Style["Step",labelStyle],Style["Shared Value",labelStyle]},PlotLabel->Style["AtomicSync Shared Value",plotLabelStyle],GridLines->Automatic,LabelStyle->labelStyle,ImageSize->400];shared=1;semaphore=1;P[]:=semaphore--;V[]:=semaphore++;mutexVals={};P[];AppendTo[mutexVals,shared=10];V[];P[];AppendTo[mutexVals,shared];V[];Print["\nWithMutex Output:"];Print["  Writer: shared = 10"];Print["  Reader: read shared = "<>ToString[Last[mutexVals]]];mutexPlot=ListLinePlot[mutexVals,Joined->True,PlotMarkers->{"\[FilledSquare]",12},PlotStyle->{DotDashed,Thick},Frame->True,FrameLabel->{Style["Step",labelStyle],Style["Shared Value",labelStyle]},PlotLabel->Style["WithMutex Shared Value",plotLabelStyle],GridLines->Automatic,LabelStyle->labelStyle,ImageSize->400];handshakeEvents={"SYN","SYN_ACK","ACK","DATA","FIN"};Print["\nHandshake Sequence:"];Print/@{"  Client: sent SYN","  Server: sent SYN_ACK","  Client: sent ACK","  Server: sent DATA","  Client: received data","  Client: sent FIN"};handshakePlot=ListPlot[Transpose[{Range[Length[handshakeEvents]],ConstantArray[1,Length[handshakeEvents]]}],PlotMarkers->{"\[FilledCircle]",14},PlotStyle->Thick,Frame->True,FrameTicks->{Table[{i,handshakeEvents[[i]]},{i,Length[handshakeEvents]}],None},FrameLabel->{Style["Handshake Step",labelStyle],None},PlotLabel->Style["Handshake Sequence",plotLabelStyle],GridLines->None,LabelStyle->labelStyle,ImageSize->400];reqList=Table[RandomInteger[{1,5}],{5}];resList=Table[RandomInteger[{1,5}],{5}];serverResList=Table[RandomInteger[{1,5}],{5}];Print["\nClient/Server Simulation:"];Print["  Client REQ values: "<>ToString[reqList]];Print["  Client RES values: "<>ToString[resList]];Print["  Server RES values: "<>ToString[serverResList]];reqPlot=ListLinePlot[reqList,Joined->True,PlotMarkers->{"\[FilledUpTriangle]",12},PlotStyle->Thick,Frame->True,FrameLabel->{Style["Request #",labelStyle],Style["REQ Value",labelStyle]},PlotLabel->Style["Client REQ Values",plotLabelStyle],GridLines->Automatic,LabelStyle->labelStyle,ImageSize->400];resPlot=ListLinePlot[resList,Joined->True,PlotMarkers->{"\[FilledDownTriangle]",12},PlotStyle->Thick,Frame->True,FrameLabel->{Style["Request #",labelStyle],Style["RES Value",labelStyle]},PlotLabel->Style["Client RES Values",plotLabelStyle],GridLines->Automatic,LabelStyle->labelStyle,ImageSize->400];serverPlot=ListLinePlot[serverResList,Joined->True,PlotMarkers->{"\[FilledDiamond]",12},PlotStyle->Thick,Frame->True,FrameLabel->{Style["Response #",labelStyle],Style["RES Value",labelStyle]},PlotLabel->Style["Server RES Values",plotLabelStyle],GridLines->Automatic,LabelStyle->labelStyle,ImageSize->400];Print["\nStyled Visualizations:"];Column[{racePlot,atomicPlot,mutexPlot,handshakePlot,reqPlot,resPlot,serverPlot},Spacings->2]]


ClearAll[gatherSeries,simPlot,setPlot,toolTipData];
generateDemoData[]:=Module[{t},t=Range[0,1,0.01];{t,Sin[2 \[Pi] t]+1,Cos[2 \[Pi] t]+1}];
gatherSeries[]:=Module[{time,kin,pot,data},data=generateDemoData[];{time,kin,pot}=data;{time,kin,pot}];
simPlot[]:=Module[{time,kin,pot,plt},{time,kin,pot}=gatherSeries[];plt=ListLinePlot[{Transpose[{time,kin}],Transpose[{time,pot}]},Joined->True,PlotMarkers->Automatic,PlotLegends->{"Local Kinetic","Local Potential"},PlotLabel->"Membrane Energies (Demo)",AxesLabel->{"Time","Energy"},ImageSize->Large];Print[plt];];
setPlot[n_Integer]:=Module[{demos,time,kinList,potList,kinSeries,potSeries,allSeries},demos=Table[generateDemoData[],{n}];time=demos[[1,1]];kinList=demos[[All,2]];potList=demos[[All,3]];kinSeries=Table[Transpose[{time,kinList[[i]]}],{i,n}];potSeries=Table[Transpose[{time,potList[[i]]}],{i,n}];allSeries=Join[kinSeries,potSeries];ListLinePlot[allSeries,Joined->True,PlotLegends->Join[Table["Run "<>ToString[i]<>" (Kinetic)",{i,n}],Table["Run "<>ToString[i]<>" (Potential)",{i,n}]],PlotLabel->"Bulk Membrane Energies (Demo)",AxesLabel->{"Time","Energy"},ImageSize->Large]];
simPlot[];
setPlot[3];


ClearAll["Global`*"];
myStyle[s_,size_:16]:=Style[s,FontFamily->"Times",FontSize->size];
gatherSeries[dir_String:"outfiles",setFlag_:"n"]:=Module[{oldDir=Directory[],area,volume,energyParts},area={{0,1},{1,1.05},{2,1.10}};volume={{0,1},{1,1.02},{2,1.04}};energyParts={{0,0},{1,0.5},{2,1.0}};If[setFlag==="y",ClearAll[setArea,setVolume,setEnergyParts];setArea={area};setVolume={volume};setEnergyParts={energyParts};];SetDirectory[oldDir];{area,volume,energyParts}];
simPlot[dir_String:"outfiles"]:=Module[{area,volume,energyParts,ar,vr,er,plots},{area,volume,energyParts}=gatherSeries[dir];ar={{0,Max[area[[All,1]]]},{0,1.10 Max[area[[All,2]]]}};vr={{0,Max[volume[[All,1]]]},{0,1.10 Max[volume[[All,2]]]}};er={{0,Max[energyParts[[All,1]]]},{0,1.10 Max[energyParts[[All,2]]]}};plots={ListLinePlot[area,Joined->True,PlotRange->ar,PlotLabel->myStyle["Membrane Area"],AxesLabel->{"Step","Area"}],ListLinePlot[volume,Joined->True,PlotRange->vr,PlotLabel->myStyle["Membrane Volume"],AxesLabel->{"Step","Volume"}],ListLinePlot[energyParts,Joined->True,PlotRange->er,PlotLabel->myStyle["Energy (parts)"],AxesLabel->{"Step","Energy"}]};GraphicsRow[plots,ImageSize->Large]];
loadMesh[id_Integer]:=Module[{verts,faces},verts={{0,0,0},{1,0,0},{0,1,0},{0,0,1}};faces={{1,2,3},{1,2,4},{1,3,4},{2,3,4}};{verts,faces}];
staticSim[meshID_Integer:1]:=Module[{verts,faces,region},{verts,faces}=loadMesh[meshID];region=MeshRegion[verts,Triangle/@faces];RepairMesh[region,PlotTheme->"SmoothShading",Boxed->False,Axes->None,ImageSize->400]];
simPlot["outfiles"]


ClearAll[staticSim];
staticSim[coords_List,faceVerts_List,opts___]:=Module[{meshRegion},meshRegion=MeshRegion[coords,Triangle/@faceVerts];Show[meshRegion,opts]];
sphereG3D=Graphics3D[Sphere[{0,0,0},1],SphericalPlotPoints->40];
sphereMR=DiscretizeGraphics[sphereG3D];
coords3D=MeshCoordinates[sphereMR];
faceCells=MeshCells[sphereMR,2];
faces3D=faceCells[[All,1]];
staticSim[coords3D,faces3D,Axes->True,Lighting->"Neutral",PlotTheme->"Detailed",ImageSize->400]


ClearAll["Global`*"];
myStyle[x_,size_:18]:=Style[x,FontFamily->"Times",FontSize->size];
gatherSeries[data_,opts___]:=Module[{area,volume,temp,energy,energyParts},{area,volume,temp,energy,energyParts}=Lookup[data,{"area","volume","temp","energy","energyParts"}];Association["area"->area,"volume"->volume,"temp"->temp,"energy"->energy,"energyParts"->energyParts]];
simPlot[series_Association]:=Module[{tvals,comps,energy,temp,area,volume,partNames,partPlot,grid},tvals=series["energyParts"][[All,1]];comps=Transpose[series["energyParts"][[All,2]]];energy=series["energy"];temp=series["temp"];area=series["area"];volume=series["volume"];partNames=Table["Part "<>ToString[i],{i,Length[comps]}];partPlot=ListLinePlot[Table[Transpose[{tvals,comps[[i]]}],{i,Length[comps]}],PlotTheme->"Detailed",PlotStyle->Thick,Frame->True,FrameLabel->{myStyle["Time"],myStyle["Energy Parts"]},PlotLegends->Placed[partNames,Right],ImageSize->Medium];grid=GraphicsGrid[{{partPlot,ListLinePlot[energy,PlotTheme->"Detailed",PlotStyle->Thick,Frame->True,FrameLabel->{myStyle["Time"],myStyle["Global Energy"]},ImageSize->Medium]},{ListLinePlot[temp,PlotTheme->"Detailed",PlotStyle->Thick,Frame->True,FrameLabel->{myStyle["Time"],myStyle["Temperature"]},ImageSize->Medium],ListLinePlot[area,PlotTheme->"Detailed",PlotStyle->Thick,Frame->True,FrameLabel->{myStyle["Time"],myStyle["Area"]},ImageSize->Medium]},{ListLinePlot[volume,PlotTheme->"Detailed",PlotStyle->Thick,Frame->True,FrameLabel->{myStyle["Time"],myStyle["Volume"]},ImageSize->Medium],Spacer[0]}},Spacings->{2,2},Alignment->Center,ImageSize->Full];grid];
setPlot[listOfSeries_List]:=ListLinePlot[Lookup[listOfSeries,"temp"],PlotTheme->"Detailed",PlotStyle->Thick,Frame->True,FrameLabel->{myStyle["Step"],myStyle["Temperature"]},PlotLegends->Placed[("Expressions"&)/@Range[Length[listOfSeries]],Above],ImageSize->Full];
bjerrumL=0.714;
s[e_]:=If[e==0,2,1+((1-e^2) ArcTanh[e])/e];
sphereArea[R0_]:=4 \[Pi] R0^2;
shapeArea[\[Lambda]_,R0_:10]:=Which[\[Lambda]<=1,oblateArea[Sqrt[1-\[Lambda]^2],R0],\[Lambda]>1,prolateArea[Sqrt[\[Lambda]^2-1]/\[Lambda],R0]];
oblateArea[e_,a_]:=If[e==0,4 \[Pi] a^2,2 \[Pi] a^2 s[e]];
prolateArea[e_,c_]:=If[e==0,4 \[Pi] c^2,2 \[Pi] c^2 Sqrt[1-e^2] (Sqrt[1-e^2]+ArcSin[e]/e)];
gcLengthSphere[Q_,R0_]:=1/((2 \[Pi] bjerrumL Q)/sphereArea[R0]);
ManningRSphere[Q_,R0_]:=R0/gcLengthSphere[Q,R0];
script[netSteps_:1000,dumpInt_:1000000,thermoInt_:10000,timeStep_:2.5/10^4]:=Module[{myT,myD,lines},myT=ToString[FortranForm[N[timeStep]],InputForm];myD=ToString[FortranForm[Round[dumpInt]],InputForm];lines={"# 3D simulation of ion condensation on nanomembrane","units lj","boundary p p p","atom_style hybrid charge sphere","timestep "<>myT,"dump pos all custom "<>myD<>" dump.melt id type x y z q c_atomPot c_atomKin","thermo "<>ToString[Round[thermoInt]],"run "<>ToString[Round[netSteps]]};StringRiffle[lines,"\n"]];
generateCounterions[coords_List,charges_List,\[Sigma]1_,\[Sigma]2_,boxL_]:=Module[{micro1={},micro2={},pos},While[Length[micro1]<Round[Total[charges]],pos=RandomReal[{-(boxL/2),boxL/2},3];AppendTo[micro1,pos];];{micro1,micro2}];
staticSim[coords_List,faceVerts_List,opts___]:=Module[{meshRegion},meshRegion=MeshRegion[coords,Triangle/@faceVerts];Show[meshRegion,opts]];
dummy=Association["area"->Table[{t,Sin[t]},{t,0,10,0.1}],"volume"->Table[{t,Cos[t]},{t,0,10,0.1}],"temp"->Table[{t,300+5 Sin[t]},{t,0,10,0.1}],"energy"->Table[{t,t^2},{t,0,10,0.1}],"energyParts"->Table[{t,{Sin[t],Cos[t],Tan[t]}},{t,0,10,0.1}]];
data=gatherSeries[dummy];
simPlot[data]


getCurrentPrice[ticker_String]:=FinancialData[ticker];
aaplLastPrice=getCurrentPrice["AAPL"];
Print["Current Apple Inc. (AAPL) Price: ",aaplLastPrice];
getHistory[ticker_String,start_,end_]:=FinancialData[ticker,{start,end}];
ibmHistory=getHistory["IBM",{2024,1,1},{2024,6,30}];
DateListPlot[ibmHistory,PlotLabel->"IBM Price (2024)",AspectRatio->1/3]
getDetailedHistory[ticker_String,property_String,start_,end_]:=FinancialData[ticker,property,{start,end}];
spxVolume=getDetailedHistory["^SPX","Volume","2025-06-01","2025-06-30"];
DateListPlot[spxVolume,PlotLabel->"S&P 500 Volume (June 2025)",Joined->False,Filling->Axis]
googPrice=getCurrentPrice["GOOG"];
Print["Current Alphabet Inc. (GOOG) Price: ",googPrice];
msftHistory=getHistory["MSFT","2020-01-01",Today];
DateListPlot[msftHistory["Path"],PlotTheme->"Web",PlotLabel->"MSFT Closing Price Since 2020",ImageSize->Large]


ClearAll[eventLog,protocolThroughput,throughputTimeline,latencyRecords,uniqueIPs,uniqueMACs,protocolConnections,totalPacketCount,logFile,styleHeading,currentTimestamp,displayPacketDetails,saveToLog,recordPacketInfo,handlePacketData,computeThroughput,computeLatency,showStatistics,generateDashboard,iface,proc];
eventLog=Association[];
protocolThroughput=Association[];
throughputTimeline=Association[];
latencyRecords=Association["TCP"->{},"UDP"->{},"IP"->{}];
uniqueIPs={};
uniqueMACs={};
protocolConnections=Association[];
totalPacketCount=0;
logFile="network_events.log";
SetOptions[EvaluationNotebook[],DefaultFont->"Helvetica",DefaultFontSize->14,CellMargins->25,Background->RGBColor[0.98,0.98,0.98]];
styleHeading[text_]:=Style[text,18,Bold,FontFamily->"Arial",FontColor->RGBColor[0.1,0.2,0.5]];
currentTimestamp[]:=AbsoluteTime[];
displayPacketDetails[protocol_,src_,dest_,size_]:=Print[Style["Packet: ",Italic,FontSize->12],Row[{Style[protocol,Bold,FontColor->RGBColor[0.5,0,0.7]],": ",src," \[RightArrow] ",dest,", ",size," bytes"}]];
saveToLog[protocol_,src_,dest_,size_,timestamp_]:=Module[{entry},entry=DateString[timestamp,{"Year","-","Month","-","Day"," ","Hour",":","Minute",":","Second"}]<>" | "<>protocol<>" | Src: "<>src<>", Dst: "<>dest<>", Size: "<>ToString[size]<>" bytes\n";entry>>>logFile;displayPacketDetails[protocol,src,dest,size];];
recordPacketInfo[protocol_,src_,dest_,size_,timestamp_]:=(totalPacketCount++;protocolThroughput[protocol]=Lookup[protocolThroughput,protocol,0]+size;eventLog[protocol]=Append[Lookup[eventLog,protocol,{}],size];protocolConnections[protocol]=Lookup[protocolConnections,protocol,0]+1;If[protocol==="Ethernet",uniqueMACs=uniqueMACs\[Union]{src,dest},uniqueIPs=uniqueIPs\[Union]{src,dest}];If[MemberQ[{"TCP","UDP","IP"},protocol],latencyRecords[protocol]=Append[latencyRecords[protocol],timestamp]];);
handlePacketData[protocol_,src_,dest_,size_]:=Module[{ts},ts=currentTimestamp[];saveToLog[protocol,src,dest,size,ts];recordPacketInfo[protocol,src,dest,size,ts];];
computeThroughput[interval_:10]:=Module[{bps},Print[styleHeading["--- Throughput (bps) ---"]];If[interval<=0,Return[]];KeyValueMap[(If[Lookup[protocolThroughput,#1,0]>0,bps=(#2 8)/interval;throughputTimeline[#1]=Append[Lookup[throughputTimeline,#1,{}],bps];Print[#1<>": ",NumberForm[bps,{7,0}]," bps"];];protocolThroughput[#1]=0;)&,protocolThroughput];Print[StringRepeat["-",25]];];
computeLatency[]:=Module[{avg=Association[],diffs},Print[styleHeading["--- Latency (ms) ---"]];Do[If[Length[latencyRecords[prot]]>1,diffs=Differences[latencyRecords[prot]] 1000;avg[prot]=Mean[diffs],avg[prot]=0];Print["Avg ",prot,": ",NumberForm[avg[prot],{6,2}]," ms"];,{prot,{"TCP","UDP","IP"}}];avg];
showStatistics[]:=Module[{},Print[styleHeading["--- Network Monitoring Summary ---"]];KeyValueMap[(Print[#1<>": ",Length[#2]," pkts; Avg Size: ",If[Length[#2]>0,NumberForm[Mean[#2],{6,2}],0]," bytes"];)&,eventLog];Print["Unique IPs: ",Length[uniqueIPs],", Unique MACs: ",Length[uniqueMACs]];Print["Total Packets: ",totalPacketCount];Print[StringRepeat["-",35]];];
generateDashboard[]:=Module[{tpPlot,latHist,barStats,pieProtocol,tcpLat,udpLat,ipLat,counts},tpPlot=If[Length[Values[throughputTimeline]]>=2,ListLinePlot[Values[throughputTimeline],PlotTheme->"Business",PlotLegends->Placed[Keys[throughputTimeline],Above],AxesLabel->{"Interval","bps"},PlotLabel->Style["Throughput Over Time",16,Bold],ImageSize->300],Graphics[Text["No throughput data"],ImageSize->300]];tcpLat=Differences[latencyRecords["TCP"]] 1000;udpLat=Differences[latencyRecords["UDP"]] 1000;ipLat=Differences[latencyRecords["IP"]] 1000;latHist=If[Length[tcpLat]+Length[udpLat]+Length[ipLat]>0,Histogram[{tcpLat,udpLat,ipLat},15,ChartLegends->{"TCP","UDP","IP"},PlotTheme->"Business",AxesLabel->{"Latency (ms)","Frequency"},PlotLabel->Style["Latency Distribution",16,Bold],ImageSize->300],Graphics[Text["No latency data"],ImageSize->300]];counts=Join[Values[protocolConnections],{Length[uniqueIPs],Length[uniqueMACs]}];barStats=BarChart[counts,ChartLabels->Placed[Join[Keys[protocolConnections],{"IPs","MACs"}],Below],PlotTheme->"Business",AxesLabel->{"Category","Count"},PlotLabel->Style["Protocol & Address Stats",16,Bold],LabelingFunction->Above,ImageSize->300];pieProtocol=If[Total[Values[protocolConnections]]>0,PieChart[Values[protocolConnections],ChartLabels->Placed[Keys[protocolConnections],"RadialCallout"],PlotTheme->"Business",PlotLabel->Style["Protocol Usage Breakdown",16,Bold],ImageSize->300],Graphics[Text["No protocol data"],ImageSize->300]];Framed[Grid[{{Style["Network Monitoring Dashboard",20,Bold]},{tpPlot,latHist},{barStats,pieProtocol}},Spacings->{3,3}],Background->White,FrameStyle->Directive[GrayLevel[0.7],Thickness[0.005]],RoundingRadius->8,ImageSize->650]];
iface="en0";
proc=StartProcess[{"tcpdump","-l","-n","-q","-i",iface}];
Print[styleHeading["Capturing on "<>iface<>" \[Ellipsis] (Shift+Enter to stop)"]];
While[True,line=ReadLine[proc];If[line===EndOfFile,Break[]];tcpMatch=StringCases[line,RegularExpression["IP\\s+([^\\.]+)\\.(\\d+)\\s*>\\s*([^\\.]+)\\.(\\d+):.*length\\s*(\\d+)"]:>{"Src"->"$1:$2","Dst"->"$3:$4","Len"->"$5"}];If[tcpMatch=!={},p=First[tcpMatch];handlePacketData["TCP",p["Src"],p["Dst"],ToExpression[p["Len"]]];Continue[];];udpMatch=StringCases[line,RegularExpression["UDP\\s+([^\\.]+)\\.(\\d+)\\s*>\\s*([^\\.]+)\\.(\\d+):.*length\\s*(\\d+)"]:>{"Src"->"$1:$2","Dst"->"$3:$4","Len"->"$5"}];If[udpMatch=!={},p=First[udpMatch];handlePacketData["UDP",p["Src"],p["Dst"],ToExpression[p["Len"]]];Continue[];];ipMatch=StringCases[line,RegularExpression["IP\\s+(\\S+)\\s*>\\s*(\\S+):.*length\\s*(\\d+)"]:>{"Src"->"$1","Dst"->"$2","Len"->"$3"}];If[ipMatch=!={},p=First[ipMatch];handlePacketData["IP",p["Src"],p["Dst"],ToExpression[p["Len"]]];Continue[];];ethMatch=StringCases[line,RegularExpression["length\\s*(\\d+)"]:>{"Len"->"$1"}];If[ethMatch=!={},handlePacketData["Ethernet","<eth>","<eth>",ToExpression[First[ethMatch]["Len"]]];];];
computeThroughput[10];
computeLatency[];
showStatistics[];
If[totalPacketCount==0,Do[With[{t=AbsoluteTime[]+i 5,pr=RandomChoice[{"TCP","UDP","IP","Ethernet"}],sz=RandomInteger[{64,1500}],src="10.0.0."<>ToString[RandomInteger[{1,254}]]<>":80",dst="10.0.0."<>ToString[RandomInteger[{1,254}]]<>":443"},recordPacketInfo[pr,src,dst,sz,t]],{i,1,50}];computeThroughput[5];];
dashboard=generateDashboard[];
KillProcess[proc];
dashboard


ClearAll[cons,cdrAndFree];
cons[element_,l_List]:=Prepend[l,element];
cdrAndFree[l_List]:=Rest[l];
ClearAll[queueCreate,queueEmpty,queueEnq,queueDeq];
queueCreate[]:={};
queueEmpty[q_List]:=q==={};
queueEnq[q_List,elem_]:=Append[q,elem];
queueDeq[q_List]:={First[q],Rest[q]};
ClearAll[Packet];
Packet[id_Integer,type_String]:=Association["id"->id,"type"->type];
ClearAll[processPacket];
processPacket[pkt_]:=Module[{id=pkt["id"],t=pkt["type"],msg},msg=Switch[t,"ARP","\:21bb ARP request \[RightArrow] ARP reply","ICMP","\:27f3 ICMP echo \[RightArrow] ICMP reply","DATA","\[RightArrow] DATA packet forwarded",_,"\[CenterEllipsis] Unknown packet"];Association["PacketID"->id,"Type"->t,"Result"->msg]];
ClearAll[generateDemoPackets];
generateDemoPackets[n_Integer]:=Module[{types={"ARP","ICMP","DATA"}},Table[Packet[i,RandomChoice[types]],{i,1,n}]];
ClearAll[runSimulation];
runSimulation[packets_List]:=processPacket/@packets;
ClearAll[simulateAndVisualize,createTextBarChart];
createTextBarChart[counts_Association]:=Module[{maxLabelLength,paddedLabels,bars},maxLabelLength=Max[(StringLength[#1]&)/@Keys[counts]];paddedLabels=(StringPadRight[#1,maxLabelLength]&)/@Keys[counts];bars=(StringJoin[Table["\[FilledSquare]",{#1}]]&)/@Values[counts];TableForm[Transpose[{paddedLabels,bars}]]];
simulateAndVisualize[n_Integer]:=Module[{packets,results,counts},packets=generateDemoPackets[n];results=runSimulation[packets];counts=Counts[results[[All,"Result"]]];Print[Style["Simulation Results: Conventional Router",Bold]];Print[TableForm[Values[results],TableHeadings->{None,Keys[First[results]]}]];Print["\n",Style["Result Distribution",Bold]];Print[createTextBarChart[counts]];];
simulateAndVisualize[15]


Quiet[Remove["CQLClient`CQLConnect"],{Remove::rmnsm}];
Quiet[Remove["Global`CQLConnect"],{Remove::rmnsm}];
BeginPackage["NodeCQL`"];
Quiet[Unprotect[CQLConnect]];
ClearAll[CQLConnect];
CQLConnect::usage="CQLConnect[host, port, keyspace] opens a Cassandra CQL connection.";
HexDec::usage="HexDec[str] converts a hexadecimal string or buffer to its decimal representation (as string).";
Begin["`Private`"];
CQLConnect[host_String,port_Integer,keyspace_:None]:=Module[{conn},conn=Association["Host"->host,"Port"->port,"Keyspace"->keyspace,"Socket"->None,"Ready"->False,"Callbacks"->Association[]];conn=OpenConnection[conn];conn];
OpenConnection[conn_Association]:=Module[{sock="<socket>"},conn["Socket"]=sock;conn["Ready"]=True;conn];
CloseConnection[conn_Association]:=conn;
Quiet[Unprotect[HexDec]];
ClearAll[HexDec];
HexDec[str_]:=Module[{s=ToString[str],ret="",r,x},If[StringMatchQ[s,"0"~~Repeated["0",{1,\[Infinity]}]],Return["0"]];While[s=!="0",r=0;x="";Do[r=16 r+FromDigits[StringTake[s,{i}],16];With[{diff=Quotient[r,10]},x=x<>IntegerString[diff,16];r-=diff 10;],{i,StringLength[s]}];s=StringTrim[x,"0"~~Repeated["0",{1,\[Infinity]}]];ret=ToString[r]<>ret;];ret];
End[];
EndPackage[];
inputConn=CQLConnect["127.0.0.1",9042];
Print["Connection Ready: ",inputConn["Ready"]];
networkDiagram=Graphics[{Blue,Disk[{0,0},0.3],Red,Disk[{1,0},0.2],Green,Disk[{0.5,0.8},0.25],Black,Thick,Line[{{0,0},{1,0},{0.5,0.8},{0,0}}],Text["Host",{0,-0.4}],Text["Proxy",{1,-0.4}],Text["Keyspace",{0.5,1.1}]},ImageSize->300];
networkDiagram
hexValue="1A3F";
decValue=HexDec[hexValue]


hexExample=FromDigits["1A2B",16]
hexVals=Table[{n,FromDigits[IntegerString[n,16],16]},{n,0,15}];
hexPlot=ListPlot[hexVals,PlotMarkers->Automatic,PlotLabel->"n vs. FromDigits[HexString]: 0\[Dash]15",AxesLabel->{"n","DecimalValue"},ImageSize->Medium]
hexPlot


causes={{2,"illegal_instruction"},{3,"breakpoint"}};
csrs={{0,"ustatus"},{305,"mstatus"}};
csrs32={{0,"cycle"},{1,"time"}};
argLut=Association["rd"->{11,7},"rs1"->{19,15},"rs2"->{24,20}];
rangeMask[begin_,end_]:=(2^(end-begin+1)-1) 2^begin;
instrDict=Association["add"->Association["encoding"->StringJoin[Table["-",{32}]],"match"->"0x00000033","mask"->"0xffffffff","extension"->{"rv32i"}],"sub"->Association["encoding"->StringJoin[Table["-",{32}]],"match"->"0x40000033","mask"->"0xffffffff","extension"->{"rv32i"}]];
printLabel[label_,expr_]:=(Print[Style[label,Bold,14]];Print[expr];);
svOut=Module[{namesStr=""},Do[namesStr=namesStr<>"  localparam [31:0] "<>ToUpperCase[StringReplace[i,"."->"_"]]<>" = 32'b"<>StringReplace[instrDict[i]["encoding"],"-"->"?"]<>";",{i,Keys[instrDict]}];namesStr];
printLabel["-- SVerilog Parameters --",svOut];
rustOut=Module[{s=""},Do[s=s<>"const MATCH_"<>ToUpperCase[StringReplace[i,"."->"_"]]<>": u32 = "<>instrDict[i]["match"]<>";\n";s=s<>"const MASK_"<>ToUpperCase[StringReplace[i,"."->"_"]]<>": u32 = "<>instrDict[i]["mask"]<>";\n";,{i,Keys[instrDict]}];s];
printLabel["-- Rust Constants --",rustOut];
goOut="// Go encoder stub for instructions: "<>StringRiffle[Keys[instrDict],", "];
printLabel["-- Go Stub --",goOut];
cOut=Module[{s=""},Do[s=s<>"#define MATCH_"<>ToUpperCase[StringReplace[i,"."->"_"]]<>" "<>instrDict[i]["match"]<>"\n";,{i,Keys[instrDict]}];s];
printLabel["-- C Header Defines --",cOut];
chiselOut="// Chisel BitPat stubs for: "<>StringRiffle[Keys[instrDict],", "];
printLabel["-- Chisel Stub --",chiselOut];
rangeMasks=Table[{i,j,rangeMask[i,j]},{i,0,4},{j,i,i+2}];
printLabel["-- Sample Range Masks (i..i+2) --",rangeMasks];


timings={{"x^3 Erf[x]^2",0.000016},{"(x^7 - 24 x^4 - 4 x^2 + 8 x - 8)/(x^8 + 6 x^6 + 12 x^4 + 8 x^2)",0.000017},{"(-4 x^2 - 4 x^3 - x^4)/((-1 + x^2)(1 + x + x^2)^2)",0.000009},{"x^3/(1 + x)",0.000003},{"(x^4 - 3 x^2 + 6)/(x^6 - 5 x^4 + 5 x^2 + 4)",0.000006},{"(-1 - E^x + E^x x Log[x])/((1 + E^x)^2 x)",0.000012}};
Dataset[(AssociationThread[{"Expression","Time (s)"},#1]&)/@timings,AppearanceRules->Association["HeaderBackground"->LightGray,"RowAlternation"->{White,LightYellow}]]
Grid[Prepend[timings,{"Expression","Time (s)"}],Frame->All,Background->{None,{LightGray,{White}}},Alignment->{Left,Center},ItemStyle->{FontFamily->"Courier",FontSize->12}]
BarChart[timings[[All,2]],ChartLabels->Placed[(Rotate[#1,45 \[Degree]]&)/@timings[[All,1]],Below],ChartStyle->RGBColor[0.2,0.6,0.8],ImageSize->Large,PlotTheme->"Detailed",AxesLabel->{None,"Time (s)"},PlotLabel->Style["Poor Man\[CloseCurlyQuote]s Integrator: Example Timings",14,Bold],LabelStyle->Directive[FontFamily->"Arial",FontSize->12],GridLines->{None,Automatic},GridLinesStyle->Dashed]


ClearAll[initState,receiverStep,buildFrameBits,buildTestBits,runSimulation,simStates,valueSeq];
initState[]:=Association["value"->0,"desMAC"->0,"srcMAC"->0,"ET"->0,"Payload"->0,"CRC32"->FromDigits["100000100110000010001110110110111",2],"size"->0,"out"->0,"done"->False];
receiverStep[state_,inBit_]:=Module[{value,desMAC,srcMAC,ET,Payload,CRC32,size,out,done,newValue,newDesMAC,newSrcMAC,newET,newPayload,newSize,newOut,newDone},{value,desMAC,srcMAC,ET,Payload,CRC32,size,out,done}=Lookup[state,{"value","desMAC","srcMAC","ET","Payload","CRC32","size","out","done"}];newValue=value;newDesMAC=desMAC;newSrcMAC=srcMAC;newET=ET;newPayload=Payload;newSize=size;newOut=out;newDone=done;If[value==0,newDesMAC=0;newSrcMAC=0;newET=0;newPayload=0;newSize=0;newOut=0;newDone=False;];Which[0<=value<=61,If[inBit===Mod[value+1,2],newValue=value+1,newValue=0],62<=value<=69,If[inBit===BitGet[FromDigits["11010101",2],value-62],newValue=value+1,newValue=0],70<=value<=117,newDesMAC=BitShiftLeft[desMAC,1]+inBit;newValue=value+1,118<=value<=165,newSrcMAC=BitShiftLeft[srcMAC,1]+inBit;newValue=value+1,166<=value<=181,newET=BitShiftLeft[ET,1]+inBit;If[value==181,newET=BitShiftLeft[newET,3]];newValue=value+1,182<=value<=181+ET+32,newPayload=BitShiftLeft[Payload,1]+inBit;If[value==181+ET,newOut=newPayload];If[value==181+ET+32,Module[{temp=newPayload},Do[If[BitGet[temp,k]==1,temp=Fold[BitXor[#1,BitShiftLeft[CRC32,j]]&,temp,Range[0,32]]],{k,ET+31,33,-1}];If[temp==0,newDone=True;newSize=ET/8,newDone=False];];newValue=0,newValue=value+1],True,newValue=value];Association["value"->newValue,"desMAC"->newDesMAC,"srcMAC"->newSrcMAC,"ET"->newET,"Payload"->newPayload,"CRC32"->CRC32,"size"->newSize,"out"->newOut,"done"->newDone]];
buildFrameBits[wrongFcs_:False]:=Module[{bits,fcs},bits={};Do[bits=Join[bits,{1,0}],{31}];bits=Join[bits,ConstantArray[1,2],ConstantArray[0,48],ConstantArray[1,48]];bits=Join[bits,ConstantArray[0,14],ConstantArray[1,2]];bits=Join[bits,Riffle[ConstantArray[{1,0},16],{}]];fcs=Flatten[Table[{0,1},{16}]];If[wrongFcs,fcs=1-fcs];Join[bits,fcs]];
buildTestBits[]:=Module[{f1,f2},f1=buildFrameBits[False];f2=buildFrameBits[True];Join[f1,ConstantArray[0,5],f2]];
runSimulation[]:=Module[{bits,states},bits=buildTestBits[];states=FoldList[receiverStep,initState[],bits];states];
simStates=runSimulation[];
valueSeq=simStates[[All,"value"]][[1;;80]];
TableForm[Transpose[{Range[Length[valueSeq]],buildTestBits[][[1;;80]],valueSeq}],TableHeadings->{None,{"Idx","inBit","value"}}]
Count[simStates,#1["done"]&]


bitsToInt[bits_List]:=FromDigits[bits,2]
crcPoly=FromDigits["100000100110000010001110110110111",2]
crcCheck[bits_List]:=Module[{reg=bitsToInt[bits],n=Length[bits]},Do[If[BitGet[reg,i]==1,reg=BitXor[reg,crcPoly 2^(i-32)]],{i,n-1,32,-1}];reg==0]
parseEthernetFrame[bits_List]:=Module[{rest=bits,preambleLen=56,sfdLen=8,macLen=48,etLen=16,des,src,etBits,etBytes,payloadAndFCS,payload,fcs,valid},rest=Drop[rest,preambleLen];rest=Drop[rest,sfdLen];des=Take[rest,macLen];rest=Drop[rest,macLen];src=Take[rest,macLen];rest=Drop[rest,macLen];etBits=Take[rest,etLen];rest=Drop[rest,etLen];etBytes=bitsToInt[etBits];payloadAndFCS=Take[rest,etBytes 8+32];payload=Take[payloadAndFCS,etBytes 8];fcs=Take[payloadAndFCS,-32];valid=crcCheck[payloadAndFCS];Association["desMAC"->IntegerString[bitsToInt[des],16,12],"srcMAC"->IntegerString[bitsToInt[src],16,12],"lengthBytes"->etBytes,"validCRC"->valid,"segments"->{"Preamble"->preambleLen,"SFD"->sfdLen,"DestMAC"->macLen,"SrcMAC"->macLen,"Length"->etLen,"Payload"->etBytes 8,"FCS"->32},"bits"->bits]]
generateTestVectors[]:=Module[{preamble,sfd,desMACbits,srcMACbits,etBits,payloadBits,validFcs,invalidFcs,tv1,tv2},preamble=Flatten[Table[{1,0},{28}]];sfd={1,1,0,1,0,1,0,1};desMACbits=ConstantArray[1,48];srcMACbits=ConstantArray[0,48];etBits=IntegerDigits[3,2,16];payloadBits=ConstantArray[1,3 8];validFcs=IntegerDigits[Module[{bits=Join[payloadBits,ConstantArray[0,32]]},Module[{reg=bitsToInt[bits],n=Length[bits]},Do[If[BitGet[reg,i]==1,reg=BitXor[reg,crcPoly 2^(i-32)]],{i,n-1,32,-1}];reg]],2,32];invalidFcs=Reverse[validFcs];tv1=Join[preamble,sfd,desMACbits,srcMACbits,etBits,payloadBits,validFcs];tv2=Join[preamble,sfd,desMACbits,srcMACbits,etBits,payloadBits,invalidFcs];{tv1,tv2}]
visualizeFrameLayout[frameBits_List]:=Module[{info=parseEthernetFrame[frameBits],segs,acc=0},segs=info["segments"];Graphics[Flatten[Join[Table[{ColorData["BrightBands"][i],Rectangle[{acc,0},{acc+segs[[i,2]],1}],Text[Style[segs[[i,1]],14,White],{acc+1/2 segs[[i,2]],0.5}]},{i,Length[segs]}],{{Black,Thick,Rectangle[{0,0},{Total[segs[[All,2]]],1}]}}]],Axes->False,ImagePadding->20,PlotRange->{{0,Total[segs[[All,2]]]},{0,1}},AspectRatio->0.2,Background->LightGray]]
plotBitWaveform[frameBits_List]:=ListLinePlot[Transpose[{Range[0,Length[frameBits]-1],frameBits}],InterpolationOrder->0,Filling->Axis,PlotRange->{{0,Length[frameBits]},{-0.2,1.2}},AxesLabel->{"Bit Index","Value"},ImageSize->Large]
{test1,_}=generateTestVectors[];
info1=parseEthernetFrame[test1];
Grid[{{"Parsed Results:"},{"destMAC"->info1["desMAC"],"srcMAC"->info1["srcMAC"],"Length bytes"->info1["lengthBytes"],"CRC OK"->info1["validCRC"]}},Frame->All]
Row[{visualizeFrameLayout[test1],Spacer[20],plotBitWaveform[test1]}]


topology=Association[1->{2,3,5},2->{1,4,6},3->{1,4,7},4->{2,3,5,8},5->{1,4,9},6->{2,7,10},7->{3,6,8},8->{4,7,9,10},9->{5,8,10},10->{6,8,9}];
initNode[id_]:=Association["ID"->id,"RoutingTable"->Association[],"SeenRREQ"->Association[],"MessageQueue"->{}];
nodes=Association[Table[i->initNode[i],{i,Keys[topology]}]];
makeRREQ[src_,dest_,bcastID_,hopCount_]:=Association["Type"->"RREQ","Source"->src,"Dest"->dest,"BcastID"->bcastID,"HopCount"->hopCount,"Originator"->src];
makeRREP[src_,dest_,originator_,hopCount_]:=Association["Type"->"RREP","Source"->src,"Dest"->dest,"Originator"->originator,"HopCount"->hopCount];
broadcast[msg_,i_]:=Scan[Function[j,AppendTo[nodes[j,"MessageQueue"],msg]],topology[i]];
unicast[msg_,i_]:=Module[{entry},entry=Lookup[nodes[i,"RoutingTable"],msg["Dest"],Missing[]];If[MatchQ[entry,{next_,___}],AppendTo[nodes[next,"MessageQueue"],msg]];];
processMessage[i_]:=Module[{node=nodes[i],msg},If[node["MessageQueue"]==={},Return[]];msg=First[node["MessageQueue"]];nodes[i,"MessageQueue"]=Rest[node["MessageQueue"]];Switch[msg["Type"],"RREQ",If[KeyExistsQ[node["SeenRREQ"],msg["BcastID"]],Return[]];AssociateTo[nodes[i,"SeenRREQ"],msg["BcastID"]->True];AssociateTo[nodes[i,"RoutingTable"],msg["Originator"]->{msg["Source"],msg["HopCount"]+1,AbsoluteTime[]}];If[i==msg["Dest"],unicast[makeRREP[i,msg["Originator"],msg["Originator"],0],i],broadcast[Append[msg,"HopCount"->msg["HopCount"]+1],i]],"RREP",AssociateTo[nodes[i,"RoutingTable"],msg["Originator"]->{msg["Source"],msg["HopCount"]+1,AbsoluteTime[]}];If[i=!=msg["Dest"],unicast[Append[msg,"HopCount"->msg["HopCount"]+1],i]]];];
simulateStep[]:=Scan[processMessage,Keys[nodes]];
startDiscovery[src_,dest_,bcastID_]:=Module[{rreq},rreq=makeRREQ[src,dest,bcastID,0];broadcast[rreq,src];];
startDiscovery[1,8,5001];
startDiscovery[4,10,7001];
Do[simulateStep[],{100}];
TableForm[Table[{i,nodes[i,"RoutingTable"]},{i,Keys[nodes]}],TableHeadings->{None,{"Node","RoutingTable"}}]


topology=Association[1->{2,3,5},2->{1,4,6},3->{1,4,7},4->{2,3,5,8},5->{1,4,9},6->{2,7,10},7->{3,6,8},8->{4,7,9,10},9->{5,8,10},10->{6,8,9}];
startDiscovery[1,8,5001];
startDiscovery[4,10,7001];
Do[simulateStep[],{100}];
edges=DeleteDuplicates[Sort/@Flatten[Table[{i,j},{i,Keys[topology]},{j,topology[i]}],1]];
g=Graph[UndirectedEdge@@@edges,VertexLabels->Placed["Name",Center],GraphLayout->"SpringEmbedding",ImagePadding->20,VertexStyle->White,EdgeStyle->LightGray,VertexSize->Medium];
getRoute[src_,dest_]:=Module[{route={src},cur=src},While[cur=!=dest,cur=nodes[cur,"RoutingTable"][dest][[1]];AppendTo[route,cur];];route];
route1=getRoute[1,8];
route2=getRoute[4,10];
hg=HighlightGraph[g,{PathGraph[UndirectedEdge@@@Partition[route1,2,1]],PathGraph[UndirectedEdge@@@Partition[route2,2,1]]},{(EdgeStyle->{UndirectedEdge@@#1->{Thick,Red}}&)/@Partition[route1,2,1],(EdgeStyle->{UndirectedEdge@@#1->{Thick,Blue}}&)/@Partition[route2,2,1]}];
hg


Clear[name2addr];
name2addr[hostname_String]:=Module[{ips},ips=Quiet[Check[DNSLookup[hostname,"A"],{}]];If[Length[ips]>=1,First[ips],Message[name2addr::noip,hostname];$Failed]];
name2addr::noip="Cannot find IP address for `1`.";
Clear[addr2name];
addr2name[ip_String]:=Module[{names},names=Quiet[Check[DNSLookup[ip,"PTR"],{}]];If[Length[names]>=1,First[names],Message[addr2name::noname,ip];$Failed]];
addr2name::noname="No reverse-DNS name for IP `1`.";
Clear[timeServ];
timeServ[port_Integer]:=Module[{sock,pktRes,pkt,from},sock=CreateDatagramSocket[port];Print["Time server listening on UDP port ",port];While[True,pktRes=Quiet[ReadDatagram[sock,All]];If[ListQ[pktRes]&&Length[pktRes]==2,{pkt,from}=pktRes;If[StringQ[pkt],SendDatagram[DateString[Now,{"Year","-","Month","-","Day"," ","Hour",":","Minute",":","Second"}]<>"\n",from];];];];];
Clear[timeCli];
timeCli[host_String,port_Integer]:=Module[{sock,respRes,resp,from},sock=CreateDatagramSocket[];SendDatagram["TIME\n",ToSocketAddress[host,port],sock];respRes=Quiet[ReadDatagram[sock,All,5]];If[ListQ[respRes]&&Length[respRes]==2,{resp,from}=respRes;If[StringQ[resp],Print["Server ",from[[1]]," \[RightArrow] ",StringTrim[resp]],Print["Invalid response received."]],Print["Timeout waiting for reply from ",host,":",port]];CloseSocket[sock];];
Clear[msgSend,msgRecv];
msgSend[sock_,{destIP_,destPort_},flag_Integer,path_String,message_String]:=Module[{buf},buf=ToString[flag]<>"|"<>destIP<>"|"<>path<>"|"<>message;SendDatagram[buf,ToSocketAddress[destIP,destPort],sock];];
msgRecv[sock_]:=Module[{res,pkt,from,parts},res=Quiet[ReadDatagram[sock,All,0]];If[ListQ[res]&&Length[res]==2,{pkt,from}=res;If[StringQ[pkt],parts=StringSplit[pkt,"|",4];If[Length[parts]==4,Association["Flag"->ToExpression[parts[[1]]],"IP"->parts[[2]],"Path"->parts[[3]],"Msg"->parts[[4]],"From"->from],$Failed],$Failed],$Failed]];
Clear[rreq,rrep,odrSend,odrRecv];
rreq[args___]:=(Message[rreq::stub];$Failed);
rreq::stub="rreq: raw Ethernet send not supported in Mathematica.";
rrep[args___]:=(Message[rrep::stub];$Failed);
rrep::stub="rrep: raw Ethernet send not supported in Mathematica.";
odrSend[args___]:=(Message[odrSend::stub];$Failed);
odrSend::stub="odrSend: raw Ethernet send not supported in Mathematica.";
odrRecv[]:=(Message[odrRecv::stub];$Failed);
odrRecv::stub="odrRecv: raw Ethernet recv not supported in Mathematica.";
ClearAll[initRoutingTable,isExistDestQ,checkStaleEntry,updateRoute,getNextHop];
initRoutingTable[]:=Table[Association["Dest"->None,"NextHop"->None,"Hops"->\[Infinity],"Time"->0],{10}];
isExistDestQ[rt_List,dest_]:=AnyTrue[rt,#Dest===dest&];
checkStaleEntry[rt_List,dest_,period_]:=Module[{now=AbsoluteTime[],idx},idx=FirstPosition[rt,x_/;x["Dest"]===dest,None];If[idx=!=None&&now-rt[[idx[[1]]]]["Time"]>period,Delete[rt,idx[[1]]],rt]];
updateRoute[rt_List,dest_,nextHop_,hops_]:=Module[{idx},idx=FirstPosition[rt,x_/;x["Dest"]===dest,None];If[idx===None,Append[rt,Association["Dest"->dest,"NextHop"->nextHop,"Hops"->hops,"Time"->AbsoluteTime[]]],ReplacePart[rt,idx[[1]]->Association["Dest"->dest,"NextHop"->nextHop,"Hops"->Min[rt[[idx[[1]]]]["Hops"],hops],"Time"->AbsoluteTime[]]]]];
getNextHop[rt_List,dest_]:=Module[{ent=SelectFirst[rt,#Dest===dest&,None]},If[ent===None,Missing["NoRoute"],ent["NextHop"]]];
Clear[getHwAddrs,freeHwAddrs];
getHwAddrs[]:=(Message[getHwAddrs::stub];$Failed);
getHwAddrs::stub="getHwAddrs: interface enumeration not supported.";
freeHwAddrs[_]:=Null;
name2addr["wolfram.com"]
addr2name["23.185.0.1"]
timeServ[4444]
timeCli["localhost",4444]
sock=CreateDatagramSocket[5555];
msgSend[sock,{"localhost",5555},0,"/tmp/path","Hello"];
msgRecv[sock]
initRoutingTable[]


ClearAll["Global`*"];
f[p_,q_,r_,k_]:=FractionalPart[Mean[{p,q,r}]+k];
Manipulate[Module[{initArray,evolution},initArray=N[Table[value[x],{x,-Floor[steps/2],Floor[steps/2],1}]];evolution=CellularAutomaton[{Function[{nb},Mod[Mean[nb]+k,1]],{},1},initArray,steps];view[evolution,Frame->True,FrameTicks->None,PlotRange->All,AspectRatio->1,ImageSize->{800,400},ColorFunction->"Rainbow",ColorFunctionScaling->True]],{{steps,500,"Steps"},10,500,1},{{k,0.0081,"k"},0,1,0.0001,Appearance->"Labeled"},{{view,ArrayPlot,"View"},{ArrayPlot->"Cell Gray Level",ListContourPlot->"Contour",ListDensityPlot->"Density"}},{{value,If[#1==0,1,0]&,"Initial Condition"},{(If[#1==0,1,0]&)->"One Cell",(.1+Sinc[#1]/2&)->"Sinc",(1/2 (1+Sin[#1])&)->"Sine",(RandomInteger[1]&)->"Random",(UnitStep[#1]&)->"Unit Step"}},ControlPlacement->Left]


ClearAll["Global`*"];
SeedRandom[1234];
nSamples=200;
nFeatures=4;
ABMInputsV2=RandomReal[{0,1},{nSamples,nFeatures}];
ABMOutputsV2=(Total[#1]+RandomReal[{-0.1,0.1}]&)/@ABMInputsV2;
ABMAssocV2=AssociationThread[ABMInputsV2->ABMOutputsV2];
ABMNormalV2=Normal[ABMAssocV2];
ABMNormalRandom=RandomSample[ABMNormalV2];
{fullTrain,testSet}=TakeDrop[ABMNormalRandom,Round[nSamples 0.8]];
{finalTrain,finalDev}=TakeDrop[fullTrain,Round[Length[fullTrain] 0.8]];
finalTest=testSet;
Print["Training examples: ",Length[finalTrain]];
Print["Development examples: ",Length[finalDev]];
Print["Test examples: ",Length[finalTest]];
models=Association["RandomForest"->Predict[finalTrain,Method->"RandomForest"],"GradientBoostedTrees"->Predict[finalTrain,Method->"GradientBoostedTrees"],"NeuralNetwork"->Predict[finalTrain,Method->{"NeuralNetwork","NetworkDepth"->3,"NetworkType"->"FullyConnected","L2Regularization"->0.05,MaxTrainingRounds->4000}],"GaussianProcess"->Predict[finalTrain,Method->"GaussianProcess"],"DecisionTree"->Predict[finalTrain,Method->"DecisionTree"],"NearestNeighbors"->Predict[finalTrain,Method->"NearestNeighbors"],"LinearRegression"->Predict[finalTrain,Method->"LinearRegression"]];
Do[modelName=key;model=models[key];pm=PredictorMeasurements[model,finalTest];Print["--- ",modelName," ---"];Print["MeanSquare: ",pm["MeanSquare"]];Print[pm["ResidualPlot"]],{key,Keys[models]}];
netSimple=NetChain[{BatchNormalizationLayer[],Tanh,20,20,BatchNormalizationLayer[],Tanh,1}];
trainedNet=NetTrain[netSimple,finalTrain,All,ValidationSet->finalTest,MaxTrainingRounds->2000,Method->{"ADAM","LearningRate"->0.001,"L2Regularization"->0.1}];
Print["Net Training Completed."];
trainedNet["LossEvolutionPlot"]


ClearAll["Global`*"];
mA=10;
mB=1;
omega=1;
Print["Initializing parameters: mA=",mA,", mB=",mB,", \[Omega]=",omega];
M=mA+mB;
gamma=(M omega)/2;
mu=(mA mB)/M;
rMin=1/10^16;rMax=50.;nStates=20;up=4;
prec=30;
V[r_]:=-(1/r)+1/2 mu omega^2 r^2
HOP[f_]:=-(Laplacian[f[r],{r}]/(2 mu))+V[r] f[r]
Print["Solving eigenproblem\[Ellipsis]"];
{eVals,eFuncs}=NDEigensystem[{HOP[f],DirichletCondition[f[r]==0,r<=rMin],DirichletCondition[f[r]==0,r>=rMax]},f[r],{r,rMin,rMax},nStates,Method->{"SpatialDiscretization"->{"FiniteElement",{"MeshOptions"->{"MaxCellMeasure"->0.001}}}}];
idx=First[First[Position[eVals,Min[eVals]]]];
E0=eVals[[idx]];
\[Psi]0[r_]:=eFuncs[[idx]]/. r->r;
Print["Ground state energy E\:2080 = ",E0];
normConst=Quiet[NIntegrate[(M^2 Exp[-2 gamma re^2] \[Psi]0[r]^2 Exp[-(((2 gamma mB^2) r^2)/M^2)] (Exp[((4 gamma mB) re r)/M]-Exp[-(((4 gamma mB) re r)/M)]))/((4 \[Pi]) (mB^2+mB) r),{r,rMin,rMax},{re,rMin,rMax},WorkingPrecision->prec,AccuracyGoal->4,PrecisionGoal->4,Method->"DoubleExponential"]];
Clear[innerInt];
innerInt[re_?NumericQ]:=innerInt[re]=Quiet[NIntegrate[(\[Psi]0[r]^2 Exp[-(((2 gamma mB^2) r^2)/M^2)] (Exp[((4 gamma mB) re r)/M]-Exp[-(((4 gamma mB) re r)/M)]))/r,{r,rMin,rMax},WorkingPrecision->prec,AccuracyGoal->4,PrecisionGoal->4,Method->"DoubleExponential"]];
rho[re_?NumericQ]:=(normConst (2 \[Pi]) M^2 Exp[-2 gamma re^2] innerInt[re])/((4 gamma) (mB^2+mB) re);
Print["Building density dataset\[Ellipsis]"];
data=Table[{re,rho[re]},{re,1/10^10,up,up/70}];
Print["Rendering final plot\[Ellipsis]"];
ListLinePlot[data,PlotTheme->"Detailed",Frame->True,FrameLabel->{"Radial Distance \(r\)","Probability Density \(\rho(r)\)"},PlotLabel->Style["Daed\[AE]lus LINK Simulation:\nKnowledge Density of Bob",Bold,14],ImageSize->Large,Epilog->{Text[Style["m_p="<>ToString[mA]<>", \[Omega]="<>ToString[omega],Gray,10],Scaled[{0.8,0.9}]]}]


Options[MultiwayPetriNet]=Join[{"IncludeStepNumber"->False,"IncludeStateID"->False,"IncludeInitializationEvents"->False,"IncludeEventInstances"->False,"IncludeStateWeights"->False,"IncludeStatePathWeights"->False,"StateRenderingFunction"->Automatic,"EventRenderingFunction"->Automatic,"MaxItems"->\[Infinity],"GivePredecessors"->False,"GiveResolvents"->False,"IncludeSelfPairs"->False,"IncludeFullBranchialSpace"->False,"LineThickness"->1,"VertexSizeMultiplier"->1},Options[Graph]];
getEventSelectionFunction["Random"]:={RandomChoice[#1]}&
getEventSelectionFunction["Sequential"]:={First[#1]}&
getEventSelectionFunction[{"Random",eventCount_Integer}]:=RandomChoice[#1,eventCount]&
getEventSelectionFunction[function_Symbol|function_Function]:=function
buildTextDot[vertex_,dotsCount_Integer,coordinateAssociation_Association]:=Text[StringRepeat["\[FilledSmallCircle]",dotsCount],coordinateAssociation[vertex]]
buildTextDotsList[coordinateAssociation_Association,vertexWeightAssociation_Association,vertices_List]:=Module[{dotsList},dotsList={};Scan[AppendTo[dotsList,buildTextDot[#1,vertexWeightAssociation[#1],coordinateAssociation]]&,vertices];dotsList]
applyBooleanOperatorToList[booleanOperator_,list_List]:=Fold[booleanOperator,First[list],Rest[list]]
petriNetQ[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List]]:=Module[{petriNetGraph},petriNetGraph=Graph[Apply[DirectedEdge,arcs,{1}]];applyBooleanOperatorToList[And,{places\[Intersection]transitions=={},BipartiteGraphQ[petriNetGraph]}]]
constructPetriNet[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List]]:=If[petriNetQ[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],{Graph[Join[places,transitions],Apply[DirectedEdge,arcs,{1}],VertexShapeFunction->Join[Thread[places->"Circle"],Thread[transitions->"Square"]],VertexLabels->"Name",VertexStyle->Join[Thread[places->LightBlue],Thread[transitions->LightGray]],VertexSize->Large],places,transitions,Apply[DirectedEdge,arcs,{1}]},$Failed]
renderPetriNet[petriNet_List,initialConditions_List]:=Module[{petriNetGraph,coordinateAssociation,vertexWeightAssociation,graphData,vertexWeight,graphEpilog},petriNetGraph=Graph[First[petriNet],VertexWeight->Join[Thread[petriNet[[2]]->initialConditions],Thread[petriNet[[3]]->0]]];graphData=ToExpression[StringReplace[ToString[FullForm[petriNetGraph]],"Graph"->"List"]];vertexWeight=Last[Last[graphData[[3]]]];coordinateAssociation=Association[Thread[graphData[[1]]->VertexCoordinates/. AbsoluteOptions[petriNetGraph,VertexCoordinates]]];vertexWeightAssociation=Association[Thread[graphData[[1]]->vertexWeight]];graphEpilog=buildTextDotsList[coordinateAssociation,vertexWeightAssociation,graphData[[1]]];Graph[petriNetGraph,Epilog->graphEpilog]]
renderPetriNetWeighted[petriNet_List,initialConditions_List]:=Graph[First[petriNet],VertexWeight->Join[Thread[petriNet[[2]]->initialConditions],Thread[petriNet[[3]]->0]]]
PetriNetObject/:MakeBoxes[petriNet:PetriNetObject[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List],format_]:=Module[{placeCount,transitionCount,arcCount,tokenCount},placeCount=Length[places];transitionCount=Length[transitions];arcCount=Length[arcs];tokenCount=Length[initialConditions];BoxForm`ArrangeSummaryBox["PetriNetObject",petriNet,GraphPlot[First[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]]],VertexLabels->None,EdgeShapeFunction->GraphElementData["ShortFilledArrow","ArrowSize"->0.05]],{{\!\(\*
TagBox["\"\<Places: \>\"",
"SummaryItemAnnotation"]\) \!\(\*
TagBox["placeCount",
"SummaryItem"]\)},{\!\(\*
TagBox["\"\<Transitions: \>\"",
"SummaryItemAnnotation"]\) \!\(\*
TagBox["transitionCount",
"SummaryItem"]\)},{\!\(\*
TagBox["\"\<Arcs: \>\"",
"SummaryItemAnnotation"]\) \!\(\*
TagBox["arcCount",
"SummaryItem"]\)}},{{\!\(\*
TagBox["\"\<Tokens: \>\"",
"SummaryItemAnnotation"]\) \!\(\*
TagBox["tokenCount",
"SummaryItem"]\)}},format,"Interpretable"->Automatic]]
PetriNetObject[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List]["AssociationForm"]:=Association["Places"->places,"Transitions"->transitions,"Arcs"->arcs]
PetriNetObject[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List]["Places"]:=places
PetriNetObject[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List]["PlaceCount"]:=Length[places]
PetriNetObject[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List]["Transitions"]:=transitions
PetriNetObject[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List]["TransitionCount"]:=Length[transitions]
PetriNetObject[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List]["Arcs"]:=arcs
PetriNetObject[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List]["ArcCount"]:=Length[arcs]
PetriNetObject[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List]["Tokens"]:=initialConditions
PetriNetObject[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List]["TokenCount"]:=Total[initialConditions]
PetriNetObject[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List]["UnlabeledGraph"]:=First[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]]]
PetriNetObject[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List]["LabeledGraph"]:=renderPetriNet[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],initialConditions]
PetriNetObject[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List]["WeightedGraph"]:=renderPetriNetWeighted[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],initialConditions]
PetriNetObject[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List]["Properties"]:={"AssociationForm","Places","PlaceCount","Transitions","TransitionCount","Arcs","ArcCount","Tokens","TokenCount","UnlabeledGraph","LabeledGraph","WeightedGraph"}
makePetriNet[associationForm_Association]:=PetriNetObject[KeySort[associationForm],ConstantArray[0,Length[associationForm["Places"]]]]/;KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"Places"]&&KeyExistsQ[associationForm,"Transitions"]
makePetriNet[associationForm_Association,initialConditions_List]:=PetriNetObject[KeySort[associationForm],initialConditions]/;KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"Places"]&&KeyExistsQ[associationForm,"Transitions"]
makePetriNet[places_List,transitions_List,arcs_List]:=PetriNetObject[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions],ConstantArray[0,Length[places]]]
makePetriNet[places_List,transitions_List,arcs_List,initialConditions_List]:=PetriNetObject[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions],initialConditions]/;Length[initialConditions]==Length[places]
transitionFiringQ[petriNet_List,transition_,currentTokens_List]:=Module[{tokenCount},tokenCount=(Length[EdgeList[First[petriNet],#1\[DirectedEdge]transition]]&)/@petriNet[[2]];AllTrue[currentTokens-tokenCount,NonNegative]]
applyTransitionFiring[petriNet_List,transition_,currentTokens_List]:=Module[{deletedTokensCount,addedTokensCount},deletedTokensCount=(Length[EdgeList[First[petriNet],#1\[DirectedEdge]transition]]&)/@petriNet[[2]];addedTokensCount=(Length[EdgeList[First[petriNet],transition\[DirectedEdge]#1]]&)/@petriNet[[2]];currentTokens-deletedTokensCount+addedTokensCount]
updateTransitionFiringMultiway[petriNet_List][currentTokens_List]:=Module[{transitionIndices,validTransitionIndices},transitionIndices=First/@Position[(transitionFiringQ[petriNet,#1,currentTokens]&)/@petriNet[[3]],True];validTransitionIndices=Select[transitionIndices,IntegerQ];(applyTransitionFiring[petriNet,petriNet[[3,#1]],currentTokens]&)/@validTransitionIndices]
petriNetMultiwayEvolution[petriNet_List,initialConditions_List]:=Module[{currentTokens,transitionIndices,validTransitionIndices},currentTokens=initialConditions;currentTokens=updateTransitionFiringMultiway[petriNet][currentTokens];transitionIndices=Catenate[(Module[{tokens=#1},First/@Position[(transitionFiringQ[petriNet,#1,tokens]&)/@petriNet[[3]],True]]&)/@currentTokens];validTransitionIndices=Select[transitionIndices,IntegerQ];(Module[{tokens=#1},(applyTransitionFiring[petriNet,petriNet[[3,#1]],tokens]&)/@validTransitionIndices]&)/@currentTokens;DeleteDuplicates[Catenate[(Module[{tokens=#1},({tokens,petriNet[[3,#1]]}&)/@validTransitionIndices]&)/@currentTokens]]]
getPetriNetStateEvolutionFunction[petriNet_List,initialConditions_String]:=ToString/@petriNetMultiwayEvolution[petriNet,First[ToExpression[initialConditions]]]
getPetriNetStateEvolutionFunction[petriNet_List,{stepNumber_Integer,stateID_Integer}->initialConditions_String]:=({stepNumber+1,RandomInteger[10^10]}->#1&)/@ToString/@petriNetMultiwayEvolution[petriNet,First[ToExpression[initialConditions]]]
getPetriNetStateEvolutionFunction[petriNet_List,stepNumber_Integer->initialConditions_String]:=(stepNumber+1->#1&)/@ToString/@petriNetMultiwayEvolution[petriNet,First[ToExpression[initialConditions]]]
getPetriNetStateEvolutionFunction[petriNet_List,{Automatic,stateID_Integer}->initialConditions_String]:=({Automatic,RandomInteger[10^10]}->#1&)/@ToString/@petriNetMultiwayEvolution[petriNet,First[ToExpression[initialConditions]]]
getPetriNetStateEventFunction[initialConditions_String,petriNet_List]:=Module[{evolution=ToString/@petriNetMultiwayEvolution[petriNet,First[ToExpression[initialConditions]]]},(Module[{length=StringLength[Last[Last[System`Dump`showStringDiff[initialConditions,#1]]]]},{StringDrop[initialConditions,-length]->StringDrop[#1,-length],StringDrop[initialConditions,-length],{"",StringTake[initialConditions,-length]}}]&)/@evolution]
getPetriNetStateEventFunction[initialConditions:{_String...},petriNet_List]:=Catenate[(getPetriNetStateEventFunction[#1,petriNet]&)/@initialConditions]
getPetriNetStateEventFunction[{stepNumber_Integer,stateID_Integer}->initialConditions_String,petriNet_List]:=({stepNumber,{stateID,RandomInteger[10^10]}}->#1&)/@Module[{evolution=ToString/@petriNetMultiwayEvolution[petriNet,First[ToExpression[initialConditions]]]},(Module[{length=StringLength[Last[Last[System`Dump`showStringDiff[initialConditions,#1]]]]},{StringDrop[initialConditions,-length]->StringDrop[#1,-length],StringDrop[initialConditions,-length],{"",StringTake[initialConditions,-length]}}]&)/@evolution]
getPetriNetStateEventFunction[stepNumber_Integer->initialConditions_String,petriNet_List]:=(stepNumber->#1&)/@Module[{evolution=ToString/@petriNetMultiwayEvolution[petriNet,First[ToExpression[initialConditions]]]},(Module[{length=StringLength[Last[Last[System`Dump`showStringDiff[initialConditions,#1]]]]},{StringDrop[initialConditions,-length]->StringDrop[#1,-length],StringDrop[initialConditions,-length],{"",StringTake[initialConditions,-length]}}]&)/@evolution]
getPetriNetStateEventFunction[{Automatic,stateID_Integer}->initialConditions_String,petriNet_List]:=({Automatic,{stateID,RandomInteger[10^10]}}->#1&)/@Module[{evolution=ToString/@petriNetMultiwayEvolution[petriNet,First[ToExpression[initialConditions]]]},(Module[{length=StringLength[Last[Last[System`Dump`showStringDiff[initialConditions,#1]]]]},{StringDrop[initialConditions,-length]->StringDrop[#1,-length],StringDrop[initialConditions,-length],{"",StringTake[initialConditions,-length]}}]&)/@evolution]
getPetriNetStateEventFunction[initialConditions:{_Rule...},petriNet_List]:=Catenate[(getPetriNetStateEventFunction[#1,petriNet]&)/@initialConditions]
getPetriNetEventDecompositionFunction[event:{input_String|input_Symbol->output_String,input_String|input_Symbol,{prefix_String,suffix_String}}]:=Join[{getPetriNetElementShifts[event]},(getPetriNetElements[{#1,{prefix,suffix}}]&)/@{input,output}]
getPetriNetElementShifts[shiftedFragment_String,{input:{inputPrefix_String,inputSuffix_String},output:{outputPrefix_String,outputSuffix_String}}]:=Table[Rule@@Apply[{StringPart[shiftedFragment,position],{#1<>StringTake[shiftedFragment,1;;position-1],StringTake[shiftedFragment,position+1;;All]<>#2}}&,{input,output},{1}],{position,StringLength[shiftedFragment]}]
getPetriNetElementShifts[{input_String|input_Symbol->output_String,input_String|input_Symbol,{prefix_String,suffix_String}}]:=Join[getPetriNetElementShifts[prefix,{{"",input<>suffix},{"",output<>suffix}}],getPetriNetElementShifts[suffix,{{prefix<>input,""},{prefix<>output,""}}]]
getPetriNetElements[{substring_String,{prefix_String,suffix_String}}]:=({StringPart[substring,#1],{prefix<>StringTake[substring,1;;#1-1],StringTake[substring,#1+1;;All]<>suffix}}&)/@Range[StringLength[substring]]
getPetriNetEventApplicationFunction[{input_String|input_Symbol->output_String,input_String|input_Symbol,{prefix_String,suffix_String}}]:=prefix<>output<>suffix
getPetriNetEventApplicationFunction[{stepNumber_Integer,{inputStateID_Integer|inputStateID_Symbol,outputStateID_Integer}}->{input_String|input_Symbol->output_String,input_String|input_Symbol,{prefix_String,suffix_String}}]:={stepNumber+1,outputStateID}->prefix<>output<>suffix
getPetriNetEventApplicationFunction[stepNumber_Integer->{input_String|input_Symbol->output_String,input_String|input_Symbol,{prefix_String,suffix_String}}]:=stepNumber+1->prefix<>output<>suffix
getPetriNetEventApplicationFunction[{Automatic,{inputStateID_Integer|inputStateID_Symbol,outputStateID_Integer}}->{input_String|input_Symbol->output_String,input_String|input_Symbol,{prefix_String,suffix_String}}]:={Automatic,outputStateID}->prefix<>output<>suffix
stripMetadata[expression_]:=If[Head[expression]===Rule,Last[expression],expression]
getPetriNetStateRenderingFunction[petriNet_List]:=Inset[Framed[Style[GraphPlot[If[Last[ToExpression[stripMetadata[#2]]]===Null,renderPetriNet[petriNet,First[ToExpression[stripMetadata[#2]]]],HighlightGraph[renderPetriNet[petriNet,First[ToExpression[stripMetadata[#2]]]],{Last[ToExpression[stripMetadata[#2]]],ToString[Last[ToExpression[stripMetadata[#2]]]]}]],VertexLabels->None,EdgeShapeFunction->GraphElementData["ShortFilledArrow","ArrowSize"->0.05]],Hue[0.62,1,0.48]],Background->Directive[Opacity[0.2],Hue[0.62,0.45,0.87]],RoundingRadius->0,FrameStyle->Directive[Opacity[0.5],Hue[0.62,0.52,0.82]]],#1,{0,0},#3]&
getPetriNetEventRenderingFunction[petriNet_List]:=If[First[First[stripMetadata[#2]]]===Null,Inset[Framed[Column[{Framed[Style[GraphPlot[If[Last[ToExpression[stripMetadata[#2][[3,1]]<>stripMetadata[#2][[1,2]]<>stripMetadata[#2][[3,2]]]]===Null,renderPetriNet[petriNet,First[ToExpression[stripMetadata[#2][[3,1]]<>stripMetadata[#2][[1,2]]<>stripMetadata[#2][[3,2]]]]],HighlightGraph[renderPetriNet[First[ToExpression[stripMetadata[#2][[3,1]]<>stripMetadata[#2][[1,2]]<>stripMetadata[#2][[3,2]]]]],{Last[ToExpression[stripMetadata[#2][[3,1]]<>stripMetadata[#2][[1,2]]<>stripMetadata[#2][[3,2]]]],ToString[Last[ToExpression[stripMetadata[#2][[3,1]]<>stripMetadata[#2][[1,2]]<>stripMetadata[#2][[3,2]]]]]}]],VertexLabels->None,EdgeShapeFunction->GraphElementData["ShortFilledArrow","ArrowSize"->0.05],ImageSize->Scaled[0.5]]]]},Center,0],Background->Directive[Opacity[0.7],RGBColor[0.259,0.576,1]],FrameMargins->{{2,2},{0,0}},RoundingRadius->0,FrameStyle->Directive[Opacity[0.4],Hue[0.09,1,0.91]]],#1,Center,#3],Inset[Framed[Column[{Framed[Style[GraphPlot[If[Last[ToExpression[stripMetadata[#2][[3,1]]<>stripMetadata[#2][[1,1]]<>stripMetadata[#2][[3,2]]]]===Null,renderPetriNet[petriNet,First[ToExpression[stripMetadata[#2][[3,1]]<>stripMetadata[#2][[1,1]]<>stripMetadata[#2][[3,2]]]]],HighlightGraph[renderPetriNet[petriNet,First[ToExpression[stripMetadata[#2][[3,1]]<>stripMetadata[#2][[1,1]]<>stripMetadata[#2][[3,2]]]]],{Last[ToExpression[stripMetadata[#2][[3,1]]<>stripMetadata[#2][[1,1]]<>stripMetadata[#2][[3,2]]]],ToString[Last[ToExpression[stripMetadata[#2][[3,1]]<>stripMetadata[#2][[1,1]]<>stripMetadata[#2][[3,2]]]]]}]],VertexLabels->None,EdgeShapeFunction->GraphElementData["ShortFilledArrow","ArrowSize"->0.05],ImageSize->Scaled[0.5]]]],Framed[Style[GraphPlot[If[Last[ToExpression[stripMetadata[#2][[3,1]]<>stripMetadata[#2][[1,2]]<>stripMetadata[#2][[3,2]]]]===Null,renderPetriNet[petriNet,First[ToExpression[stripMetadata[#2][[3,1]]<>stripMetadata[#2][[1,2]]<>stripMetadata[#2][[3,2]]]]],HighlightGraph[renderPetriNet[petriNet,First[ToExpression[stripMetadata[#2][[3,1]]<>stripMetadata[#2][[1,2]]<>stripMetadata[#2][[3,2]]]]],{Last[ToExpression[stripMetadata[#2][[3,1]]<>stripMetadata[#2][[1,2]]<>stripMetadata[#2][[3,2]]]],ToString[Last[ToExpression[stripMetadata[#2][[3,1]]<>stripMetadata[#2][[1,2]]<>stripMetadata[#2][[3,2]]]]]}]],VertexLabels->None,EdgeShapeFunction->GraphElementData["ShortFilledArrow","ArrowSize"->0.05],ImageSize->Scaled[0.5]]]]},Center,0],Background->Directive[Opacity[0.7],Hue[0.14,0.34,1]],FrameMargins->{{2,2},{0,0}},RoundingRadius->0,FrameStyle->Directive[Opacity[0.4],Hue[0.09,1,0.91]]],#1,Center,#3]]&
MultiwayPetriNet[associationForm_Association,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[associationForm]->Identity,1,"PetriNetObjects",options]/;KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"Places"]&&KeyExistsQ[associationForm,"Transitions"]
MultiwayPetriNet[associationForm_Association,initialConditions_List,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[associationForm,initialConditions]->Identity,1,"PetriNetObjects",options]/;KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"Places"]&&KeyExistsQ[associationForm,"Transitions"]
MultiwayPetriNet[associationForm_Association,stepCount_Integer,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[associationForm]->Identity,stepCount,"PetriNetObjects",options]/;KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"Places"]&&KeyExistsQ[associationForm,"Transitions"]
MultiwayPetriNet[associationForm_Association,initialConditions_List,stepCount_Integer,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[associationForm,initialConditions]->Identity,stepCount,"PetriNetObjects",options]/;KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"Places"]&&KeyExistsQ[associationForm,"Transitions"]
MultiwayPetriNet[associationForm_Association,property_String,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[associationForm]->Identity,1,property,options]/;KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"Places"]&&KeyExistsQ[associationForm,"Transitions"]
MultiwayPetriNet[associationForm_Association,initialConditions_List,property_String,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[associationForm,initialConditions]->Identity,1,property,options]/;KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"Places"]&&KeyExistsQ[associationForm,"Transitions"]
MultiwayPetriNet[associationForm_Association,stepCount_Integer,property_String,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[associationForm]->Identity,stepCount,property,options]/;KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"Places"]&&KeyExistsQ[associationForm,"Transitions"]
MultiwayPetriNet[associationForm_Association,initialConditions_List,stepCount_Integer,property_String,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[associationForm,initialConditions]->Identity,stepCount,property,options]/;KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"Places"]&&KeyExistsQ[associationForm,"Transitions"]
MultiwayPetriNet[associationForm_Association->eventSelectionFunction_,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[associationForm]->eventSelectionFunction,1,"PetriNetObjects",options]/;KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"Places"]&&KeyExistsQ[associationForm,"Transitions"]
MultiwayPetriNet[associationForm_Association->eventSelectionFunction_,initialConditions_List,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[associationForm,initialConditions]->eventSelectionFunction,1,"PetriNetObjects",options]/;KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"Places"]&&KeyExistsQ[associationForm,"Transitions"]
MultiwayPetriNet[associationForm_Association->eventSelectionFunction_,stepCount_Integer,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[associationForm]->eventSelectionFunction,stepCount,"PetriNetObjects",options]/;KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"Places"]&&KeyExistsQ[associationForm,"Transitions"]
MultiwayPetriNet[associationForm_Association->eventSelectionFunction_,initialConditions_List,stepCount_Integer,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[associationForm,initialConditions]->eventSelectionFunction,stepCount,"PetriNetObjects",options]/;KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"Places"]&&KeyExistsQ[associationForm,"Transitions"]
MultiwayPetriNet[associationForm_Association->eventSelectionFunction_,property_String,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[associationForm]->eventSelectionFunction,1,property,options]/;KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"Places"]&&KeyExistsQ[associationForm,"Transitions"]
MultiwayPetriNet[associationForm_Association->eventSelectionFunction_,initialConditions_List,property_String,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[associationForm,initialConditions]->eventSelectionFunction,1,property,options]/;KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"Places"]&&KeyExistsQ[associationForm,"Transitions"]
MultiwayPetriNet[associationForm_Association->eventSelectionFunction_,stepCount_Integer,property_String,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[associationForm]->eventSelectionFunction,stepCount,property,options]/;KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"Places"]&&KeyExistsQ[associationForm,"Transitions"]
MultiwayPetriNet[associationForm_Association->eventSelectionFunction_,initialConditions_List,stepCount_Integer,property_String,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[associationForm,initialConditions]->eventSelectionFunction,stepCount,property,options]/;KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"Places"]&&KeyExistsQ[associationForm,"Transitions"]
MultiwayPetriNet[places_List,transitions_List,arcs_List,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[places,transitions,arcs]->Identity,1,"PetriNetObjects",options]
MultiwayPetriNet[places_List,transitions_List,arcs_List,initialConditions_List,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[places,transitions,arcs,initialConditions]->Identity,1,"PetriNetObjects",options]/;Length[initialConditions]==Length[places]
MultiwayPetriNet[places_List,transitions_List,arcs_List,stepCount_Integer,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[places,transitions,arcs]->Identity,stepCount,"PetriNetObjects",options]
MultiwayPetriNet[places_List,transitions_List,arcs_List,initialConditions_List,stepCount_Integer,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[places,transitions,arcs,initialConditions]->Identity,stepCount,"PetriNetObjects",options]/;Length[initialConditions]==Length[places]
MultiwayPetriNet[places_List,transitions_List,arcs_List,property_String,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[places,transitions,arcs]->Identity,1,property,options]
MultiwayPetriNet[places_List,transitions_List,arcs_List,initialConditions_List,property_String,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[places,transitions,arcs,initialConditions]->Identity,1,property,options]/;Length[initialConditions]==Length[places]
MultiwayPetriNet[places_List,transitions_List,arcs_List,stepCount_Integer,property_String,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[places,transitions,arcs]->Identity,stepCount,property,options]
MultiwayPetriNet[places_List,transitions_List,arcs_List,initialConditions_List,stepCount_Integer,property_String,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[places,transitions,arcs,initialConditions]->Identity,stepCount,property,options]/;Length[initialConditions]==Length[places]
MultiwayPetriNet[{places_List,transitions_List,arcs_List}->eventSelectionFunction_,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[places,transitions,arcs]->eventSelectionFunction,1,"PetriNetObjects",options]
MultiwayPetriNet[{places_List,transitions_List,arcs_List}->eventSelectionFunction_,initialConditions_List,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[places,transitions,arcs,initialConditions]->eventSelectionFunction,1,"PetriNetObjects",options]/;Length[initialConditions]==Length[places]
MultiwayPetriNet[{places_List,transitions_List,arcs_List}->eventSelectionFunction_,stepCount_Integer,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[places,transitions,arcs]->eventSelectionFunction,stepCount,"PetriNetObjects",options]
MultiwayPetriNet[{places_List,transitions_List,arcs_List}->eventSelectionFunction_,initialConditions_List,stepCount_Integer,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[places,transitions,arcs,initialConditions]->eventSelectionFunction,stepCount,"PetriNetObjects",options]/;Length[initialConditions]==Length[places]
MultiwayPetriNet[{places_List,transitions_List,arcs_List}->eventSelectionFunction_,property_String,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[places,transitions,arcs]->eventSelectionFunction,1,property,options]
MultiwayPetriNet[{places_List,transitions_List,arcs_List}->eventSelectionFunction_,initialConditions_List,property_String,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[places,transitions,arcs,initialConditions]->eventSelectionFunction,1,property,options]/;Length[initialConditions]==Length[places]
MultiwayPetriNet[{places_List,transitions_List,arcs_List}->eventSelectionFunction_,stepCount_Integer,property_String,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[places,transitions,arcs]->eventSelectionFunction,stepCount,property,options]
MultiwayPetriNet[{places_List,transitions_List,arcs_List}->eventSelectionFunction_,initialConditions_List,stepCount_Integer,property_String,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[places,transitions,arcs,initialConditions]->eventSelectionFunction,stepCount,property,options]/;Length[initialConditions]==Length[places]
MultiwayPetriNet[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List],options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions],initialConditions]->Identity,1,"PetriNetObjects",options]/;SymbolName[petriNetObject]==="PetriNetObject"
MultiwayPetriNet[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List],stepCount_Integer,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions],initialConditions]->Identity,stepCount,"PetriNetObjects",options]/;SymbolName[petriNetObject]==="PetriNetObject"
MultiwayPetriNet[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List],property_String,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions],initialConditions]->Identity,1,property,options]/;SymbolName[petriNetObject]==="PetriNetObject"
MultiwayPetriNet[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List],stepCount_Integer,property_String,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions],initialConditions]->Identity,stepCount,property,options]/;SymbolName[petriNetObject]==="PetriNetObject"
MultiwayPetriNet[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List]->eventSelectionFunction_,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions],initialConditions]->eventSelectionFunction,1,"PetriNetObjects",options]/;SymbolName[petriNetObject]==="PetriNetObject"
MultiwayPetriNet[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List]->eventSelectionFunction_,stepCount_Integer,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions],initialConditions]->eventSelectionFunction,stepCount,"PetriNetObjects",options]/;SymbolName[petriNetObject]==="PetriNetObject"
MultiwayPetriNet[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List]->eventSelectionFunction_,property_String,options:OptionsPattern[]]:=MultiwayPetriNet[makePetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions],initialConditions]->eventSelectionFunction,1,property,options]/;SymbolName[petriNetObject]==="PetriNetObject"
MultiwayPetriNet[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List]->eventSelectionFunction_,stepCount_Integer,property_String,options:OptionsPattern[]]:=ResourceFunction["MultiwaySystem"][Association["StateEvolutionFunction"->(getPetriNetStateEvolutionFunction[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],#1]&),"StateEquivalenceFunction"->SameQ,"StateEventFunction"->(getPetriNetStateEventFunction[#1,constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]]]&),"EventDecompositionFunction"->getPetriNetEventDecompositionFunction,"EventApplicationFunction"->getPetriNetEventApplicationFunction,"SystemType"->"PetriNet","EventSelectionFunction"->getEventSelectionFunction[eventSelectionFunction]],{ToString[{initialConditions,Null}]},stepCount,property,options,"StateRenderingFunction"->getPetriNetStateRenderingFunction[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]]],"EventRenderingFunction"->getPetriNetEventRenderingFunction[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]]]]/;SymbolName[petriNetObject]==="PetriNetObject"&&property=!="PetriNetObjects"&&property=!="LabeledGraphs"&&property=!="LabeledGraphsHighlighted"&&property=!="WeightedGraphs"&&property=!="WeightedGraphsHighlighted"&&property=!="Tokens"&&property=!="TokenFirings"
MultiwayPetriNet[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List]->eventSelectionFunction_,stepCount_Integer,"PetriNetObjects",options:OptionsPattern[]]:=(Module[{generation=#1},DeleteDuplicates[(makePetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions],First[ToExpression[stripMetadata[#1]]]]&)/@generation]]&)/@ResourceFunction["MultiwaySystem"][Association["StateEvolutionFunction"->(getPetriNetStateEvolutionFunction[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],#1]&),"StateEquivalenceFunction"->SameQ,"StateEventFunction"->(getPetriNetStateEventFunction[#1,constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]]]&),"EventDecompositionFunction"->getPetriNetEventDecompositionFunction,"EventApplicationFunction"->getPetriNetEventApplicationFunction,"SystemType"->"PetriNet","EventSelectionFunction"->getEventSelectionFunction[eventSelectionFunction]],{ToString[{initialConditions,Null}]},stepCount,"AllStatesList",options]/;SymbolName[petriNetObject]==="PetriNetObject"
MultiwayPetriNet[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List]->eventSelectionFunction_,stepCount_Integer,"LabeledGraphs",options:OptionsPattern[]]:=(Module[{generation=#1},(Graph[#1,FilterRules[{options},Options[Graph]]]&)/@DeleteDuplicates[(renderPetriNet[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],First[ToExpression[stripMetadata[#1]]]]&)/@generation]]&)/@ResourceFunction["MultiwaySystem"][Association["StateEvolutionFunction"->(getPetriNetStateEvolutionFunction[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],#1]&),"StateEquivalenceFunction"->SameQ,"StateEventFunction"->(getPetriNetStateEventFunction[#1,constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]]]&),"EventDecompositionFunction"->getPetriNetEventDecompositionFunction,"EventApplicationFunction"->getPetriNetEventApplicationFunction,"SystemType"->"PetriNet","EventSelectionFunction"->getEventSelectionFunction[eventSelectionFunction]],{ToString[{initialConditions,Null}]},stepCount,"AllStatesList",options]/;SymbolName[petriNetObject]==="PetriNetObject"
MultiwayPetriNet[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List]->eventSelectionFunction_,stepCount_Integer,"LabeledGraphsHighlighted",options:OptionsPattern[]]:=(Module[{generation=#1},(Graph[#1,FilterRules[{options},Options[Graph]]]&)/@DeleteDuplicates[(HighlightGraph[renderPetriNet[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],First[ToExpression[stripMetadata[#1]]]],{Last[ToExpression[stripMetadata[#1]]]}]&)/@generation]]&)/@ResourceFunction["MultiwaySystem"][Association["StateEvolutionFunction"->(getPetriNetStateEvolutionFunction[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],#1]&),"StateEquivalenceFunction"->SameQ,"StateEventFunction"->(getPetriNetStateEventFunction[#1,constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]]]&),"EventDecompositionFunction"->getPetriNetEventDecompositionFunction,"EventApplicationFunction"->getPetriNetEventApplicationFunction,"SystemType"->"PetriNet","EventSelectionFunction"->getEventSelectionFunction[eventSelectionFunction]],{ToString[{initialConditions,Null}]},stepCount,"AllStatesList",options]/;SymbolName[petriNetObject]==="PetriNetObject"
MultiwayPetriNet[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List]->eventSelectionFunction_,stepCount_Integer,"WeightedGraphs",options:OptionsPattern[]]:=(Module[{generation=#1},(Graph[#1,FilterRules[{options},Options[Graph]]]&)/@DeleteDuplicates[(renderPetriNetWeighted[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],First[ToExpression[stripMetadata[#1]]]]&)/@generation]]&)/@ResourceFunction["MultiwaySystem"][Association["StateEvolutionFunction"->(getPetriNetStateEvolutionFunction[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],#1]&),"StateEquivalenceFunction"->SameQ,"StateEventFunction"->(getPetriNetStateEventFunction[#1,constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]]]&),"EventDecompositionFunction"->getPetriNetEventDecompositionFunction,"EventApplicationFunction"->getPetriNetEventApplicationFunction,"SystemType"->"PetriNet","EventSelectionFunction"->getEventSelectionFunction[eventSelectionFunction]],{ToString[{initialConditions,Null}]},stepCount,"AllStatesList",options]/;SymbolName[petriNetObject]==="PetriNetObject"
MultiwayPetriNet[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List]->eventSelectionFunction_,stepCount_Integer,"WeightedGraphsHighlighted",options:OptionsPattern[]]:=(Module[{generation=#1},(Graph[#1,FilterRules[{options},Options[Graph]]]&)/@DeleteDuplicates[(HighlightGraph[renderPetriNetWeighted[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],First[ToExpression[stripMetadata[#1]]]],{Last[ToExpression[stripMetadata[#1]]]}]&)/@generation]]&)/@ResourceFunction["MultiwaySystem"][Association["StateEvolutionFunction"->(getPetriNetStateEvolutionFunction[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],#1]&),"StateEquivalenceFunction"->SameQ,"StateEventFunction"->(getPetriNetStateEventFunction[#1,constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]]]&),"EventDecompositionFunction"->getPetriNetEventDecompositionFunction,"EventApplicationFunction"->getPetriNetEventApplicationFunction,"SystemType"->"PetriNet","EventSelectionFunction"->getEventSelectionFunction[eventSelectionFunction]],{ToString[{initialConditions,Null}]},stepCount,"AllStatesList",options]/;SymbolName[petriNetObject]==="PetriNetObject"
MultiwayPetriNet[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List]->eventSelectionFunction_,stepCount_Integer,"Tokens",options:OptionsPattern[]]:=(Module[{generation=#1},DeleteDuplicates[(First[ToExpression[stripMetadata[#1]]]&)/@generation]]&)/@ResourceFunction["MultiwaySystem"][Association["StateEvolutionFunction"->(getPetriNetStateEvolutionFunction[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],#1]&),"StateEquivalenceFunction"->SameQ,"StateEventFunction"->(getPetriNetStateEventFunction[#1,constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]]]&),"EventDecompositionFunction"->getPetriNetEventDecompositionFunction,"EventApplicationFunction"->getPetriNetEventApplicationFunction,"SystemType"->"PetriNet","EventSelectionFunction"->getEventSelectionFunction[eventSelectionFunction]],{ToString[{initialConditions,Null}]},stepCount,"AllStatesList",options]/;SymbolName[petriNetObject]==="PetriNetObject"
MultiwayPetriNet[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List]->eventSelectionFunction_,stepCount_Integer,"TokenFirings",options:OptionsPattern[]]:=(Module[{generation=#1},DeleteDuplicates[(ToExpression[stripMetadata[#1]]&)/@generation]]&)/@ResourceFunction["MultiwaySystem"][Association["StateEvolutionFunction"->(getPetriNetStateEvolutionFunction[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],#1]&),"StateEquivalenceFunction"->SameQ,"StateEventFunction"->(getPetriNetStateEventFunction[#1,constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]]]&),"EventDecompositionFunction"->getPetriNetEventDecompositionFunction,"EventApplicationFunction"->getPetriNetEventApplicationFunction,"SystemType"->"PetriNet","EventSelectionFunction"->getEventSelectionFunction[eventSelectionFunction]],{ToString[{initialConditions,Null}]},stepCount,"AllStatesList",options]/;SymbolName[petriNetObject]==="PetriNetObject"
addLivenessTokens[vertex_,tokenCount_Integer,coordinateAssociation_Association]:=Text[Row[ConstantArray[Style["\[FilledCircle]",Purple],tokenCount]],coordinateAssociation[vertex]]
addLivenessTokensList[coordinateAssociation_Association,vertexWeightAssociation_Association,vertices_List]:=Module[{livenessTokensList},livenessTokensList={};Scan[AppendTo[livenessTokensList,addLivenessTokens[#1,vertexWeightAssociation[#1],coordinateAssociation]]&,vertices];livenessTokensList]
validDaedaelusProtocolQ[Association["AlicePlaces"->alicePlaces_List,"Arcs"->arcs_List,"BobPlaces"->bobPlaces_List,"ForwardArcs"->forwardArcs_List,"ForwardTransitions"->forwardTransitions_List,"ReverseArcs"->reverseArcs_List,"ReverseTransitions"->reverseTransitions_List,"Transitions"->transitions_List]]:=Module[{daedaelusProtocolGraph},daedaelusProtocolGraph=Graph[Apply[DirectedEdge,Join[arcs,forwardArcs,reverseArcs],{1}]];applyBooleanOperatorToList[And,{Join[alicePlaces,bobPlaces]\[Intersection]Join[transitions,forwardTransitions,reverseTransitions]=={},BipartiteGraphQ[daedaelusProtocolGraph]}]]
constructDaedaelusProtocolGraph[Association["AlicePlaces"->alicePlaces_List,"Arcs"->arcs_List,"BobPlaces"->bobPlaces_List,"ForwardArcs"->forwardArcs_List,"ForwardTransitions"->forwardTransitions_List,"ReverseArcs"->reverseArcs_List,"ReverseTransitions"->reverseTransitions_List,"Transitions"->transitions_List]]:=If[validDaedaelusProtocolQ[Association["AlicePlaces"->alicePlaces,"Arcs"->arcs,"BobPlaces"->bobPlaces,"ForwardArcs"->forwardArcs,"ForwardTransitions"->forwardTransitions,"ReverseArcs"->reverseArcs,"ReverseTransitions"->reverseTransitions,"Transitions"->transitions]],{Graph[Join[alicePlaces,bobPlaces,transitions,forwardTransitions,reverseTransitions],Apply[DirectedEdge,Join[arcs,forwardArcs,reverseArcs],{1}],VertexShapeFunction->Join[Thread[Join[alicePlaces,bobPlaces]->"Circle"],Thread[Join[transitions,forwardTransitions,reverseTransitions]->"Square"]],VertexStyle->Join[Thread[alicePlaces->Yellow],Thread[bobPlaces->Blue],Thread[transitions->Gray],Thread[forwardTransitions->Green],Thread[reverseTransitions->Red]],EdgeStyle->Join[Thread[Apply[DirectedEdge,arcs,{1}]->Directive[Black,Thick]],Thread[Apply[DirectedEdge,forwardArcs,{1}]->Directive[Green,Thick]],Thread[Apply[DirectedEdge,reverseArcs,{1}]->Directive[Red,Thick]]],VertexSize->Large,VertexLabels->"Name",VertexLabelStyle->Medium],alicePlaces,bobPlaces,transitions,forwardTransitions,reverseTransitions,Apply[DirectedEdge,arcs,{1}],Apply[DirectedEdge,forwardArcs,{1}],Apply[DirectedEdge,reverseArcs,{1}]},$Failed]
renderDaedaelusProtocolGraph[daedaelusProtocol_List,aliceTokens_List,bobTokens_List]:=Module[{daedaelusProtocolGraph,coordinateAssociation,vertexWeightAssociation,graphData,vertexWeight,graphEpilog},daedaelusProtocolGraph=Graph[First[daedaelusProtocol],VertexWeight->Join[Thread[daedaelusProtocol[[2]]->aliceTokens],Thread[daedaelusProtocol[[3]]->bobTokens],Thread[Join[daedaelusProtocol[[4]],daedaelusProtocol[[5]],daedaelusProtocol[[6]]]->0]]];graphData=ToExpression[StringReplace[ToString[FullForm[daedaelusProtocolGraph]],"Graph"->"List"]];vertexWeight=Last[Last[graphData[[3]]]];coordinateAssociation=Association[Thread[graphData[[1]]->VertexCoordinates/. AbsoluteOptions[daedaelusProtocolGraph,VertexCoordinates]]];vertexWeightAssociation=Association[Thread[graphData[[1]]->vertexWeight]];graphEpilog=addLivenessTokensList[coordinateAssociation,vertexWeightAssociation,graphData[[1]]];Graph[daedaelusProtocolGraph,Epilog->graphEpilog]]
renderDaedaelusProtocolGraphWeighted[daedaelusProtocol_List,aliceTokens_List,bobTokens_List]:=Graph[First[daedaelusProtocol],VertexWeight->Join[Thread[daedaelusProtocol[[2]]->aliceTokens],Thread[daedaelusProtocol[[3]]->bobTokens],Thread[Join[daedaelusProtocol[[4]],daedaelusProtocol[[5]],daedaelusProtocol[[6]]]->0]]]
MakeDaedaelusProtocol[associationForm_Association]:=DaedaelusProtocol[KeySort[associationForm],ConstantArray[0,Length[associationForm["AlicePlaces"]]],ConstantArray[0,Length[associationForm["BobPlaces"]]]]/;KeyExistsQ[associationForm,"AlicePlaces"]&&KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"BobPlaces"]&&KeyExistsQ[associationForm,"ForwardArcs"]&&KeyExistsQ[associationForm,"ForwardTransitions"]&&KeyExistsQ[associationForm,"ReverseArcs"]&&KeyExistsQ[associationForm,"ReverseTransitions"]&&KeyExistsQ[associationForm,"Transitions"]
MakeDaedaelusProtocol[associationForm_Association,aliceTokens_List,bobTokens_List]:=DaedaelusProtocol[KeySort[associationForm],aliceTokens,bobTokens]/;KeyExistsQ[associationForm,"AlicePlaces"]&&KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"BobPlaces"]&&KeyExistsQ[associationForm,"ForwardArcs"]&&KeyExistsQ[associationForm,"ForwardTransitions"]&&KeyExistsQ[associationForm,"ReverseArcs"]&&KeyExistsQ[associationForm,"ReverseTransitions"]&&KeyExistsQ[associationForm,"Transitions"]
MakeDaedaelusProtocol[alicePlaces_List,bobPlaces_List,transitions_List,forwardTransitions_List,reverseTransitions_List,arcs_List,forwardArcs_List,reverseArcs_List]:=DaedaelusProtocol[Association["AlicePlaces"->alicePlaces,"Arcs"->arcs,"BobPlaces"->bobPlaces,"ForwardArcs"->forwardArcs,"ForwardTransitions"->forwardTransitions,"ReverseArcs"->reverseArcs,"ReverseTransitions"->reverseTransitions,"Transitions"->transitions],ConstantArray[0,Length[alicePlaces]],ConstantArray[0,Length[bobPlaces]]]
MakeDaedaelusProtocol[alicePlaces_List,bobPlaces_List,transitions_List,forwardTransitions_List,reverseTransitions_List,arcs_List,forwardArcs_List,reverseArcs_List,aliceTokens_List,bobTokens_List]:=DaedaelusProtocol[Association["AlicePlaces"->alicePlaces,"Arcs"->arcs,"BobPlaces"->bobPlaces,"ForwardArcs"->forwardArcs,"ForwardTransitions"->forwardTransitions,"ReverseArcs"->reverseArcs,"ReverseTransitions"->reverseTransitions,"Transitions"->transitions],aliceTokens,bobTokens]/;Length[aliceTokens]==Length[alicePlaces]&&Length[bobTokens]==Length[bobPlaces]
DaedaelusProtocol[Association["AlicePlaces"->alicePlaces_List,"Arcs"->arcs_List,"BobPlaces"->bobPlaces_List,"ForwardArcs"->forwardArcs_List,"ForwardTransitions"->forwardTransitions_List,"ReverseArcs"->reverseArcs_List,"ReverseTransitions"->reverseTransitions_List,"Transitions"->transitions_List],aliceTokens_List,bobTokens_List]["AssociationForm"]:=Association["AlicePlaces"->alicePlaces,"BobPlaces"->bobPlaces,"Transitions"->transitions,"ForwardTransitions"->forwardTransitions,"ReverseTransitions"->reverseTransitions,"Arcs"->arcs,"ForwardArcs"->forwardArcs,"ReverseArcs"->reverseArcs]
DaedaelusProtocol[Association["AlicePlaces"->alicePlaces_List,"Arcs"->arcs_List,"BobPlaces"->bobPlaces_List,"ForwardArcs"->forwardArcs_List,"ForwardTransitions"->forwardTransitions_List,"ReverseArcs"->reverseArcs_List,"ReverseTransitions"->reverseTransitions_List,"Transitions"->transitions_List],aliceTokens_List,bobTokens_List]["UnlabeledGraph"]:=First[constructDaedaelusProtocolGraph[Association["AlicePlaces"->alicePlaces,"Arcs"->arcs,"BobPlaces"->bobPlaces,"ForwardArcs"->forwardArcs,"ForwardTransitions"->forwardTransitions,"ReverseArcs"->reverseArcs,"ReverseTransitions"->reverseTransitions,"Transitions"->transitions]]]
DaedaelusProtocol[Association["AlicePlaces"->alicePlaces_List,"Arcs"->arcs_List,"BobPlaces"->bobPlaces_List,"ForwardArcs"->forwardArcs_List,"ForwardTransitions"->forwardTransitions_List,"ReverseArcs"->reverseArcs_List,"ReverseTransitions"->reverseTransitions_List,"Transitions"->transitions_List],aliceTokens_List,bobTokens_List]["LabeledGraph"]:=renderDaedaelusProtocolGraph[constructDaedaelusProtocolGraph[Association["AlicePlaces"->alicePlaces,"Arcs"->arcs,"BobPlaces"->bobPlaces,"ForwardArcs"->forwardArcs,"ForwardTransitions"->forwardTransitions,"ReverseArcs"->reverseArcs,"ReverseTransitions"->reverseTransitions,"Transitions"->transitions]],aliceTokens,bobTokens]
DaedaelusProtocol[Association["AlicePlaces"->alicePlaces_List,"Arcs"->arcs_List,"BobPlaces"->bobPlaces_List,"ForwardArcs"->forwardArcs_List,"ForwardTransitions"->forwardTransitions_List,"ReverseArcs"->reverseArcs_List,"ReverseTransitions"->reverseTransitions_List,"Transitions"->transitions_List],aliceTokens_List,bobTokens_List]["WeightedGraph"]:=renderDaedaelusProtocolGraphWeighted[constructDaedaelusProtocolGraph[Association["AlicePlaces"->alicePlaces,"Arcs"->arcs,"BobPlaces"->bobPlaces,"ForwardArcs"->forwardArcs,"ForwardTransitions"->forwardTransitions,"ReverseArcs"->reverseArcs,"ReverseTransitions"->reverseTransitions,"Transitions"->transitions]],aliceTokens,bobTokens]
DaedaelusProtocol/:MakeBoxes[daedaelusProtocol:DaedaelusProtocol[Association["AlicePlaces"->alicePlaces_List,"Arcs"->arcs_List,"BobPlaces"->bobPlaces_List,"ForwardArcs"->forwardArcs_List,"ForwardTransitions"->forwardTransitions_List,"ReverseArcs"->reverseArcs_List,"ReverseTransitions"->reverseTransitions_List,"Transitions"->transitions_List],aliceTokens_List,bobTokens_List],format_]:=Module[{placeCount,transitionCount,arcCount,tokenCount},placeCount=ToString[Length[alicePlaces]]<>"+"<>ToString[Length[bobPlaces]];transitionCount=ToString[Length[transitions]]<>"+"<>ToString[Length[forwardTransitions]]<>"+"<>ToString[Length[reverseTransitions]];arcCount=ToString[Length[arcs]]<>"+"<>ToString[Length[forwardArcs]]<>"+"<>ToString[Length[reverseArcs]];tokenCount=ToString[Total[aliceTokens]]<>"+"<>ToString[Total[bobTokens]];BoxForm`ArrangeSummaryBox["DaedaelusProtocol",daedaelusProtocol,GraphPlot[First[constructDaedaelusProtocolGraph[Association["AlicePlaces"->alicePlaces,"Arcs"->arcs,"BobPlaces"->bobPlaces,"ForwardArcs"->forwardArcs,"ForwardTransitions"->forwardTransitions,"ReverseArcs"->reverseArcs,"ReverseTransitions"->reverseTransitions,"Transitions"->transitions]]],VertexLabels->None,EdgeShapeFunction->GraphElementData["ShortFilledArrow","ArrowSize"->0.05]],{{\!\(\*
TagBox["\"\<Places: \>\"",
"SummaryItemAnnotation"]\) \!\(\*
TagBox["placeCount",
"SummaryItem"]\),\!\(\*
TagBox["\"\<Transitions: \>\"",
"SummaryItemAnnotation"]\) \!\(\*
TagBox["transitionCount",
"SummaryItem"]\)},{\!\(\*
TagBox["\"\<Arcs: \>\"",
"SummaryItemAnnotation"]\) \!\(\*
TagBox["arcCount",
"SummaryItem"]\),\!\(\*
TagBox["\"\<Tokens: \>\"",
"SummaryItemAnnotation"]\) \!\(\*
TagBox["tokenCount",
"SummaryItem"]\)}},{{}},format,"Interpretable"->Automatic]]
transitionFiringQ[daedaelusProtocol_List,transition_,currentTokens_List]:=Module[{tokenCount},tokenCount=(Length[EdgeList[First[daedaelusProtocol],#1\[DirectedEdge]transition]]&)/@Join[daedaelusProtocol[[2]],daedaelusProtocol[[3]]];AllTrue[currentTokens-tokenCount,NonNegative]]
applyTransitionFiring[daedaelusProtocol_List,transition_,currentTokens_List]:=Module[{deletedTokensCount,addedTokensCount},deletedTokensCount=(Length[EdgeList[First[daedaelusProtocol],#1\[DirectedEdge]transition]]&)/@Join[daedaelusProtocol[[2]],daedaelusProtocol[[3]]];addedTokensCount=(Length[EdgeList[First[daedaelusProtocol],transition\[DirectedEdge]#1]]&)/@Join[daedaelusProtocol[[2]],daedaelusProtocol[[3]]];currentTokens-deletedTokensCount+addedTokensCount]
updateTransitionFiringMultiway[daedaelusProtocol_List][currentTokens_List]:=Module[{transitionIndices,validTransitionIndices},transitionIndices=First/@Position[(transitionFiringQ[daedaelusProtocol,#1,currentTokens]&)/@Join[daedaelusProtocol[[4]],daedaelusProtocol[[5]],daedaelusProtocol[[6]]],True];validTransitionIndices=Select[transitionIndices,IntegerQ];(applyTransitionFiring[daedaelusProtocol,Join[daedaelusProtocol[[4]],daedaelusProtocol[[5]],daedaelusProtocol[[6]]][[#1]],currentTokens]&)/@validTransitionIndices]
daedaelusMultiwayEvolution[daedaelusProtocol_List,aliceTokens_List,bobTokens_List]:=Module[{currentTokens,transitionIndices,validTransitionIndices},currentTokens=Join[aliceTokens,bobTokens];currentTokens=updateTransitionFiringMultiway[daedaelusProtocol][currentTokens];transitionIndices=Catenate[(Module[{tokens=#1},First/@Position[(transitionFiringQ[daedaelusProtocol,#1,tokens]&)/@Join[daedaelusProtocol[[4]],daedaelusProtocol[[5]],daedaelusProtocol[[6]]],True]]&)/@currentTokens];validTransitionIndices=Select[transitionIndices,IntegerQ];(Module[{tokens=#1},(applyTransitionFiring[daedaelusProtocol,Join[daedaelusProtocol[[4]],daedaelusProtocol[[5]],daedaelusProtocol[[6]]][[#1]],tokens]&)/@validTransitionIndices]&)/@currentTokens;DeleteDuplicates[Catenate[(Module[{tokens=#1},({Take[tokens,Length[daedaelusProtocol[[2]]]],Take[tokens,-Length[daedaelusProtocol[[3]]]],Join[daedaelusProtocol[[4]],daedaelusProtocol[[5]],daedaelusProtocol[[6]]][[#1]]}&)/@validTransitionIndices]&)/@currentTokens]]]
getDaedaelusStateEvolutionFunction[daedaelusProtocol_List,initialConditions_String]:=ToString/@daedaelusMultiwayEvolution[daedaelusProtocol,ToExpression[initialConditions][[1]],ToExpression[initialConditions][[2]]]
getDaedaelusStateRenderingFunction[daedaelusProtocol_List]:=Inset[Framed[Style[GraphPlot[If[Last[ToExpression[#2]]===Null,renderDaedaelusProtocolGraph[daedaelusProtocol,ToExpression[#2][[1]],ToExpression[#2][[2]]],HighlightGraph[renderDaedaelusProtocolGraph[daedaelusProtocol,ToExpression[#2][[1]],ToExpression[#2][[2]]],{ToExpression[#2][[3]],ToString[ToExpression[#2][[3]]]}]],VertexLabels->None,EdgeShapeFunction->GraphElementData["ShortFilledArrow","ArrowSize"->0.05]],Hue[0.62,1,0.48]],Background->Directive[Opacity[0.2],Hue[0.62,0.45,0.87]],RoundingRadius->0,FrameStyle->Directive[Opacity[0.5],Hue[0.62,0.52,0.82]]],#1,{0,0},#3]&
SimulateDaedaelusProtocol[daedaelusProtocol_[Association["AlicePlaces"->alicePlaces_List,"Arcs"->arcs_List,"BobPlaces"->bobPlaces_List,"ForwardArcs"->forwardArcs_List,"ForwardTransitions"->forwardTransitions_List,"ReverseArcs"->reverseArcs_List,"ReverseTransitions"->reverseTransitions_List,"Transitions"->transitions_List],aliceTokens_List,bobTokens_List],stepCount_Integer]:=ResourceFunction["MultiwaySystem"][Association["StateEvolutionFunction"->(getDaedaelusStateEvolutionFunction[constructDaedaelusProtocolGraph[Association["AlicePlaces"->alicePlaces,"Arcs"->arcs,"BobPlaces"->bobPlaces,"ForwardArcs"->forwardArcs,"ForwardTransitions"->forwardTransitions,"ReverseArcs"->reverseArcs,"ReverseTransitions"->reverseTransitions,"Transitions"->transitions]],#1]&),"StateEquivalenceFunction"->SameQ,"StateEventFunction"->Identity,"EventDecompositionFunction"->Identity,"EventApplicationFunction"->Identity,"SystemType"->"PetriNet","EventSelectionFunction"->Identity],{ToString[{aliceTokens,bobTokens,Null}]},stepCount,"StatesGraph","StateRenderingFunction"->getDaedaelusStateRenderingFunction[constructDaedaelusProtocolGraph[Association["AlicePlaces"->alicePlaces,"Arcs"->arcs,"BobPlaces"->bobPlaces,"ForwardArcs"->forwardArcs,"ForwardTransitions"->forwardTransitions,"ReverseArcs"->reverseArcs,"ReverseTransitions"->reverseTransitions,"Transitions"->transitions]]],VertexSize->1]/;SymbolName[daedaelusProtocol]==="DaedaelusProtocol"
SimulateDaedaelusProtocolEntanglement[daedaelusProtocol_[Association["AlicePlaces"->alicePlaces_List,"Arcs"->arcs_List,"BobPlaces"->bobPlaces_List,"ForwardArcs"->forwardArcs_List,"ForwardTransitions"->forwardTransitions_List,"ReverseArcs"->reverseArcs_List,"ReverseTransitions"->reverseTransitions_List,"Transitions"->transitions_List],aliceTokens_List,bobTokens_List],stepCount_Integer]:=ResourceFunction["MultiwaySystem"][Association["StateEvolutionFunction"->(getDaedaelusStateEvolutionFunction[constructDaedaelusProtocolGraph[Association["AlicePlaces"->alicePlaces,"Arcs"->arcs,"BobPlaces"->bobPlaces,"ForwardArcs"->forwardArcs,"ForwardTransitions"->forwardTransitions,"ReverseArcs"->reverseArcs,"ReverseTransitions"->reverseTransitions,"Transitions"->transitions]],#1]&),"StateEquivalenceFunction"->SameQ,"StateEventFunction"->Identity,"EventDecompositionFunction"->Identity,"EventApplicationFunction"->Identity,"SystemType"->"PetriNet","EventSelectionFunction"->Identity],{ToString[{aliceTokens,bobTokens,Null}]},stepCount,"BranchialGraph","StateRenderingFunction"->getDaedaelusStateRenderingFunction[constructDaedaelusProtocolGraph[Association["AlicePlaces"->alicePlaces,"Arcs"->arcs,"BobPlaces"->bobPlaces,"ForwardArcs"->forwardArcs,"ForwardTransitions"->forwardTransitions,"ReverseArcs"->reverseArcs,"ReverseTransitions"->reverseTransitions,"Transitions"->transitions]]],VertexSize->1]/;SymbolName[daedaelusProtocol]==="DaedaelusProtocol"
Options[PetriNetNondeterministicEvolution]=Options[Graph];
petriNetNondeterministicEvolution[petriNet_List,initialConditions_List]:=Module[{currentTokens,transitionIndices,validTransitionIndices,currentToken},currentTokens=initialConditions;currentTokens=updateTransitionFiringMultiway[petriNet][currentTokens];transitionIndices=Catenate[(Module[{tokens=#1},First/@Position[(transitionFiringQ[petriNet,#1,tokens]&)/@petriNet[[3]],True]]&)/@currentTokens];validTransitionIndices=Select[transitionIndices,IntegerQ];(Module[{tokens=#1},(applyTransitionFiring[petriNet,petriNet[[3,#1]],tokens]&)/@validTransitionIndices]&)/@currentTokens;If[Length[currentTokens]>0,currentToken=RandomChoice[currentTokens];{makePetriNet[petriNet[[2]],petriNet[[3]],petriNet[[4]],currentToken],{petriNet,currentToken}},{makePetriNet[petriNet[[2]],petriNet[[3]],petriNet[[4]],initialConditions],{petriNet,initialConditions}}]]
petriNetNondeterministicEvolution[nondeterministicStates_List]:=Module[{nondeterministicEvolution},nondeterministicEvolution=petriNetNondeterministicEvolution[First[Last[nondeterministicStates]],Last[Last[nondeterministicStates]]];{First[nondeterministicEvolution],{First[Last[nondeterministicStates]],Last[Last[nondeterministicEvolution]]}}]
petriNetNondeterministicEvolutionLabeledGraphs[petriNet_List,initialConditions_List]:=Module[{currentTokens,transitionIndices,validTransitionIndices,currentToken},currentTokens=initialConditions;currentTokens=updateTransitionFiringMultiway[petriNet][currentTokens];transitionIndices=Catenate[(Module[{tokens=#1},First/@Position[(transitionFiringQ[petriNet,#1,tokens]&)/@petriNet[[3]],True]]&)/@currentTokens];validTransitionIndices=Select[transitionIndices,IntegerQ];(Module[{tokens=#1},(applyTransitionFiring[petriNet,petriNet[[3,#1]],tokens]&)/@validTransitionIndices]&)/@currentTokens;If[Length[currentTokens]>0,currentToken=RandomChoice[currentTokens];{renderPetriNet[petriNet,currentToken],{petriNet,currentToken}},{renderPetriNet[petriNet,initialConditions],{petriNet,initialConditions}}]]
petriNetNondeterministicEvolutionLabeledGraphs[nondeterministicStates_List]:=Module[{nondeterministicEvolution},nondeterministicEvolution=petriNetNondeterministicEvolutionLabeledGraphs[First[Last[nondeterministicStates]],Last[Last[nondeterministicStates]]];{First[nondeterministicEvolution],{First[Last[nondeterministicStates]],Last[Last[nondeterministicEvolution]]}}]
petriNetNondeterministicEvolutionLabeledGraphsHighlighted[petriNet_List,initialConditions_List]:=Module[{currentTokens,transitionIndices,validTransitionIndices,currentToken,validTransitionIndex,petriNetGraph},currentTokens=initialConditions;currentTokens=updateTransitionFiringMultiway[petriNet][currentTokens];transitionIndices=Catenate[(Module[{tokens=#1},First/@Position[(transitionFiringQ[petriNet,#1,tokens]&)/@petriNet[[3]],True]]&)/@currentTokens];validTransitionIndices=Select[transitionIndices,IntegerQ];(Module[{tokens=#1},(applyTransitionFiring[petriNet,petriNet[[3,#1]],tokens]&)/@validTransitionIndices]&)/@currentTokens;If[Length[currentTokens]>0&&Length[validTransitionIndices]>0,currentToken=RandomChoice[currentTokens];validTransitionIndex=RandomChoice[validTransitionIndices];petriNetGraph=renderPetriNet[petriNet,currentToken];{HighlightGraph[petriNetGraph,{petriNet[[3,validTransitionIndex]]}],{petriNet,currentToken}},{renderPetriNet[petriNet,initialConditions],{petriNet,initialConditions}}]]
petriNetNondeterministicEvolutionLabeledGraphsHighlighted[nondeterministicStates_List]:=Module[{nondeterministicEvolution},nondeterministicEvolution=petriNetNondeterministicEvolutionLabeledGraphsHighlighted[First[Last[nondeterministicStates]],Last[Last[nondeterministicStates]]];{First[nondeterministicEvolution],{First[Last[nondeterministicStates]],Last[Last[nondeterministicEvolution]]}}]
petriNetNondeterministicEvolutionWeightedGraphs[petriNet_List,initialConditions_List]:=Module[{currentTokens,transitionIndices,validTransitionIndices,currentToken},currentTokens=initialConditions;currentTokens=updateTransitionFiringMultiway[petriNet][currentTokens];transitionIndices=Catenate[(Module[{tokens=#1},First/@Position[(transitionFiringQ[petriNet,#1,tokens]&)/@petriNet[[3]],True]]&)/@currentTokens];validTransitionIndices=Select[transitionIndices,IntegerQ];(Module[{tokens=#1},(applyTransitionFiring[petriNet,petriNet[[3,#1]],tokens]&)/@validTransitionIndices]&)/@currentTokens;If[Length[currentTokens]>0,currentToken=RandomChoice[currentTokens];{renderPetriNetWeighted[petriNet,currentToken],{petriNet,currentToken}},{renderPetriNetWeighted[petriNet,initialConditions],{petriNet,initialConditions}}]]
petriNetNondeterministicEvolutionWeightedGraphs[nondeterministicStates_List]:=Module[{nondeterministicEvolution},nondeterministicEvolution=petriNetNondeterministicEvolutionWeightedGraphs[First[Last[nondeterministicStates]],Last[Last[nondeterministicStates]]];{First[nondeterministicEvolution],{First[Last[nondeterministicStates]],Last[Last[nondeterministicEvolution]]}}]
petriNetNondeterministicEvolutionWeightedGraphsHighlighted[petriNet_List,initialConditions_List]:=Module[{currentTokens,transitionIndices,validTransitionIndices,currentToken,validTransitionIndex,petriNetGraphWeighted},currentTokens=initialConditions;currentTokens=updateTransitionFiringMultiway[petriNet][currentTokens];transitionIndices=Catenate[(Module[{tokens=#1},First/@Position[(transitionFiringQ[petriNet,#1,tokens]&)/@petriNet[[3]],True]]&)/@currentTokens];validTransitionIndices=Select[transitionIndices,IntegerQ];(Module[{tokens=#1},(applyTransitionFiring[petriNet,petriNet[[3,#1]],tokens]&)/@validTransitionIndices]&)/@currentTokens;If[Length[currentTokens]>0&&Length[validTransitionIndices]>0,currentToken=RandomChoice[currentTokens];validTransitionIndex=RandomChoice[validTransitionIndices];petriNetGraphWeighted=renderPetriNetWeighted[petriNet,currentToken];{HighlightGraph[petriNetGraphWeighted,{petriNet[[3,validTransitionIndex]]}],{petriNet,currentToken}},{renderPetriNetWeighted[petriNet,initialConditions],{petriNet,initialConditions}}]]
petriNetNondeterministicEvolutionWeightedGraphsHighlighted[nondeterministicStates_List]:=Module[{nondeterministicEvolution},nondeterministicEvolution=petriNetNondeterministicEvolutionWeightedGraphsHighlighted[First[Last[nondeterministicStates]],Last[Last[nondeterministicStates]]];{First[nondeterministicEvolution],{First[Last[nondeterministicStates]],Last[Last[nondeterministicEvolution]]}}]
petriNetNondeterministicEvolutionTokens[petriNet_List,initialConditions_List]:=Module[{currentTokens,transitionIndices,validTransitionIndices,currentToken},currentTokens=initialConditions;currentTokens=updateTransitionFiringMultiway[petriNet][currentTokens];transitionIndices=Catenate[(Module[{tokens=#1},First/@Position[(transitionFiringQ[petriNet,#1,tokens]&)/@petriNet[[3]],True]]&)/@currentTokens];validTransitionIndices=Select[transitionIndices,IntegerQ];(Module[{tokens=#1},(applyTransitionFiring[petriNet,petriNet[[3,#1]],tokens]&)/@validTransitionIndices]&)/@currentTokens;If[Length[currentTokens]>0,currentToken=RandomChoice[currentTokens];{currentToken,{petriNet,currentToken}},{initialConditions,{petriNet,initialConditions}}]]
petriNetNondeterministicEvolutionTokens[nondeterministicStates_List]:=Module[{nondeterministicEvolution},nondeterministicEvolution=petriNetNondeterministicEvolutionTokens[First[Last[nondeterministicStates]],Last[Last[nondeterministicStates]]];{First[nondeterministicEvolution],{First[Last[nondeterministicStates]],Last[Last[nondeterministicEvolution]]}}]
petriNetNondeterministicEvolutionTokenFirings[petriNet_List,initialConditions_List]:=Module[{currentTokens,transitionIndices,validTransitionIndices,currentToken,validTransitionIndex},currentTokens=initialConditions;currentTokens=updateTransitionFiringMultiway[petriNet][currentTokens];transitionIndices=Catenate[(Module[{tokens=#1},First/@Position[(transitionFiringQ[petriNet,#1,tokens]&)/@petriNet[[3]],True]]&)/@currentTokens];validTransitionIndices=Select[transitionIndices,IntegerQ];(Module[{tokens=#1},(applyTransitionFiring[petriNet,petriNet[[3,#1]],tokens]&)/@validTransitionIndices]&)/@currentTokens;If[Length[currentTokens]>0&&Length[validTransitionIndices]>0,currentToken=RandomChoice[currentTokens];validTransitionIndex=RandomChoice[validTransitionIndices];{{currentToken,petriNet[[3,validTransitionIndex]]},{petriNet,currentToken}},{{initialConditions,Null},{petriNet,initialConditions}}]]
petriNetNondeterministicEvolutionTokenFirings[nondeterministicStates_List]:=Module[{nondeterministicEvolution},nondeterministicEvolution=petriNetNondeterministicEvolutionTokenFirings[First[Last[nondeterministicStates]],Last[Last[nondeterministicStates]]];{First[nondeterministicEvolution],{First[Last[nondeterministicStates]],Last[Last[nondeterministicEvolution]]}}]
PetriNetNondeterministicEvolution[associationForm_Association,options:OptionsPattern[]]:=PetriNetNondeterministicEvolution[makePetriNet[associationForm],"PetriNetObjects",options]/;KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"Places"]&&KeyExistsQ[associationForm,"Transitions"]
PetriNetNondeterministicEvolution[associationForm_Association,initialConditions_List,options:OptionsPattern[]]:=PetriNetNondeterministicEvolution[makePetriNet[associationForm,initialConditions],"PetriNetObjects",options]/;KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"Places"]&&KeyExistsQ[associationForm,"Transitions"]&&Length[initialConditions]==Length[associationForm["Places"]]
PetriNetNondeterministicEvolution[associationForm_Association,stepCount_Integer,options:OptionsPattern[]]:=PetriNetNondeterministicEvolution[makePetriNet[associationForm],stepCount,"PetriNetObjects",options]/;KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"Places"]&&KeyExistsQ[associationForm,"Transitions"]
PetriNetNondeterministicEvolution[associationForm_Association,initialConditions_List,stepCount_Integer,options:OptionsPattern[]]:=PetriNetNondeterministicEvolution[makePetriNet[associationForm,initialConditions],stepCount,"PetriNetObjects",options]/;KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"Places"]&&KeyExistsQ[associationForm,"Transitions"]&&Length[initialConditions]==Length[associationForm["Places"]]
PetriNetNondeterministicEvolution[associationForm_Association,property_String,options:OptionsPattern[]]:=PetriNetNondeterministicEvolution[makePetriNet[associationForm],property,options]/;KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"Places"]&&KeyExistsQ[associationForm,"Transitions"]
PetriNetNondeterministicEvolution[associationForm_Association,initialConditions_List,property_String,options:OptionsPattern[]]:=PetriNetNondeterministicEvolution[makePetriNet[associationForm,initialConditions],property,options]/;KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"Places"]&&KeyExistsQ[associationForm,"Transitions"]&&Length[initialConditions]==Length[associationForm["Places"]]
PetriNetNondeterministicEvolution[associationForm_Association,stepCount_Integer,property_String,options:OptionsPattern[]]:=PetriNetNondeterministicEvolution[makePetriNet[associationForm],stepCount,property,options]/;KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"Places"]&&KeyExistsQ[associationForm,"Transitions"]
PetriNetNondeterministicEvolution[associationForm_Association,initialConditions_List,stepCount_Integer,property_String,options:OptionsPattern[]]:=PetriNetNondeterministicEvolution[makePetriNet[associationForm,initialConditions],stepCount,property,options]/;KeyExistsQ[associationForm,"Arcs"]&&KeyExistsQ[associationForm,"Places"]&&KeyExistsQ[associationForm,"Transitions"]&&Length[initialConditions]==Length[associationForm["Places"]]
PetriNetNondeterministicEvolution[places_List,transitions_List,arcs_List,options:OptionsPattern[]]:=PetriNetNondeterministicEvolution[makePetriNet[places,transitions,arcs],"PetriNetObjects",options]
PetriNetNondeterministicEvolution[places_List,transitions_List,arcs_List,initialConditions_List,options:OptionsPattern[]]:=PetriNetNondeterministicEvolution[makePetriNet[places,transitions,arcs,initialConditions],"PetriNetObjects",options]/;Length[initialConditions]==Length[places]
PetriNetNondeterministicEvolution[places_List,transitions_List,arcs_List,stepCount_Integer,options:OptionsPattern[]]:=PetriNetNondeterministicEvolution[makePetriNet[places,transitions,arcs],stepCount,"PetriNetObjects",options]
PetriNetNondeterministicEvolution[places_List,transitions_List,arcs_List,initialConditions_List,stepCount_Integer,options:OptionsPattern[]]:=PetriNetNondeterministicEvolution[makePetriNet[places,transitions,arcs,initialConditions],stepCount,"PetriNetObjects",options]/;Length[initialConditions]==Length[places]
PetriNetNondeterministicEvolution[places_List,transitions_List,arcs_List,property_String,options:OptionsPattern[]]:=PetriNetNondeterministicEvolution[makePetriNet[places,transitions,arcs],property,options]
PetriNetNondeterministicEvolution[places_List,transitions_List,arcs_List,initialConditions_List,property_String,options:OptionsPattern[]]:=PetriNetNondeterministicEvolution[makePetriNet[places,transitions,arcs,initialConditions],property,options]/;Length[initialConditions]==Length[places]
PetriNetNondeterministicEvolution[places_List,transitions_List,arcs_List,stepCount_Integer,property_String,options:OptionsPattern[]]:=PetriNetNondeterministicEvolution[makePetriNet[places,transitions,arcs],stepCount,property,options]
PetriNetNondeterministicEvolution[places_List,transitions_List,arcs_List,initialConditions_List,stepCount_Integer,property_String,options:OptionsPattern[]]:=PetriNetNondeterministicEvolution[makePetriNet[places,transitions,arcs,initialConditions],stepCount,property,options]/;Length[initialConditions]==Length[places]
PetriNetNondeterministicEvolution[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List],options:OptionsPattern[]]:=PetriNetNondeterministicEvolution[PetriNetObject[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions],initialConditions],"PetriNetObjects",options]/;SymbolName[petriNetObject]==="PetriNetObject"
PetriNetNondeterministicEvolution[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List],stepCount_Integer,options:OptionsPattern[]]:=PetriNetNondeterministicEvolution[PetriNetObject[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions],initialConditions],stepCount,"PetriNetObjects",options]/;SymbolName[petriNetObject]==="PetriNetObject"
PetriNetNondeterministicEvolution[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List],"PetriNetObjects",options:OptionsPattern[]]:=First[petriNetNondeterministicEvolution[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],initialConditions]]/;SymbolName[petriNetObject]==="PetriNetObject"
PetriNetNondeterministicEvolution[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List],stepCount_Integer,"PetriNetObjects",options:OptionsPattern[]]:=First/@NestList[petriNetNondeterministicEvolution,{PetriNetObject[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions],initialConditions],{constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],initialConditions}},stepCount]/;SymbolName[petriNetObject]==="PetriNetObject"
PetriNetNondeterministicEvolution[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List],"LabeledGraphs",options:OptionsPattern[]]:=Graph[First[petriNetNondeterministicEvolutionLabeledGraphs[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],initialConditions]],options]/;SymbolName[petriNetObject]==="PetriNetObject"
PetriNetNondeterministicEvolution[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List],stepCount_Integer,"LabeledGraphs",options:OptionsPattern[]]:=(Graph[#1,options]&)/@First/@NestList[petriNetNondeterministicEvolutionLabeledGraphs,{renderPetriNet[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],initialConditions],{constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],initialConditions}},stepCount]/;SymbolName[petriNetObject]==="PetriNetObject"
PetriNetNondeterministicEvolution[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List],"LabeledGraphsHighlighted",options:OptionsPattern[]]:=Graph[First[petriNetNondeterministicEvolutionLabeledGraphsHighlighted[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],initialConditions]],options]/;SymbolName[petriNetObject]==="PetriNetObject"
PetriNetNondeterministicEvolution[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List],stepCount_Integer,"LabeledGraphsHighlighted",options:OptionsPattern[]]:=(Graph[#1,options]&)/@First/@NestList[petriNetNondeterministicEvolutionLabeledGraphsHighlighted,{renderPetriNet[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],initialConditions],{constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],initialConditions}},stepCount]/;SymbolName[petriNetObject]==="PetriNetObject"
PetriNetNondeterministicEvolution[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List],"WeightedGraphs",options:OptionsPattern[]]:=Graph[First[petriNetNondeterministicEvolutionWeightedGraphs[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],initialConditions]],options]/;SymbolName[petriNetObject]==="PetriNetObject"
PetriNetNondeterministicEvolution[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List],stepCount_Integer,"WeightedGraphs",options:OptionsPattern[]]:=(Graph[#1,options]&)/@First/@NestList[petriNetNondeterministicEvolutionWeightedGraphs,{renderPetriNetWeighted[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],initialConditions],{constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],initialConditions}},stepCount]/;SymbolName[petriNetObject]==="PetriNetObject"
PetriNetNondeterministicEvolution[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List],"WeightedGraphsHighlighted",options:OptionsPattern[]]:=Graph[First[petriNetNondeterministicEvolutionWeightedGraphsHighlighted[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],initialConditions]],options]/;SymbolName[petriNetObject]==="PetriNetObject"
PetriNetNondeterministicEvolution[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List],stepCount_Integer,"WeightedGraphsHighlighted",options:OptionsPattern[]]:=(Graph[#1,options]&)/@First/@NestList[petriNetNondeterministicEvolutionWeightedGraphsHighlighted,{renderPetriNetWeighted[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],initialConditions],{constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],initialConditions}},stepCount]/;SymbolName[petriNetObject]==="PetriNetObject"
PetriNetNondeterministicEvolution[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List],"Tokens",options:OptionsPattern[]]:=First[petriNetNondeterministicEvolutionTokens[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],initialConditions]]/;SymbolName[petriNetObject]==="PetriNetObject"
PetriNetNondeterministicEvolution[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List],stepCount_Integer,"Tokens",options:OptionsPattern[]]:=First/@NestList[petriNetNondeterministicEvolutionTokens,{initialConditions,{constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],initialConditions}},stepCount]/;SymbolName[petriNetObject]==="PetriNetObject"
PetriNetNondeterministicEvolution[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List],"TokenFirings",options:OptionsPattern[]]:=First[petriNetNondeterministicEvolutionTokenFirings[constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],initialConditions]]/;SymbolName[petriNetObject]==="PetriNetObject"
PetriNetNondeterministicEvolution[petriNetObject_[Association["Arcs"->arcs_List,"Places"->places_List,"Transitions"->transitions_List],initialConditions_List],stepCount_Integer,"TokenFirings",options:OptionsPattern[]]:=First/@NestList[petriNetNondeterministicEvolutionTokenFirings,{{initialConditions,Null},{constructPetriNet[Association["Arcs"->arcs,"Places"->places,"Transitions"->transitions]],initialConditions}},stepCount]/;SymbolName[petriNetObject]==="PetriNetObject"


reversibleProtocol=MakeDaedaelusProtocol[Association["AlicePlaces"->{"alice_state_0","alice_state_1"},"BobPlaces"->{"bob_state_0","bob_state_1"},"Transitions"->{},"ForwardTransitions"->{"forward_evolution"},"ReverseTransitions"->{"reverse_evolution"},"Arcs"->{},"ForwardArcs"->{"alice_state_0"->"forward_evolution","forward_evolution"->"bob_state_1"},"ReverseArcs"->{"bob_state_1"->"reverse_evolution","reverse_evolution"->"alice_state_0"}],{1,0},{0,0}];
SimulateDaedaelusProtocol[reversibleProtocol,3]


twoPhaseCommitProtocol=MakeDaedaelusProtocol[Association["AlicePlaces"->{"A_Idle","A_PrepareSent","A_Committed","A_Aborted"},"BobPlaces"->{"B_Waiting","B_Prepared","B_Committed","B_Aborted"},"Transitions"->{},"ForwardTransitions"->{"SendPrepare","SendCommit"},"ReverseTransitions"->{"SendAbort"},"Arcs"->{"A_PrepareSent"->"SendCommit"->"A_Committed","B_Prepared"->"SendCommit","SendCommit"->"B_Committed","A_PrepareSent"->"SendAbort"->"A_Aborted","B_Prepared"->"SendAbort","SendAbort"->"B_Aborted"},"ForwardArcs"->{"A_Idle"->"SendPrepare"->"A_PrepareSent","B_Waiting"->"SendPrepare","SendPrepare"->"B_Prepared"},"ReverseArcs"->{}],{1,0,0,0},{1,0,0,0}];
SimulateDaedaelusProtocol[twoPhaseCommitProtocol,3]


twoBitAlternatingProtocol=MakeDaedaelusProtocol[Association["AlicePlaces"->{"A_state0","A_state2"},"BobPlaces"->{"B_state1","B_state3"},"Transitions"->{},"ForwardTransitions"->{"T_A_to_B_1","T_B_to_A_2","T_A_to_B_3","T_B_to_A_4"},"ReverseTransitions"->{},"Arcs"->{"A_state0"->"T_A_to_B_1"->"B_state1","B_state1"->"T_B_to_A_2"->"A_state2","A_state2"->"T_A_to_B_3"->"B_state3","B_state3"->"T_B_to_A_4"->"A_state0"},"ForwardArcs"->{},"ReverseArcs"->{}],{1,0},{0,0}];
SimulateDaedaelusProtocol[twoBitAlternatingProtocol,4]


places={"p1","p2","p3"};
transitions={"t1","t2"};
arcs={{"p1","t1"},{"t1","p2"},{"p2","t2"},{"t2","p3"}};
initialTokens=Association["p1"->1,"p2"->0,"p3"->0];
vertices=Join[places,transitions];
edges=DirectedEdge@@@arcs;
vertexStyles=Join[Thread[places->Lighter[Green,0.3]],Thread[transitions->Lighter[Orange,0.3]]];
vertexShapes=Join[Thread[places->"Circle"],Thread[transitions->"Square"]];
vertexSizes=Thread[vertices->0.4];
petriNetGraph=Graph[vertices,edges,VertexStyle->vertexStyles,VertexShapeFunction->vertexShapes,VertexSize->vertexSizes,EdgeStyle->Directive[Thick,Darker[Gray,0.3]],VertexLabels->Placed["Name",Center],Background->Lighter[Gray,0.9],ImageSize->Medium];
petriNetGraph
drawPetriNetWithTokens[marking_Association]:=Module[{g,coords,tokenGraphics},g=Graph[vertices,edges,VertexStyle->vertexStyles,VertexShapeFunction->vertexShapes,VertexSize->vertexSizes,EdgeStyle->Directive[Thick,Darker[Gray,0.3]],VertexLabels->Placed["Name",Center],Background->Lighter[Gray,0.97],ImageSize->Medium,GraphLayout->"SpringElectricalEmbedding"];coords=AssociationThread[VertexList[g],GraphEmbedding[g]];tokenGraphics=Flatten[Table[With[{n=marking[p],pos=coords[p]},Table[{Black,Disk[pos,0.07-0.025 i]},{i,0,n-1}]],{p,places}]];Show[g,Epilog->tokenGraphics]]
drawPetriNetWithTokens[initialTokens]
fireTransitions[marking_]:=Module[{nextStates={}},If[marking["p1"]>=1,AppendTo[nextStates,Association["p1"->marking["p1"]-1,"p2"->marking["p2"]+1,"p3"->marking["p3"]]]];If[marking["p2"]>=1,AppendTo[nextStates,Association["p1"->marking["p1"],"p2"->marking["p2"]-1,"p3"->marking["p3"]+1]]];nextStates]
generateBranchialGraph[init_,maxSteps_:4]:=Module[{states=Association[],edges={},queue,nodeKey,children,seen=Association[]},nodeKey[state_]:=ToString[Normal[state]];states[nodeKey[init]]=init;queue={{init,0}};seen[nodeKey[init]]=True;While[queue=!={},{state,depth}=First[queue];queue=Rest[queue];If[depth>=maxSteps,Continue[]];children=fireTransitions[state];Do[k=nodeKey[child];If[!KeyExistsQ[seen,k],states[k]=child;seen[k]=True;AppendTo[queue,{child,depth+1}]];AppendTo[edges,nodeKey[state]->k],{child,children}];];Graph[Keys[states],edges,VertexLabels->v_:>Placed[Style[v,Small],Center],VertexStyle->LightBlue,EdgeStyle->Thin,GraphLayout->"RadialEmbedding",VertexSize->0.3,ImageSize->Large]]
generateBranchialGraph[initialTokens,4]
highlightFiring[marking_]:=drawPetriNetWithTokens[marking];
stateSeq=FoldList[Function[{s,tr},Which[tr==="t1"&&s["p1"]>=1,Association["p1"->s["p1"]-1,"p2"->s["p2"]+1,"p3"->s["p3"]],tr==="t2"&&s["p2"]>=1,Association["p1"->s["p1"],"p2"->s["p2"]-1,"p3"->s["p3"]+1],True,s]],initialTokens,{"t1","t2","t2"}];
Row[(highlightFiring[#1]&)/@stateSeq,Spacer[10]]


places={"A","B"};
transitions={"t"};
arcs={{"A","t"},{"t","B"}};
initialMarking=Association["A"->3,"B"->0];
steps=6;
vertexLabelFunc[marking_]:=Function[v,If[KeyExistsQ[marking,v],Placed[Row[{v,":",marking[v]}],Center],Placed[v,Center]]];
vertexStyleFunc=Function[v,If[MemberQ[places,v],LightBlue,LightGray]];
vertexShapeFunc=Function[v,If[MemberQ[transitions,v],"Rectangle","Circle"]];
drawNet[marking_Association]:=Module[{verts=Join[places,transitions],edges},edges=DirectedEdge@@@arcs;Graph[verts,edges,VertexLabels->(#1->vertexLabelFunc[marking][#1]&)/@verts,VertexStyle->(#1->vertexStyleFunc[#1]&)/@verts,VertexShapeFunction->(#1->vertexShapeFunc[#1]&)/@verts,VertexSize->Medium,GraphLayout->"SpringElectricalEmbedding",ImageSize->300]];
fireTransition[marking_Association,t_String]:=Module[{m=Association[marking],pre,post},pre=Select[arcs,#1[[2]]==t&][[All,1]];post=Select[arcs,#1[[1]]==t&][[All,2]];If[AllTrue[pre,m[#1]>0&],(m[#1]--&)/@pre;(m[#1]++&)/@post;m,marking]];
frames=Module[{current=initialMarking,hist={}},AppendTo[hist,drawNet[current]];Do[current=fireTransition[current,"t"];AppendTo[hist,drawNet[current]],{steps}];hist];
anim=ListAnimate[frames,AnimationRate->1,DefaultDuration->steps 0.5,AnimationRunning->False];
Grid[{{drawNet[initialMarking],anim}},Spacings->{2,2}]


Column[{Style["1. Packet Slicing Visualization (PIF Guarantees 1st Slice Perfect)",Bold,14,Blue],Module[{packetLength=64,sliceLength=8,slices,faultPattern,sliceColors},slices=packetLength/sliceLength;SeedRandom[123];faultPattern=Join[{0},RandomInteger[{0,1},slices-1]];sliceColors=(If[#1==0,Green,Red]&)/@faultPattern;Graphics[Table[{EdgeForm[Black],FaceForm[sliceColors[[i]]],Rectangle[{i,0},{i+1,1}],Text[Style[ToString[i],White,12,Bold],{i+0.5,0.5}]},{i,1,slices}],Axes->None,ImageSize->480,PlotRange->{{0,slices},{0,1}},AspectRatio->0.16]],Spacer[20],Style["2. All Four Link Reliability States",Bold,14,Blue],Grid[Partition[Table[Module[{state=s,colorA,colorB,labelA,labelB},Switch[state,"11",colorA=colorB=Green;labelA="A\[RightArrow]B";labelB="B\[RightArrow]A","10",colorA=Green;colorB=Red;labelA="A\[RightArrow]B";labelB="B\[RightArrow]A","01",colorA=Red;colorB=Green;labelA="A\[RightArrow]B";labelB="B\[RightArrow]A","00",colorA=colorB=Red;labelA="A\[RightArrow]B";labelB="B\[RightArrow]A"];Column[{Style[state,Bold,14],Graphics[{Arrowheads[0.12],{colorA,Arrow[{{0,0},{1,0}}]},Text[labelA,{0.5,0.1},{0,0}],{colorB,Arrow[{{1,0.2},{0,0.2}}]},Text[labelB,{0.5,0.3},{0,0}]},PlotRange->{{-0.2,1.2},{-0.1,0.4}},ImageSize->120,Axes->False,Background->Lighter[Gray,0.95]]}]],{s,{"11","10","01","00"}}],2],Spacings->{2,2}],Spacer[20],Style["3. L(n) and FailureModes(n) Formulas and Enumeration Table",Bold,14,Blue],Module[{L,FailureModes,table},L[n_]:=If[n<=8,Binomial[n,2],4 n];FailureModes[n_]:=4^L[n]-1;table=Table[{n,L[n],FailureModes[n]},{n,2,20}];Grid[Prepend[table,{"n","L(n)","FailureModes(n)"}],Frame->All,Alignment->Center]],Spacer[20],Style["4. Log-Plot: Explosion of Failure Modes as n Increases",Bold,14,Blue],Module[{L,FailureModes,failureData},L[n_]:=If[n<=8,Binomial[n,2],4 n];FailureModes[n_]:=4^L[n]-1;failureData=Table[{n,FailureModes[n]},{n,2,20}];ListLogPlot[failureData,Joined->True,PlotMarkers->Automatic,Mesh->All,AxesLabel->{"n","Failure Modes (log scale)"},PlotLabel->Style["Explosion of Failure Modes in Octavalent Mesh",Bold,14],ImageSize->420]],Spacer[20],Style["5. Interactive: n, L(n), and FailureModes(n) Explorer",Bold,14,Blue],Module[{L,FailureModes},L[n_]:=If[n<=8,Binomial[n,2],4 n];FailureModes[n_]:=4^L[n]-1;Manipulate[Column[{Row[{"n = ",n,",   L(n) = ",L[n],",   FailureModes(n) = ",FailureModes[n]}],ListLogPlot[Table[{k,FailureModes[k]},{k,2,n}],Joined->True,Mesh->All,AxesLabel->{"n","Failure Modes (log)"},PlotLabel->"Combinatorial Failure Modes for Ethernet Link States"]}],{{n,10,"Number of Nodes"},2,20,1,Appearance->"Labeled"}]],Spacer[20],Style["6. Epistricted Registers (EPI): State Restriction Visualization",Bold,14,Blue],Module[{allStates,epistrictedStates},allStates=Tuples[{0,1},2];epistrictedStates={{0,0},{1,1}};GraphicsGrid[{{Style["All Classical States",Bold,12],Style["Epistricted States",Bold,12]},{Graphics[Table[{If[MemberQ[epistrictedStates,state],Green,Blue],Disk[state,0.15],Text[state,state+{0,-0.25}]},{state,allStates}],Axes->False,PlotRange->{{-0.5,1.5},{-0.5,1.5}},ImageSize->200],Graphics[Table[{If[MemberQ[epistrictedStates,state],Green,LightGray],Disk[state,0.15],Text[state,state+{0,-0.25}]},{state,allStates}],Axes->False,PlotRange->{{-0.5,1.5},{-0.5,1.5}},ImageSize->200]}}]]}]


L[n_]:=If[n<=9,Binomial[n,2],4 n]
LinkStates[n_]:=4^L[n]
FailureModes[n_]:=LinkStates[n]-1
table=Table[{n,L[n],LinkStates[n],FailureModes[n]},{n,2,20}];
tableHeadings={"Nodes n","Links L(n)","Total Configs","Failure Modes"};
Print["--- Fault Model Table ---"];
Grid[Prepend[table,tableHeadings],Frame->All,Alignment->Center,Background->{None,{{Lighter[Gray,0.95]},None}}]
Print["--- Failure Modes Growth (Log Plot) ---"];
ListLogPlot[Table[{n,FailureModes[n]},{n,2,20}],Joined->True,Mesh->All,MeshStyle->Red,PlotMarkers->Automatic,PlotLabel->"Number of Failure Modes vs. Nodes (n)",Frame->True,FrameLabel->{"Nodes n","Failure Modes (log scale)"},GridLines->Automatic,ImageSize->Large]
Print["--- Example Link State Enumerations for n = 3 ---"];
nSmall=3;
linksSmall=Subsets[Range[nSmall],{2}];
statesSmall=Tuples[{"00","01","10","11"},Length[linksSmall]];
Grid[Prepend[Table[Row[Table[linksSmall[[k]]->statesSmall[[i,k]],{k,Length[linksSmall]}],"  "],{i,1,8}],"Links and States (First 8 configs)"],Frame->All]
Print["--- Visualization: Link State Colors in n=4 Graph ---"];
nVis=4;
nodesVis=Range[nVis];
linksVis=Subsets[nodesVis,{2}];
SeedRandom[42];
randStates=RandomChoice[{"00","01","10","11"},Length[linksVis]];
stateColor["11"]=Green;
stateColor["10"]=Blue;
stateColor["01"]=Orange;
stateColor["00"]=Red;
Graph[nodesVis,Table[Style[UndirectedEdge@@linksVis[[k]],Thick,stateColor[randStates[[k]]]],{k,Length[linksVis]}],VertexLabels->"Name",EdgeLabels->Table[UndirectedEdge@@linksVis[[k]]->randStates[[k]],{k,Length[linksVis]}],ImageSize->Medium,PlotLabel->"Random Fault Configuration (edge color = link state)"]
Print["--- PIF Model: Echo of First 8 Bytes ---"];
EchoSlice[packet_]:=Take[packet,8]
packet=RandomInteger[{0,255},64];
firstSlice=EchoSlice[packet];
Grid[{{"Full 64-byte packet (Tx)",packet},{"First 8 bytes echoed back (Rx)",firstSlice}},Frame->All,ItemStyle->{Directive[Bold,14]},Background->{None,{{LightBlue,None}}}]
Print["--- EPI Model: Epistricted Register States (Spekkens-like) ---"];
allStates=Tuples[{0,1},2];
epistrictedStates=Select[allStates,Total[#1]==1&];
Grid[{{"All possible states",allStates},{"Epistricted states",epistrictedStates}},Frame->All,ItemStyle->{Directive[Bold,14]},Background->{None,{{LightYellow,None}}}]


slots=8;
slotRects[side_,filled_]:=Table[{If[filled[[i]],LightGreen,LightGray],EdgeForm[Black],Rectangle[{i,side},{i+0.8,side+0.6}]},{i,1,slots}];
pairedLines[paired_]:=Table[If[paired[[i]],{Dashed,Blue,Thick,Line[{{i+0.4,0.6},{i+0.4,1}}]},{}],{i,1,slots}];
slotViz[filledA_,filledB_,paired_]:=Graphics[{slotRects[0,filledA],slotRects[1,filledB],pairedLines[paired],Text[Style["Host A Slots",14],{4,-0.25}],Text[Style["Host B Slots",14],{4,1.9}]},PlotRange->{{0,9},{-0.5,2.2}},ImageSize->480];
slotVizAllPaired=slotViz[ConstantArray[True,slots],ConstantArray[True,slots],ConstantArray[True,slots]];
slotVizKoherenceLoss=slotViz[ReplacePart[ConstantArray[True,slots],5->False],ReplacePart[ConstantArray[True,slots],5->False],ReplacePart[ConstantArray[True,slots],5->False]];
triangleHealViz:=Graphics[{{FaceForm[LightGray],EdgeForm[Black],Disk[{0,0},0.5],Disk[{2,0},0.5],Disk[{1,1.7},0.5]},{Arrowheads[0.04],Blue,Arrow[{{0.4,0.2},{1.6,1.5}}],Arrow[{{1.6,1.5},{1.6,0.1}}],Arrow[{{1.6,0.1},{0.4,0.2}}]},Text[Style["Alice",14],{0,-0.7}],Text[Style["Bob",14],{2,-0.7}],Text[Style["Coordinator (Charlie)",13,Bold,Darker[Blue]],{1,2.4}],Text[Style["Local healing (Triangle Recovery)",12,Italic,Red],{1,-1}]},PlotRange->{{-1,3},{-1.2,2.7}},ImageSize->380];
sliceViz[stage_]:=Module[{tokens,acks,txColor=LightBlue,ackColor=LightGreen},tokens=Table[If[stage==i,{txColor,EdgeForm[Black],Disk[{i,0},0.16],Arrow[{{i,0.18},{i,0.55}}],Text["slice",{i,0.34},{0,0}]}],{i,1,8}];acks=Table[If[stage>i,{ackColor,EdgeForm[Black],Disk[{i,1},0.14],Arrow[{{i,0.82},{i,0.45}}],Text["ack",{i,0.67},{0,0}]}],{i,1,8}];Graphics[{tokens,acks,Text["Host A",{0,-0.3}],Text["Host B",{0,1.3}]},PlotRange->{{0.4,8.6},{-0.5,1.5}},ImageSize->460]];
sliceViz1=sliceViz[2];
altBitDiagram[nBits_:1]:=Module[{states,arrows,y,abpColors={LightYellow,LightBlue,LightRed,LightGreen}},states=Table[{abpColors[[Mod[i,Length[abpColors],1]]],EdgeForm[Black],Disk[{i,0},0.14],Text[Style[IntegerString[i,2,nBits],14],{i,0.28}]},{i,0,2^nBits-1}];arrows=Table[{Arrowheads[0.04],Black,Arrow[{{i,0.14},{Mod[i+1,2^nBits],0.14}}]},{i,0,2^nBits-1}];Graphics[{states,arrows,Text["ABP States",{2^(nBits-1),-0.5}]},PlotRange->{{-1,2^nBits},{-0.7,0.8}},ImageSize->240+nBits 60]];
abp1bit=altBitDiagram[1];
abp2bit=altBitDiagram[2];
Column[{Style["1. Finite Shannon Slot Pairing (Healthy)","Section"],slotVizAllPaired,Style["2. Loss of Koherence (Timeout/Retry)","Section"],slotVizKoherenceLoss,Style["3. Triangle Healing: Local Recovery After Pair Loss","Section"],triangleHealViz,Style["4. Circulating Slices/Tokens and ACKs (1PC Model)","Section"],sliceViz1,Style["5. Alternating Bit Protocol (ABP): Classic (1-bit) and Bill Lynch (2-bit)","Section"],Row[{abp1bit,Spacer[24],abp2bit}]}]


Print[Style["1. Global Flooding vs. Local Ant/Bee Scouting: Conceptual Network",16,Bold,Blue]];
SeedRandom[12345];
nNodes=16;
g=RandomGraph[{nNodes,24}];
coords=GraphEmbedding[g,"CircularEmbedding"];
floodingVis[src_]:=Module[{edgesVisited={},allVertices=VertexList[g],vLabels},BreadthFirstScan[g,src,{"DiscoverVertex"->(AppendTo[edgesVisited,#2->#1]&)}];vLabels=AssociationThread[allVertices,allVertices];HighlightGraph[g,{Style[src,Red,22],Style[Complement[allVertices,{src}],Black,14],Style[edgesVisited/. Rule->UndirectedEdge,Thick,Blue]},VertexLabels->vLabels,VertexCoordinates->coords]];
antBeeVis[src_,steps_]:=Module[{path={src},v=src,visited=Association[src->True],nbhd,next,vLabels,allVertices=VertexList[g]},Do[nbhd=Complement[Flatten[{NeighborhoodVertices[g,v,1]}],Flatten[{Keys[visited]}]];If[Length[nbhd]==0,Break[]];next=RandomChoice[nbhd];visited[next]=True;AppendTo[path,next];v=next;,{steps}];vLabels=AssociationThread[allVertices,allVertices];HighlightGraph[g,{Style[path,Thick,Orange],Style[src,Red,22],Style[Complement[allVertices,path],Gray,12]},VertexLabels->vLabels,VertexCoordinates->coords,EdgeStyle->{EdgeList[g]->LightGray,Thread[Partition[path,2,1]/. {a_,b_}:>a\[UndirectedEdge]b]->{Orange,Thick}}]];
GraphicsRow[{floodingVis[1],antBeeVis[1,6]},Spacings->2,ImageSize->900,PlotLabel->Row[{Style["Flooding (Full Discovery)",14,Bold],"        ",Style["Ant/Bee (Local Path Only)",14,Bold,Orange]}]]
Print[Style["2. Scale-Independence: Local Discovery vs. Global (Network Size Varies)",16,Bold,Blue]];
Manipulate[Module[{g2,coords2,src=1,allVertices,path,v,visited,nbhd,next},g2=RandomGraph[{nodes,nodes+8}];coords2=GraphEmbedding[g2,"CircularEmbedding"];allVertices=VertexList[g2];path={src};v=src;visited=Association[src->True];Do[nbhd=Complement[Flatten[{NeighborhoodVertices[g2,v,1]}],Flatten[{Keys[visited]}]];If[Length[nbhd]==0,Break[]];next=RandomChoice[nbhd];visited[next]=True;AppendTo[path,next];v=next;,{steps}];GraphicsRow[{HighlightGraph[g2,Style[allVertices,Black,12],VertexLabels->None,VertexCoordinates->coords2,ImageSize->350,PlotLabel->Style["Network Size: "<>ToString[nodes]<>" Nodes",13]],HighlightGraph[g2,{Style[path,Thick,Orange],Style[src,Red,18],Style[Complement[allVertices,path],Gray,12]},VertexLabels->None,VertexCoordinates->coords2,EdgeStyle->{EdgeList[g2]->LightGray,Thread[Partition[path,2,1]/. {a_,b_}:>a\[UndirectedEdge]b]->{Orange,Thick}},ImageSize->350,PlotLabel->Style["Ant/Bee Local Scouting\n(Does Not Scale with Network Size)",13]]},Spacings->2]],{{nodes,16,"Number of Nodes"},8,64,1,Appearance->"Labeled"},{{steps,7,"Ant/Bee Scouting Steps"},3,15,1,Appearance->"Labeled"},ControlPlacement->Top]
Print[Style["3. Limiting Enclave Size: Secure Boundary with Local Discovery",16,Bold,Blue]];
Graphics[{LightGray,Disk[{0,0},3],Lighter[Blue,0.8],Disk[{0,0},2],Lighter[Green,0.8],Disk[{0,0},1],Black,Circle[{0,0},1],Circle[{0,0},2],Circle[{0,0},3],Text[Style["Core\n(Local Nodes Only)",13,Bold],{0,0}],Text[Style["Enclave\n(Limited by Ant/Bee Range)",13,Bold,Blue],{0,1.4}],Text[Style["Rest of Network\n(Not Discovered)",13,Gray],{0,2.5}],Red,Thick,Circle[{0,0},2]},ImageSize->320,PlotLabel->"Local Discovery Limits Enclave Size (No Global Topology Known)"]
Print[Style["4. FAQ Table: Summary (for Inclusion in Papers)",16,Bold,Blue]];
Grid[{{Style["Question",Bold],Style["Answer",Bold]},{"Why not use global flooding to discover all routes?","Flooding is not scale-independent; it forces every node to know (and possibly connect to) every other node. This is infeasible in large, secure, or privacy-bound networks."},{"How are Ant/Bee algorithms different?","They only learn/discover enough local routes to achieve functional connectivity. No node requires knowledge of the full network; this limits the scope of discovery (and trust/exposure)."},{"What is the benefit?","Scale-independence: the work required does not grow with network size. Secure enclaves can be formed by bounding the scouting range."}},Frame->All,Spacings->{2,2},Alignment->Left,BaseStyle->12]


SeedRandom[42];
nodes=Range[1,9];
meshEdges=Join[Table[i\[UndirectedEdge]i+1,{i,1,8,3}],Table[i\[UndirectedEdge]i+3,{i,1,6}]];
meshGraph=Graph[nodes,meshEdges,VertexCoordinates->Thread[nodes->Tuples[{Range[3],Range[3]}]],VertexLabels->"Name",ImageSize->350,GraphStyle->"NameLabeled"];
source=1;
dest=9;
sourceRoute={1,2,3,6,9};
sourceEdges=UndirectedEdge@@@Partition[sourceRoute,2,1];
sourceRoutingGraph=HighlightGraph[meshGraph,{Style[sourceRoute,Directive[Bold,Blue,22]],Style[sourceEdges,Thick,Blue]}];
sourceRoutingLabel="Source Routing:\nRoute = "<>ToString[sourceRoute];
destBasedRoute=FindShortestPath[meshGraph,source,dest];
destEdges=UndirectedEdge@@@Partition[destBasedRoute,2,1];
destRoutingGraph=HighlightGraph[meshGraph,{Style[destBasedRoute,Directive[Bold,Red,22]],Style[destEdges,Thick,Red]}];
destRoutingLabel="Destination-Based Routing (Shortest Path):\nRoute = "<>ToString[destBasedRoute];
serviceNode=7;
nameRoute={1,4,7};
nameEdges=UndirectedEdge@@@Partition[nameRoute,2,1];
nameRoutingGraph=HighlightGraph[meshGraph,{Style[nameRoute,Directive[Bold,Green,22]],Style[nameEdges,Thick,Darker[Green]]}];
nameRoutingLabel="Name-Based Routing:\nRoute to \"Service X\" at node "<>ToString[serviceNode]<>" = "<>ToString[nameRoute];
summaryTable={{"Routing Type","Header Overhead","Per-Hop Logic","Flexibility"},{"Source Routing","High","Low","Low"},{"Destination-Based","Low","Medium","Medium"},{"Name-Based","Medium/High","High","High"}};
Print["--- Chiplet Network Routing Paradigms ---"];
Grid[{{Labeled[sourceRoutingGraph,sourceRoutingLabel,Top],Labeled[destRoutingGraph,destRoutingLabel,Top],Labeled[nameRoutingGraph,nameRoutingLabel,Top]}},Spacings->{2,2}]
Print["--- Routing Paradigm Summary ---"];
Grid[summaryTable,Frame->All,Alignment->Center,Background->{None,{{Lighter[Gray,0.95]},None}}]


SeedRandom[23];
nNodes=7;
chipNet=Graph[{"A","B","C","D","E","F","G"},{"A"\[UndirectedEdge]"B","A"\[UndirectedEdge]"D","B"\[UndirectedEdge]"C","B"\[UndirectedEdge]"E","C"\[UndirectedEdge]"F","D"\[UndirectedEdge]"E","D"\[UndirectedEdge]"G","E"\[UndirectedEdge]"F","F"\[UndirectedEdge]"G"},VertexCoordinates->Association["A"->{0,1},"B"->{1,2},"C"->{2.2,2.4},"D"->{0,-0.8},"E"->{1.2,0.3},"F"->{2.5,1.2},"G"->{2.2,-0.7}],VertexStyle->Lighter[Blue,0.6],EdgeStyle->Gray,VertexLabels->"Name",ImageSize->370];
sourcePath={"A","B","E","F","G"};
sourceRoutingGraph=HighlightGraph[chipNet,{Style[PathGraph[sourcePath],Orange,Thick],Style["A",Green,Bold,18],Style["G",Red,Bold,18]},GraphHighlightStyle->"Dehighlighted"];
sourceLabel=Labeled[sourceRoutingGraph,Column[{Style["Source Routing",16,Bold,Orange],"Path encoded: A \[RightArrow] B \[RightArrow] E \[RightArrow] F \[RightArrow] G\nHeader: [B,E,F,G]\nAt each node, the next hop is read from header."}],Top];
destPath=FindShortestPath[chipNet,"A","G"];
destRoutingGraph=HighlightGraph[chipNet,{Style[PathGraph[destPath],Purple,Thick,Dashed],Style["A",Green,Bold,18],Style["G",Red,Bold,18]},GraphHighlightStyle->"Dehighlighted"];
destLabel=Labeled[destRoutingGraph,Column[{Style["Destination-Based Routing",16,Bold,Purple],"Packet carries destination G\nEach node forwards via table:\nNext = FwdTbl[destination]"}],Top];
serviceLocation="F";
namePath=FindShortestPath[chipNet,"A",serviceLocation];
nameRoutingGraph=HighlightGraph[chipNet,{Style[PathGraph[namePath],Blue,Thick,Dotted],Style["A",Green,Bold,18],Style[serviceLocation,Red,Bold,18]},GraphHighlightStyle->"Dehighlighted"];
nameLabel=Labeled[nameRoutingGraph,Column[{Style["Name-Based Routing",16,Bold,Blue],"Packet: [service=foo]\nRouters resolve name \[RightArrow] location\nPath = A \[RightArrow] B \[RightArrow] C \[RightArrow] F"}],Top];
summaryTable=Grid[{{"Routing Type","Header Overhead","Per-Hop Logic","Flexibility"},{"Source Routing","High","Low","Low"},{"Destination-Based","Low","Medium","Medium"},{"Name-Based","Medium/High","High","High"}},Frame->All,Background->{None,{{LightGray,None,None,None}}},Alignment->Left];
Column[{Style["Chiplet Ethernet: Routing Paradigm Visualization","Section"],Row[{sourceLabel,Spacer[8],destLabel,Spacer[8],nameLabel}],Spacer[12],Style["Routing Paradigm Summary","Subsection"],summaryTable}]


SeedRandom[100];
nodes=Range[8];
edges={1\[UndirectedEdge]2,1\[UndirectedEdge]5,2\[UndirectedEdge]3,2\[UndirectedEdge]6,3\[UndirectedEdge]4,3\[UndirectedEdge]7,4\[UndirectedEdge]8,5\[UndirectedEdge]6,6\[UndirectedEdge]7,7\[UndirectedEdge]8};
g=Graph[nodes,edges,VertexLabels->"Name",GraphStyle->"NameLabeled",ImageSize->340];
antStart=1;
antSteps=7;
antPath=Module[{path={antStart}},Do[Module[{curr=Last[path],nb},nb=DeleteCases[NeighborhoodVertices[g,curr],Alternatives@@path];If[nb==={}||!ListQ[nb],Break[],AppendTo[path,RandomChoice[nb]]]],{antSteps}];path=DeleteDuplicates[path];path];
antEdges=UndirectedEdge@@@Partition[antPath,2,1];
pheromoneColors=Table[Blend[{Yellow,Orange},k/antSteps],{k,0,Length[antEdges]-1}];
antTrailGraph=HighlightGraph[g,{Style[antPath,Directive[Bold,Black,20]],MapThread[Style,{antEdges,pheromoneColors}]}];
antTrailLabel="Ant-Based Discovery:\nScouts sample and reinforce paths (pheromones).";
hiveNode=6;
beePaths=Table[FindShortestPath[g,hiveNode,i],{i,Complement[nodes,{hiveNode}]}];
beeEdges=Flatten[(UndirectedEdge@@@Partition[#1,2,1]&)/@beePaths];
beeGraph=HighlightGraph[g,{Style[hiveNode,Directive[Bold,Darker[Yellow],24]],Style[beeEdges,Thick,Yellow],Style[Flatten[beePaths],Directive[Bold,Black,18]]}];
beeLabel="Bee-Inspired: Scouts report to Hive; dance broadcasts best routes.";
snakeStart=1;
snakeRoute=Quiet[FindHamiltonianPath[g]];
If[!ListQ[snakeRoute]||Length[snakeRoute]<Length[nodes],snakeRoute=FindPath[g,snakeStart,8,All,12];If[ListQ[snakeRoute]&&snakeRoute=!={},snakeRoute=snakeRoute[[1]],snakeRoute={snakeStart}]];
snakeEdges=If[Length[snakeRoute]>1,UndirectedEdge@@@Partition[snakeRoute,2,1],{}];
snakeGraph=HighlightGraph[g,{Style[snakeRoute,Directive[Bold,Purple,20]],Style[snakeEdges,Thick,Purple]}];
snakeLabel="Snake Traversal:\nSystematically visits all nodes, returns with full map.";
spiderOrigin=1;
spiderThreads=Table[FindPath[g,spiderOrigin,n,3],{n,Complement[nodes,{spiderOrigin}]}];
spiderThreadsFlat=Select[Flatten[spiderThreads,1],Length[#1]>1&];
spiderEdges=Flatten[(UndirectedEdge@@@Partition[#1,2,1]&)/@spiderThreadsFlat];
spiderGraph=HighlightGraph[g,{Style[spiderOrigin,Directive[Bold,Black,22]],Style[spiderEdges,Dashed,Darker[Gray,0.4]]}];
spiderLabel="Spider Web: Multi-threaded discovery and local neighbor webs.";
wormPath={1,2,6,7,8};
wormEdges=UndirectedEdge@@@Partition[wormPath,2,1];
flitColors={Red,Orange,Green};
frames=Table[HighlightGraph[g,{Style[wormPath[[1;;i]],Directive[Bold,Black,18]],If[i>=2,Style[wormEdges[[1;;i-1]],Thick,Blue],{}],If[i>=1,Style[wormPath[[i]],flitColors[[1]]],{}],If[i>=2&&i<Length[wormPath],Style[wormPath[[2;;i]],flitColors[[2]]],{}],If[i==Length[wormPath],Style[wormPath[[i]],flitColors[[3]]],{}]}],{i,1,Length[wormPath]}];
wormLabel="Wormhole Routing:\nFlits forwarded in a pipeline (head, body, tail).";
routingTable={{"Technique","Discovery/Forwarding","Overhead","Adaptivity","Ideal Use"},{"Ant","Random scouts, pheromone trails","Low","High","Adaptive routing, scalable"},{"Bee","Hive aggregation, dancing","Medium","Medium","Semi-centralized optimization"},{"Snake","Full network traversal, return","High","Low","Diagnostics, full map"},{"Spider","Multi-thread, local web","Medium","High","Redundant mesh building"},{"Wormhole","Flits in pipeline","Low","High","Low-latency forwarding"}};
Print["--- Biologically Inspired Topology Learning & Routing ---"];
Grid[{{Labeled[antTrailGraph,antTrailLabel,Top],Labeled[beeGraph,beeLabel,Top]},{Labeled[snakeGraph,snakeLabel,Top],Labeled[spiderGraph,spiderLabel,Top]}},Spacings->{2,2}]
Print["--- Wormhole Routing Animation (Head/Body/Tail Flits) ---"];
ListAnimate[frames,AnimationRunning->False]
Print["--- Technique Comparison Table ---"];
Grid[routingTable,Frame->All,Alignment->Center,Background->{None,{{Lighter[Gray,0.95]},None}}]


SeedRandom[42];
nodes=Range[1,9];
meshEdges=Join[Table[i\[UndirectedEdge]i+1,{i,1,8,3}],Table[i\[UndirectedEdge]i+3,{i,1,6}]];
g=Graph[nodes,meshEdges,VertexCoordinates->Thread[nodes->Tuples[{Range[3],Range[3]}]],VertexLabels->"Name",ImageSize->340,GraphStyle->"NameLabeled"];
antStart=1;
antPath=Module[{path={antStart}},Do[Module[{curr=Last[path],nb},nb=DeleteCases[NeighborhoodVertices[g,curr],Alternatives@@path];If[nb==={},Break[],AppendTo[path,Quiet[RandomChoice[nb],{RandomChoice::lrwl}]]]],{7}];path];
antEdges=UndirectedEdge@@@Partition[antPath,2,1];
hiveNode=5;
beePaths=Table[FindShortestPath[g,hiveNode,n],{n,Complement[nodes,{hiveNode}]}];
beeEdges=Flatten[(UndirectedEdge@@@Partition[#1,2,1]&)/@beePaths];
snakeRoute=Quiet[FindHamiltonianPath[g]];
If[!ListQ[snakeRoute]||Length[snakeRoute]<Length[nodes],snakeRoute=FindPath[g,1,9,All,9];If[ListQ[snakeRoute]&&snakeRoute=!={},snakeRoute=snakeRoute[[1]],snakeRoute={1}]];
snakeEdges=If[Length[snakeRoute]>1,UndirectedEdge@@@Partition[snakeRoute,2,1],{}];
spiderOrigin=1;
spiderThreads=Table[FindPath[g,spiderOrigin,n,3],{n,Complement[nodes,{spiderOrigin}]}];
spiderThreadsFlat=Select[Flatten[spiderThreads,1],Length[#1]>1&];
spiderEdges=Flatten[(UndirectedEdge@@@Partition[#1,2,1]&)/@spiderThreadsFlat];
wormPath=FindShortestPath[g,1,9];
wormEdges=UndirectedEdge@@@Partition[wormPath,2,1];
frames=Table[HighlightGraph[g,{Style[antEdges,Dashed,Lighter[Yellow,0.5]],Style[beeEdges,Dashed,Lighter[Orange,0.7]],Style[snakeEdges,Dashed,Lighter[Purple,0.7]],Style[spiderEdges,Dashed,Lighter[Blue,0.7]],Style[wormPath[[1;;i]],Directive[Bold,Black,20]],If[i>=2,Style[wormEdges[[1;;i-1]],Thick,Red],{}],If[i==Length[wormPath],Style[wormPath[[i]],Green],Style[wormPath[[i]],Red]]}],{i,1,Length[wormPath]}];
summaryTable={{Style["Mechanism",Bold],Style["Role in Discovery",Bold],Style["Role in Forwarding",Bold],Style["Resilience",Bold],Style["Adaptivity",Bold]},{Style["Ants",Yellow],"Explore paths, cache metrics","","High","High"},{Style["Bees",Orange],"Aggregate, broadcast quality","","Med","Med"},{Style["Snakes",Purple],"Full topology mapping","","Full","Low"},{Style["Spiders",Blue],"Local mesh, redundancy","","High","High"},{Style["Worms",Red],"","Efficient flit forwarding","Low","High"},{Style["Integration",Black,Bold],"Discover, reinforce","Fast data, few buffers","Maximal","Maximal"}};
legend=GraphicsRow[{{Style[Line[{{0,0},{1,0}}],Yellow,Thick]," Ant"},{Style[Line[{{0,0},{1,0}}],Orange,Thick]," Bee"},{Style[Line[{{0,0},{1,0}}],Purple,Thick]," Snake"},{Style[Line[{{0,0},{1,0}}],Blue,Thick]," Spider"},{Style[Line[{{0,0},{1,0}}],Red,Thick]," Wormhole"}},Spacings->1];
Column[{Labeled[HighlightGraph[g,{Style[antEdges,Thick,Yellow],Style[beeEdges,Thick,Orange],Style[snakeEdges,Thick,Purple],Style[spiderEdges,Thick,Blue]}],Column[{Style["All Discovery Mechanisms Overlayed",14,Bold],legend}],Top],Style["Composite: Discovery (Faded) + Efficient Wormhole Forwarding",13,Bold,Black],ListAnimate[frames,AnimationRunning->False,DefaultDuration->6],Style["Mechanism Integration Summary",13,Bold,Black],Grid[summaryTable,Frame->All,Alignment->Center,Background->{None,{{Lighter[Gray,0.97]},None}}]}]


arrowGraphics=Table[Module[{pos=n,plist=pheromones[n]},Table[With[{vec=directions[dir],val=plist[dir]},If[NumericQ[val],{Opacity[Rescale[val,{0.4,2},{0.2,0.9}]],Arrow[{pos,pos+0.28 vec}]},Sequence[]]],{dir,Select[directionList,MemberQ[nodes,n+directions[#1]]&]}]],{n,nodes}];
packetArrows=Table[With[{from=packet[[i]],to=packet[[i+1]]},{Directive[Red,Thick,Arrowheads[0.045]],Arrow[{from,to}]}],{i,Length[packet]-1}];
packetTrail={Directive[Red,Opacity[0.7]],(Disk[#1,0.11]&)/@packet};
phField=Graphics[Flatten[arrowGraphics],PlotRange->{{0.5,gridSize+0.5},{0.5,gridSize+0.5}},ImageSize->380];
packetViz=Graphics[{packetArrows,packetTrail},PlotRange->{{0.5,gridSize+0.5},{0.5,gridSize+0.5}},ImageSize->380];
meshGraph=GraphPlot[g,VertexCoordinateRules->AssociationThread[nodes,nodes],VertexStyle->LightGray,EdgeStyle->Gray,PlotRange->{{0.5,gridSize+0.5},{0.5,gridSize+0.5}},ImageSize->380,VertexLabels->None];
summary=Grid[{{"Phase","Mechanism","Routing Behavior","Emergent Effect"},{"Scouting","Random/pheromone-biased agent walks","Local tables updated, directional ranking","Efficient path discovery, self-organizing field"},{"Routing","Bufferless, hot-potato, pheromone prioritization","Always forwards, may deflect, always updates local table","Packets follow best field, adapt to congestion"}},Frame->All,Alignment->Left,Background->{None,{{LightGray,None}}}];
Column[{Style["4.4 Biologically Inspired Scouting Before Routing (Pheromones + Bufferless Deflection)","Section"],Row[{Labeled[Show[phField,meshGraph],"Pheromone Field (Arrow thickness = trail strength)",Top],Spacer[12],Labeled[Show[packetViz,meshGraph],"Hot-Potato Routing with Local Pheromone Table",Top]}],summary,Style["Key: Arrows show local routing 'desirability' at each node (thicker = more reinforced).\nPacket path (red) illustrates adaptive, deflecting, always-moving, bufferless routing.","Text",12]}]


Module[{wormholeDiagram},wormholeDiagram=Graphics[{Style[Rectangle[{0,1},{1,3}],LightGray,EdgeForm[Black]],Style[Rectangle[{1,0.5},{3,3.5}],LightYellow,EdgeForm[Black]],Style[Rectangle[{3,1},{4,3}],LightGray,EdgeForm[Black]],Arrow[{{-0.5,2},{0,2}}],Text["Input",{-0.7,2}],Arrow[{{4,2},{4.5,2}}],Text["Output",{4.7,2}],Arrow[{{2,3.5},{2,4}}],Text["Control",{2,4.2}],Text["Router Core",{2,2}],Text["Input Buffer",{0.5,2.7},{0,0}],Text["Output Buffer",{3.5,2.7},{0,0}],Text["Wormhole Path",{2,0.7},{0,0}],Dashed,Circle[{2,2},1.2]},PlotLabel->"Wormhole Router Schematic",ImageSize->320];wormholeDiagram]


Module[{nNodes=16,mesh,coordAssoc,neighborAssoc,hiveNode,beeScoutPath,beeRecruitmentPath,hiveState,hiveGatherPlot,RandomSeedVal},RandomSeedVal=2025;SeedRandom[RandomSeedVal];mesh=GridGraph[{4,4},VertexLabels->"Name"];coordAssoc=AssociationThread[VertexList[mesh],GraphEmbedding[mesh]];neighborAssoc=Association[Table[v->VertexList[NeighborhoodGraph[mesh,v,1]][[2;;All]],{v,VertexList[mesh]}]];hiveNode=1;beeScoutPath=Module[{path={hiveNode},steps=10,current=hiveNode,nbrs},Do[nbrs=neighborAssoc[current];current=RandomChoice[nbrs];path=Append[path,current];,{steps}];path];beeRecruitmentPath=Reverse[beeScoutPath];hiveState=Length[DeleteDuplicates[beeScoutPath]];hiveGatherPlot=Show[Graph[mesh,VertexCoordinates->coordAssoc,VertexStyle->{hiveNode->Orange,_->LightGray},VertexLabels->{hiveNode->Style["Hive",Bold,14],_->None},EdgeStyle->Gray,VertexSize->0.23],Graphics[{Blue,Thick,Arrowheads[.04],Arrow[coordAssoc/@beeScoutPath],Green,Dashed,Arrowheads[.03],Arrow[coordAssoc/@beeRecruitmentPath]}],PlotLabel->Style["Bee Hive/Scout Discovery and Recruitment",Bold,12],Epilog->{Text[Style["Unique scouted nodes: "<>ToString[hiveState],Medium,Blue],Scaled[{.7,.2}]]}];hiveGatherPlot]


Module[{n=16,mesh,coords,neighbors,edges,webThreads,threadColors,tension,maxTension=3,weaveOverlap,randomSeed=2025,animFrames,weaveFrames,colorForTension,safeCoords},SeedRandom[randomSeed];mesh=GridGraph[{4,4}];coords=AssociationThread[VertexList[mesh],GraphEmbedding[mesh]];neighbors=Association[Table[v->VertexList[NeighborhoodGraph[mesh,v,1]][[2;;All]],{v,VertexList[mesh]}]];edges=EdgeList[mesh];webThreads=Association[Table[v->Table[{v,nbr},{nbr,neighbors[v]}],{v,VertexList[mesh]}]];threadColors=AssociationThread[VertexList[mesh],(ColorData["Rainbow"][Rescale[#1,{1,n},{0,1}]]&)/@Range[n]];weaveOverlap=Association[Table[v->DeleteDuplicates[Flatten[Table[If[nbr2=!=v,{{v,nbr,nbr2}},Nothing],{nbr,neighbors[v]},{nbr2,neighbors[nbr]}],1]],{v,VertexList[mesh]}]];tension=AssociationThread[edges,RandomReal[{0.7,maxTension},Length[edges]]];colorForTension[_]:=Orange;safeCoords[path_List,coordAssoc_]:=Module[{pts},pts=DeleteMissing[coordAssoc/@path];If[Length[pts]==Length[path],pts,{}]];animFrames=Table[Graphics[Join[Table[Module[{e=edges[[k]],t=tension[edges[[k]]],pts},pts=safeCoords[List@@e,coords];If[Length[pts]===2,{Thick,Directive[colorForTension[t],Opacity[0.65]],Line[pts]},Sequence[]]],{k,Length[edges]}],If[step<=n,Module[{v=VertexList[mesh][[step]],clr=Lookup[threadColors,v,Black]},Table[Module[{pts=safeCoords[path,coords]},If[Length[pts]===Length[path],{Thick,clr,Dashed,Arrow[pts]},Sequence[]]],{path,webThreads[v]}]],Sequence[]],Table[{Black,EdgeForm[White],Disk[coords[v],0.04]},{v,VertexList[mesh]}],Table[Text[Style[v,Bold,12],coords[v]+{0,0.08}],{v,VertexList[mesh]}]],PlotRange->1.15 {MinMax[Values[coords][[All,1]]],MinMax[Values[coords][[All,2]]]},ImageSize->400,Background->Lighter[Gray,0.95]],{step,1,n+1}];weaveFrames=Table[Graphics[Join[Table[Module[{pts=safeCoords[List@@e,coords]},If[Length[pts]===2,{Gray,Thin,Line[pts]},Sequence[]]],{e,edges}],If[step<=n,Module[{v=VertexList[mesh][[step]],clr=Lookup[threadColors,v,Black]},Table[Module[{pts=safeCoords[path,coords]},If[Length[pts]===Length[path],{Thick,clr,Opacity[0.5],Line[pts]},Sequence[]]],{path,weaveOverlap[v]}]],Sequence[]],Table[{Black,EdgeForm[White],Disk[coords[v],0.04]},{v,VertexList[mesh]}],Table[Text[Style[v,Bold,12],coords[v]+{0,0.08}],{v,VertexList[mesh]}]],PlotRange->1.15 {MinMax[Values[coords][[All,1]]],MinMax[Values[coords][[All,2]]]},ImageSize->400,Background->Lighter[Gray,0.97]],{step,1,n+1}];Column[{Style["Spider-Web Chiplet Network: Web Construction & Tension Metrics",Bold,16,Blue],"1. **Web Construction:** Nodes send direct threads to neighbors; edge color shows tension.",ListAnimate[animFrames,DefaultDuration->3],Spacer[10],Style["Local Weave: Multi-hop Overlap and Redundancy",Bold,16,Darker[Green]],"2. **Local Weave:** Two-hop overlap paths highlight redundant reachability.",ListAnimate[weaveFrames,DefaultDuration->3]}]]


Module[{nNodes=10,path,coords,nodeRadius=0.15,packetLength=5,flitSize=0.25,flitSpacing=0.3,maxSteps,step=0,animFrames,flitPositions,headFlitIndex,stalled=False,headColor=Red,bodyColor=Orange,tailColor=Blue,blockedColor=Gray,edgeVector,edgeLength,flitCoord,edgeIndex},path=Range[nNodes];coords=Table[{i,0},{i,nNodes}];edges=Partition[path,2,1];maxSteps=nNodes+packetLength+5;flitCoord[edgeIdx_,pos_]:=Module[{startPt,endPt},startPt=coords[[edgeIdx]];endPt=coords[[edgeIdx+1]];startPt+pos (endPt-startPt)];nodeGraphics:=Table[{LightGray,EdgeForm[Black],Disk[coords[[i]],nodeRadius],Black,Text[Style[ToString[i],Bold,14],coords[[i]]+{0,-0.3}]},{i,nNodes}];edgeGraphics:=Table[{Black,Thick,Line[{coords[[i]],coords[[i+1]]}]},{i,nNodes-1}];animFrames=Table[step=t;flitPositions=Table[Module[{pos},pos=step-i+1;If[pos<1,Nothing,edgeIdx=Floor[pos];frac=pos-edgeIdx;If[edgeIdx>nNodes-1,Nothing,{edgeIdx,frac}]]],{i,packetLength}];flitPositions=DeleteCases[flitPositions,Nothing];stalled=step>=8&&step<=12;If[stalled,flitPositions=flitPositions/. {4,_}:>{4,0.9};flitPositions=SortBy[flitPositions,#1[[1]]&];flitPositions=Table[If[i==1,{4,0.9},{4,Max[0,0.9-(i-1) flitSpacing]}],{i,Length[flitPositions]}];];flitGraphics=Table[Module[{edgeIdx=flitPositions[[i,1]],pos=flitPositions[[i,2]],col},col=Which[i==1&&stalled,blockedColor,i==1,headColor,i==packetLength,tailColor,True,bodyColor];{col,Disk[flitCoord[edgeIdx,pos],flitSize]}],{i,Length[flitPositions]}];Graphics[{edgeGraphics,nodeGraphics,flitGraphics,Black,Text[Style["Step: "<>ToString[step],Bold,16],{0,1}],If[stalled,Text[Style["Status: BLOCKED at Edge 4",Red,Bold,14],{0,0.7}],Text[Style["Status: Transmitting",Darker[Green],Bold,14],{0,0.7}]]},PlotRange->{{0,nNodes+1},{-1,1}},ImageSize->700,Background->Lighter[Gray,0.9]],{t,1,maxSteps}];Manipulate[animFrames[[step]],{step,1,maxSteps,1},Initialization:>(Print["Wormhole Routing Simulation:\nRed=Head Flit, Orange=Body Flits, Blue=Tail Flit"];Print["Gray flit indicates blocked/stalled state"];)]]


Module[{gridSize=5,nodes,nodeCoords,directions,dirVectors,dirNames,pheromoneTable,pheromoneDecay=0.9,pheromoneIncrement=0.3,packets,maxSteps=40,busyPorts,colors,choosePort,updatePheromones,movePackets,routerGraphics,pheromoneGraphics,packetGraphics},nodes=Flatten[Table[{x,y},{x,1,gridSize},{y,1,gridSize}],1];nodeCoords=Association[Table[node->{node[[1]],node[[2]]},{node,nodes}]];directions={"N"->{0,1},"NE"->{1,1},"E"->{1,0},"SE"->{1,-1},"S"->{0,-1},"SW"->{-1,-1},"W"->{-1,0},"NW"->{-1,1}};dirNames=directions[[All,1]];dirVectors=Association[directions];colors=AssociationThread[dirNames->Take[ColorData[97,"ColorList"],Length[dirNames]]];pheromoneTable=Association[Table[node->Association[Table[dir->RandomReal[{0.1,0.3}],{dir,dirNames}]],{node,nodes}]];packets={{{1,1},{gridSize,gridSize},{},None},{{gridSize,1},{1,gridSize},{},None},{{1,gridSize},{gridSize,1},{},None}};busyPorts=Association[Table[node->{},{node,nodes}]];possiblePorts[node_]:=Select[directions,MemberQ[nodes,node+#1[[2]]]&];choosePort[node_,dest_,lastDir_]:=Module[{ports=possiblePorts[node],sortedPorts,freePorts,chosenDir,pheromonesAtNode=pheromoneTable[node]},sortedPorts=SortBy[ports,{-pheromonesAtNode[#1[[1]]],EuclideanDistance[node+#1[[2]],dest]}&];freePorts=Select[sortedPorts,!MemberQ[busyPorts[node],#1[[1]]]&];If[freePorts=!={},chosenDir=freePorts[[1,1]],chosenDir=If[Complement[dirNames,busyPorts[node]]=!={},First[Complement[dirNames,busyPorts[node]]],None]];chosenDir];updatePheromones[path_]:=Module[{},Do[pheromoneTable[path[[i]]][path[[i+1]]]=Min[1.0,pheromoneTable[path[[i]]][path[[i+1]]]+pheromoneIncrement],{i,Length[path]-1}];pheromoneTable=(AssociationMap[#1 pheromoneDecay&,#1]&)/@pheromoneTable;];movePackets[]:=Module[{newPackets={},chosenDir,nextNode,p,currNode,dest,path,lastDir},busyPorts=Association[Table[node->{},{node,nodes}]];For[p=1,p<=Length[packets],p++,{currNode,dest,path,lastDir}=packets[[p]];If[currNode===dest,updatePheromones[Append[path,currNode]];Continue[];];chosenDir=choosePort[currNode,dest,lastDir];If[chosenDir===None,AppendTo[newPackets,{currNode,dest,Append[path,currNode],lastDir}],nextNode=currNode+dirVectors[chosenDir];busyPorts[currNode]=Append[busyPorts[currNode],chosenDir];With[{oppDir=Switch[chosenDir,"N","S","NE","SW","E","W","SE","NW","S","N","SW","NE","W","E","NW","SE"]},busyPorts[nextNode]=Append[busyPorts[nextNode],oppDir]];AppendTo[newPackets,{nextNode,dest,Append[path,currNode],chosenDir}];];];packets=newPackets;];routerGraphics[]:=Graphics[Table[{LightGray,EdgeForm[Black],Rectangle[nodeCoords[node]-0.3,nodeCoords[node]+0.3],Table[{colors[dirNames[[i]]],Disk[nodeCoords[node]+0.35 dirVectors[dirNames[[i]]],0.1],Text[Style[dirNames[[i]],Small,Bold,Black],nodeCoords[node]+0.65 dirVectors[dirNames[[i]]]]},{i,Length[dirNames]}]},{node,nodes}],PlotRange->{{0,gridSize+1},{0,gridSize+1}},ImageSize->700,Background->Lighter[Gray,0.95]];pheromoneGraphics[]:=Graphics[Flatten[Table[Table[Module[{pos=nodeCoords[node]+0.15 dirVectors[dir],level},level=pheromoneTable[node][dir];{Opacity[level],colors[dir],Thick,Arrow[{pos,pos+0.2 dirVectors[dir]}]}],{dir,dirNames}],{node,nodes}],1],PlotRange->{{0,gridSize+1},{0,gridSize+1}},ImageSize->700];packetGraphics[]:=Graphics[Table[If[Length[packets]>=p,Style[Disk[nodeCoords[packets[[p,1]]],0.18],Directive[Thick,Black]],{}],{p,Length[packets]}],PlotRange->{{0,gridSize+1},{0,gridSize+1}},ImageSize->700];DynamicModule[{localStep=1},Panel[Column[{Style["Biologically Inspired Scouting & Bufferless Deflection Routing Simulation",Bold,16],Dynamic[Show[routerGraphics[],pheromoneGraphics[],packetGraphics[],PlotRange->{{0,gridSize+1},{0,gridSize+1}},ImageSize->700]],Row[{Button["Step Forward",movePackets[];localStep++,Enabled->Dynamic[localStep<maxSteps]],Button["Reset",packets={{{1,1},{gridSize,gridSize},{},None},{{gridSize,1},{1,gridSize},{},None},{{1,gridSize},{gridSize,1},{},None}};pheromoneTable=Association[Table[node->Association[Table[dir->RandomReal[{0.1,0.3}],{dir,dirNames}]],{node,nodes}]];localStep=1;]}],Dynamic[Text[StringForm["Step `` of ``", localStep, maxSteps]]]}]]]]


Module[{nCells=20,cells,coords,portsPerCell,maxPorts=12,edges,groundplane,portAngles,portLabels,portAssignment,spanningTrees,hopCounts,treeEdges,failedLink,rerouteTree,rerouteEdges,timeReversalStates,vizOpts,hexPortLabels=ToString/@Range[0,11]},SeedRandom[2025];cells=Range[nCells];coords=AssociationThread[cells->RandomReal[{0,10},{nCells,2}]];portsPerCell=RandomInteger[{5,9},nCells];edges=Reap[Module[{currentEdges={}},Do[Module[{cell=cells[[i]],nPorts=portsPerCell[[i]],candidates,added=0},candidates=SortBy[DeleteCases[cells,cell],EuclideanDistance[coords[cell],coords[#1]]&];Do[Module[{edge=cell\[UndirectedEdge]candidates[[j]]},If[added<nPorts&&!MemberQ[currentEdges,edge]&&!MemberQ[currentEdges,candidates[[j]]\[UndirectedEdge]cell]&&Count[currentEdges,_?(MemberQ[{cell,candidates[[j]]},#1[[1]]]&&MemberQ[{cell,candidates[[j]]},#1[[2]]]&)]<portsPerCell[[cell]]&&Count[currentEdges,_?(MemberQ[{cell,candidates[[j]]},#1[[1]]]&&MemberQ[{cell,candidates[[j]]},#1[[2]]]&)]<portsPerCell[[candidates[[j]]]],Sow[edge];AppendTo[currentEdges,edge];added++;]],{j,Length[candidates]}];],{i,nCells}]]][[2,1]];groundplane=Graph[cells,edges,VertexCoordinates->coords,VertexLabels->Placed["Name",Center],GraphStyle->"NameLabeled",ImageSize->600];portAssignment=Association[];Do[Module[{nbrs,assignedPorts=Range[portsPerCell[[cell]]],assignment=Association[]},nbrs=DeleteCases[VertexList[NeighborhoodGraph[groundplane,cell]],cell];Do[If[Length[assignedPorts]>0&&(MemberQ[edges,cell\[UndirectedEdge]nbr]||MemberQ[edges,nbr\[UndirectedEdge]cell]),assignment[nbr]=First[assignedPorts];assignedPorts=Rest[assignedPorts];],{nbr,nbrs}];portAssignment[cell]=assignment;],{cell,cells}];spanningTrees=Association[];hopCounts=Association[];treeEdges=Association[];Do[Module[{tree=FindSpanningTree[groundplane,RootVertex->root]},spanningTrees[root]=tree;hopCounts[root]=AssociationThread[VertexList[tree],(GraphDistance[tree,root,#1]&)/@VertexList[tree]];treeEdges[root]=EdgeList[tree];],{root,cells}];failedLink=RandomChoice[edges];Module[{root=First[failedLink],reducedEdges,reducedGraph},reducedEdges=DeleteCases[edges,failedLink|UndirectedEdge@@Reverse[List@@failedLink]];reducedGraph=Graph[cells,reducedEdges];rerouteTree=Quiet[FindSpanningTree[reducedGraph,RootVertex->root]];rerouteEdges=EdgeList[rerouteTree];hopCounts[root]=AssociationThread[VertexList[rerouteTree],(GraphDistance[rerouteTree,root,#1]&)/@VertexList[rerouteTree]];spanningTrees[root]=rerouteTree;];timeReversalStates=Association["BeforeFailure"->groundplane,"AfterFailure"->Graph[cells,DeleteCases[edges,failedLink]]];vizOpts={VertexSize->Medium,VertexLabels->Placed["Name",Center],PlotRangePadding->Scaled[0.1],ImageSize->Large,EdgeStyle->GrayLevel[0.5]};GraphicsRow[{Graph[cells,edges,VertexCoordinates->coords,EdgeStyle->Directive[Gray,Thin],VertexLabels->Placed["Name",Center],PlotLabel->Style["Groundplane: Physical Connectivity",Bold,14],ImageSize->400],Graph[cells,treeEdges[cells[[1]]],VertexCoordinates->coords,EdgeStyle->Directive[Blue,Thick],VertexLabels->Placed["Name",Center],PlotLabel->Style["Spanning Tree (TRAPH) Rooted at Cell "<>ToString[cells[[1]]],Bold,14],ImageSize->400],Graph[cells,edges,VertexCoordinates->coords,EdgeShapeFunction->(If[#2===failedLink,{Red,Thick,Dashed,Line[#1]},{Gray,Thin,Line[#1]}]&),VertexLabels->Placed["Name",Center],PlotLabel->Style["Failed Link Highlighted in Red",Bold,14],ImageSize->400],Graph[cells,rerouteEdges,VertexCoordinates->coords,EdgeStyle->Directive[Green,Thick,Dashed],VertexLabels->Placed["Name",Center],PlotLabel->Style["Failover Rerouted Spanning Tree at Root "<>ToString[First[failedLink]],Bold,14],ImageSize->400]},Spacings->20]]


Module[{nNodes=12,maxDegree=4,graph,edgeColors,colorPalette,scoutingPaths,scoutingStartNode=1,routedEdges,loopFreeGraph,edgeColoringRules,vertices,edges,nodePositions,edgeColorFunction},SeedRandom[2025];graph=RandomGraph[{nNodes,2 nNodes},VertexLabels->"Name",GraphStyle->"NameLabeled"];If[!ConnectedGraphQ[graph],graph=FindSpanningTree[graph,Method->"Prim"]];vertices=VertexList[graph];edges=EdgeList[graph];edgeColors=Association[];adjacentColors[edge_]:=Module[{v1,v2,adjEdges,colorsUsed},{v1,v2}=List@@edge;adjEdges=Select[edges,MemberQ[{v1,v2},#1]&];colorsUsed=DeleteDuplicates[Lookup[edgeColors,adjEdges,None]];DeleteCases[colorsUsed,None]];colorPalette=ColorData[97,"ColorList"];If[Length[colorPalette]<Length[edges],colorPalette=Table[ColorData["Rainbow"][i],{i,0,1,1./Length[edges]}];];Do[Module[{usedColors=adjacentColors[edge],availColors},availColors=Complement[colorPalette,usedColors];edgeColors[edge]=First[availColors];],{edge,edges}];scoutingPaths=Table[FindShortestPath[graph,scoutingStartNode,target],{target,DeleteCases[vertices,scoutingStartNode]}];routedEdges=DeleteDuplicates[Flatten[(UndirectedEdge@@@Partition[#1,2,1]&)/@scoutingPaths,1]];loopFreeGraph=Subgraph[graph,routedEdges];nodePositions=GraphEmbedding[graph,"SpringElectricalEmbedding"];edgeColorFunction[edge_]:=Lookup[edgeColors,edge,Black];Panel[Column[{Style["Layer 2 Ethernet Topology with Edge Coloring (Collision-Free Link Differentiation)",Bold,16],Graph[graph,VertexCoordinates->nodePositions,EdgeStyle->edgeColorFunction/@edges,VertexSize->Medium,ImageSize->Large,PlotLabel->"Original Ethernet Graph with Edge Colors",GraphLayout->"SpringElectricalEmbedding"],Spacer[20],Style["Loop-Free Path Discovery from Node "<>ToString[scoutingStartNode],Bold,14],Graph[graph,VertexCoordinates->nodePositions,EdgeStyle->(If[MemberQ[routedEdges,#1],Red,LightGray]&)/@edges,VertexSize->Medium,ImageSize->Large,PlotLabel->"Scouting Paths Highlighted (Shortest Loop-Free Paths)",GraphLayout->"SpringElectricalEmbedding"],Spacer[20],Style["Scouting Simulation: Propagation of Path Discovery Messages",Bold,14],DynamicModule[{step=1,maxStep=Length[scoutingPaths],currentPathEdges},currentPathEdges:=If[step<=maxStep,UndirectedEdge@@@Partition[scoutingPaths[[step]],2,1],{}];Column[{Slider[Dynamic[step],{1,maxStep,1},Appearance->"Labeled"],Dynamic[Graph[graph,VertexCoordinates->nodePositions,EdgeStyle->(If[MemberQ[currentPathEdges,#1],Blue,If[MemberQ[routedEdges,#1],LightGray,Gray]]&)/@edges,VertexSize->Medium,ImageSize->Medium,PlotLabel->"Scouting Step: Path to Node "<>ToString[scoutingPaths[[step,-1]]]]]}]]}]]]


nodes=Range[8];
edges={1\[UndirectedEdge]2,1\[UndirectedEdge]3,2\[UndirectedEdge]4,3\[UndirectedEdge]4,3\[UndirectedEdge]5,4\[UndirectedEdge]6,5\[UndirectedEdge]6,5\[UndirectedEdge]7,6\[UndirectedEdge]8,7\[UndirectedEdge]8};
g=Graph[nodes,edges,VertexLabels->"Name",GraphLayout->"SpringElectricalEmbedding",ImageSize->Large,EdgeStyle->Directive[Gray,Thick]];
edgeColors=Association[];
usedColorsAtVertex=AssociationThread[nodes->Table[{},{Length[nodes]}]];
Do[Module[{u=First[e],v=Last[e],forbiddenColors,assignedColor},forbiddenColors=usedColorsAtVertex[u]\[Union]usedColorsAtVertex[v];assignedColor=First[Complement[Range[Length[edges]],forbiddenColors]];edgeColors[e]=assignedColor;AppendTo[usedColorsAtVertex[u],assignedColor];AppendTo[usedColorsAtVertex[v],assignedColor];],{e,edges}];
colorPalette=ColorData[97,"ColorList"];
maxColor=Max[Values[edgeColors]];
edgeColorFunction[c_]:=colorPalette[[Mod[c-1,Length[colorPalette]]+1]];
coloredGraph=Graph[nodes,edges,VertexLabels->"Name",GraphLayout->"SpringElectricalEmbedding",EdgeStyle->(edgeColorFunction[edgeColors[#1]]&)/@edges,ImageSize->Large,PlotLabel->Style["Layer 2 Ethernet Topology with Edge Coloring",Bold,16]];
src=1;
dest=8;
sp=FindShortestPath[g,src,dest];
pathEdges=UndirectedEdge@@@Partition[sp,2,1];
highlightedGraph=Graph[nodes,edges,VertexLabels->"Name",GraphLayout->"SpringElectricalEmbedding",EdgeStyle->(If[MemberQ[pathEdges,#1],Directive[Red,Thick],Directive[Gray,Thin]]&)/@edges,VertexStyle->(If[MemberQ[sp,#1],Yellow,LightGray]&)/@nodes,ImageSize->Large,PlotLabel->Style[StringForm["Deterministic Loop-Free Path from Node `1` to Node `2`", src, dest],Bold,16]];
broadcastGraph=Graph[nodes,edges,VertexLabels->"Name",GraphLayout->"SpringElectricalEmbedding",EdgeStyle->Directive[Blue,Dashed,Thin],VertexStyle->LightBlue,ImageSize->Large,PlotLabel->Style["Traditional Broadcast Flooding at Layer 2",Bold,16]];
Grid[{{coloredGraph},{highlightedGraph},{broadcastGraph}},Spacings->{0,2}]


Module[{macAddresses={"MAC1","MAC2","MAC3","MAC4","MAC5","MAC6","MAC7"},initialEdges={"MAC1"\[UndirectedEdge]"MAC2","MAC1"\[UndirectedEdge]"MAC3","MAC2"\[UndirectedEdge]"MAC4","MAC2"\[UndirectedEdge]"MAC5","MAC3"\[UndirectedEdge]"MAC5","MAC4"\[UndirectedEdge]"MAC6","MAC5"\[UndirectedEdge]"MAC6","MAC5"\[UndirectedEdge]"MAC7","MAC6"\[UndirectedEdge]"MAC7"},g,spanningTree,treeEdges,colors,dynamicUpdates,maxUpdates=3,computeSpanningTree,highlightLoopFreePaths,simulateDynamicChange},g=Graph[macAddresses,initialEdges,VertexLabels->"Name",ImageSize->450];computeSpanningTree[graph_]:=FindSpanningTree[graph];spanningTree=computeSpanningTree[g];treeEdges=EdgeList[spanningTree];colors=ColorData[97,"ColorList"];highlightLoopFreePaths[graph_,src_]:=Module[{allPaths,edgeHighlightRules={},edgesInPath},allPaths=Table[FindShortestPath[graph,src,dst],{dst,VertexList[graph]}];Do[If[Length[allPaths[[i]]]>=2,edgesInPath=UndirectedEdge@@@Partition[allPaths[[i]],2,1];AppendTo[edgeHighlightRules,Thread[edgesInPath->colors[[Mod[i-1,Length[colors]]+1]]]]],{i,Length[allPaths]}];DeleteDuplicates[Flatten[edgeHighlightRules,1]]];Print["\n--- Initial Network Topology ---"];Print[Graph[g,GraphLayout->"SpringElectricalEmbedding",EdgeStyle->Directive[Gray,Thin],VertexSize->Medium]];Print["\n--- Loop-Free Spanning Tree (Avoid Broadcast Storms) ---"];Print[Graph[g,EdgeStyle->Thread[EdgeList[g]->(If[MemberQ[treeEdges,#1],Directive[Blue,Thick],Gray]&)/@EdgeList[g]],GraphLayout->"SpringElectricalEmbedding",VertexSize->Medium]];Print["\n--- Loop-Free Paths Highlighted by Path Identifiers ---"];Print[Graph[g,EdgeStyle->highlightLoopFreePaths[spanningTree,"MAC1"],GraphLayout->"SpringElectricalEmbedding",VertexSize->Medium]];simulateDynamicChange[graph_,step_]:=Module[{updatedGraph},Switch[step,1,EdgeDelete[graph,"MAC2"\[UndirectedEdge]"MAC5"],2,EdgeAdd[graph,"MAC3"\[UndirectedEdge]"MAC6"],3,VertexDelete[graph,"MAC4"],_,graph]];dynamicUpdates=Table[Module[{gUpdated,st,edgeRules},Quiet[gUpdated=simulateDynamicChange[g,i];st=computeSpanningTree[gUpdated];edgeRules=highlightLoopFreePaths[st,"MAC1"];Print[Style[StringForm["\n--- Dynamic Topology Update Step `1` ---", i],Bold,14]];Print[Graph[gUpdated,EdgeStyle->edgeRules,GraphLayout->"SpringElectricalEmbedding",VertexSize->Medium,ImageSize->450]];g=gUpdated;]],{i,1,maxUpdates}];Print["\n--- Computational Overhead Timing ---"];Print[Timing[Do[computeSpanningTree[g],{1000}]]];]


vertices=Range[10];
edges={1\[UndirectedEdge]2,1\[UndirectedEdge]3,2\[UndirectedEdge]3,2\[UndirectedEdge]4,3\[UndirectedEdge]5,4\[UndirectedEdge]5,4\[UndirectedEdge]6,5\[UndirectedEdge]7,6\[UndirectedEdge]7,6\[UndirectedEdge]8,7\[UndirectedEdge]9,8\[UndirectedEdge]9,8\[UndirectedEdge]10,9\[UndirectedEdge]10};
g=Graph[vertices,edges,VertexLabels->"Name",GraphLayout->"SpringElectricalEmbedding"];
degreeList=VertexDegree[g];
maxDegree=Max[degreeList];
edgeColors=Association[];
usedColorsPerVertex=AssociationThread[vertices->Table[{},Length[vertices]]];
availableColors=Range[maxDegree+1];
Do[Module[{u=First[edge],v=Last[edge],forbiddenColors,chosenColor},forbiddenColors=usedColorsPerVertex[u]\[Union]usedColorsPerVertex[v];chosenColor=First[Complement[availableColors,forbiddenColors]];edgeColors[edge]=chosenColor;AppendTo[usedColorsPerVertex[u],chosenColor];AppendTo[usedColorsPerVertex[v],chosenColor];],{edge,edges}];
palette=ColorData[97,"ColorList"];
numColors=maxDegree+1;
colorFunc[colorIndex_]:=palette[[Mod[colorIndex-1,Length[palette]]+1]];
edgeStyles=Table[edge->Directive[Thick,colorFunc[edgeColors[edge]]],{edge,edges}];
coloredGraph=Graph[vertices,edges,VertexLabels->Placed["Name",Center],GraphLayout->"SpringElectricalEmbedding",EdgeStyle->edgeStyles,ImageSize->Large,PlotLabel->Style[StringForm["Edge Coloring of Ethernet Graph with `1` Colors (\[CapitalDelta] = `2`)", numColors, maxDegree],Bold,16]];
coloredGraph


ClearAll[vertexInEdgeQ,assignLocalColors,gossipColors,colorAwareDijkstra];
vertexInEdgeQ[v_,e_UndirectedEdge]:=MemberQ[List@@e,v];
assignLocalColors[g_Graph]:=Module[{\[CapitalDelta]=Max[VertexDegree[g]],tag=Association[]},Do[Module[{used={},adj=Select[EdgeList[g],vertexInEdgeQ[v,#1]&]},Do[With[{free=Complement[Range[0,\[CapitalDelta]],used]},tag[e]=First[free];AppendTo[used,tag[e]]],{e,adj}]],{v,VertexList[g]}];tag];
gossipColors[g_Graph,init_Association,max_:10]:=Module[{\[CapitalDelta]=Max[VertexDegree[g]],edges=EdgeList[g],curr=init,upd,it=1},While[it<=max,upd=Association[Table[Module[{u,v,nbr,nbrC,free},{u,v}=List@@e;nbr=Select[edges,(vertexInEdgeQ[u,#1]||vertexInEdgeQ[v,#1])&&#1=!=e&];nbrC=DeleteDuplicates[Lookup[curr,nbr,{}]];free=Complement[Range[0,\[CapitalDelta]],nbrC];e->If[free==={},curr[e],Min[free]]],{e,edges}]];If[upd===curr,Break[]];curr=upd;++it];curr];
colorAwareDijkstra[g_Graph,s_,d_,cost_Association]:=Module[{dist,prev,pq,u},dist=AssociationThread[VertexList[g],ConstantArray[\[Infinity],VertexCount[g]]];dist[s]=0;prev=Association[];pq=VertexList[g];While[pq=!={},u=First[MinimalBy[pq,dist]];pq=DeleteCases[pq,u];If[u===d,Break[]];Do[With[{e=u\[UndirectedEdge]v,alt=dist[u]+Lookup[cost,u\[UndirectedEdge]v,0]+1},If[alt<dist[v],dist[v]=alt;prev[v]=u]],{v,AdjacencyList[g,u]}]];If[!KeyExistsQ[prev,d],Return[{}]];Reverse[NestWhileList[prev[#1]&,d,KeyExistsQ[prev,#1]&]]];
Module[{n=8,graph,vertices,edges,\[CapitalDelta],palette,lbl,local,global,path,pis,pos,panel},SeedRandom[2025];graph=RandomGraph[{n,12}];While[!ConnectedGraphQ[graph],graph=RandomGraph[{n,12}]];vertices=VertexList[graph];edges=EdgeList[graph];\[CapitalDelta]=Max[VertexDegree[graph]];palette=Table[ColorData["Rainbow"][i/(\[CapitalDelta]+1)],{i,0,\[CapitalDelta]}];lbl=AssociationThread[vertices->"MAC-"<>ToString/@vertices];local=assignLocalColors[graph];global=gossipColors[graph,local];path=colorAwareDijkstra[graph,First[vertices],Last[vertices],global];pis=If[Length[path]>=2,Table[global[path[[i]]\[UndirectedEdge]path[[i+1]]],{i,Length[path]-1}],{}];pos=GraphEmbedding[graph,"SpringElectricalEmbedding"];panel:=DynamicModule[{step=1},Panel[Column[{Style["Frame Forwarding Simulation",Bold,16],Dynamic[Grid[{{"Step",step},{"Current Node",If[path=!={},lbl[path[[step]]],"\[LongDash]"]},{"Remaining PIS",Drop[pis,step-1]}},Alignment->Left]],Dynamic[Graph[graph,VertexCoordinates->pos,VertexLabels->(lbl[#1]&),EdgeStyle->(If[path=!={}&&step<=Length[pis]&&global[#1]===pis[[step]],Red,Gray]&)/@edges,ImageSize->400,PlotLabel->Style[If[path==={},"No path found",If[step<=Length[pis],"Forwarding tag "<>ToString[pis[[step]]],"Destination reached"]],Bold,14]]],Row[{Button["Previous",If[step>1,step--]],Spacer[20],Button["Next",If[step<Length[pis]+1,step++]]}]}]]];Column[{Style["4.13 Protocol \[Dash] Visualisation",Bold,20],Spacer[8],Style["Initialisation Phase (Stable Edge Tags)",Bold,14],Graph[graph,VertexCoordinates->pos,VertexLabels->(lbl[#1]&),EdgeStyle->(palette[[global[#1]+1]]&)/@edges,ImageSize->Large],Spacer[15],Style["Path Discovery Phase",Bold,14],Grid[{{"Path nodes",path},{"PIS",pis}},Alignment->Left],Spacer[15],Style["Frame Forwarding Phase",Bold,14],panel}]]


Module[{fields={{"Destination MAC",6,"Standard MAC"},{"Source MAC",6,"Standard MAC"},{"Type/PIS Identifier",2,"Ethertype or custom"},{"Path Identifier Sequence",12,"Encoded tag list (variable size shown as 12 bytes)"},{"Payload",30,"As usual (variable size, example 30 bytes)"},{"FCS",4,"Standard CRC"}},totalLength,scaleFactor=20,rectangles,labels,notes},totalLength=Total[fields[[All,2]]];rectangles={};labels={};notes={};Module[{xpos=0},Do[Module[{width=fields[[i,2]] scaleFactor,name=fields[[i,1]],size=fields[[i,2]],note=fields[[i,3]]},AppendTo[rectangles,Rectangle[{xpos,0},{xpos+width,2}]];AppendTo[labels,Text[Style[Row[{name,"\n",size," bytes"}],14,Bold,Black],{xpos+width/2,1.2}]];AppendTo[notes,Text[Style[note,11,GrayLevel[0.4],Italic],{xpos+width/2,-1}]];xpos+=width;],{i,Length[fields]}];];Graphics[{LightBlue,EdgeForm[Black],rectangles,Black,labels,Darker[Gray,0.5],notes},ImageSize->{totalLength scaleFactor+150,180},PlotRange->{{0,totalLength scaleFactor+30},{-2,3}},Axes->False,Background->White,PlotLabel->Style["4.14 Frame Format Visualization",18,Bold]]]


Module[{nNodes=12,graph,vertices,edges,vertexLabels,layoutSpring,layoutCircular,advantageTexts,advantageGraphics,baseColor=Lighter[Blue,0.7],highlightColor=Orange,panelWidth=800},SeedRandom[2025];graph=RandomGraph[{nNodes,nNodes+5}];While[!ConnectedGraphQ[graph],graph=RandomGraph[{nNodes,nNodes+5}]];vertices=VertexList[graph];edges=EdgeList[graph];vertexLabels=AssociationThread[vertices->"N"<>ToString/@vertices];layoutSpring=GraphEmbedding[graph,"SpringElectricalEmbedding"];layoutCircular=GraphEmbedding[graph,"CircularEmbedding"];advantageTexts={Style["\[Bullet] No need for Layer 3 routing tables",14,Bold],Style["\[Bullet] Supports programmable switching (SmartNICs, eBPF)",14,Bold],Style["\[Bullet] Scales to large networks with sparse connectivity",14,Bold],Style["\[Bullet] Deterministic pathing avoids congestion and loops",14,Bold]};advantageGraphics=GraphicsGrid[{{Graphics[{Style[Line/@(layoutSpring[[#1]]&)/@List@@@edges,baseColor,Thick],MapIndexed[Style[Disk[layoutSpring[[#1]],0.12],Black,EdgeForm[Directive[Black,Thick]]]&,vertices],MapIndexed[Text[vertexLabels[#1],layoutSpring[[#2[[1]]]]+{0,0.15}]&,vertices]},PlotRange->{{-1.5,1.5},{-1.5,1.5}},ImageSize->350,Background->LightGray,Frame->True,FrameLabel->Style["Sparse Network Connectivity",16,Bold]],Graphics[{Style[Arrowheads[0.03],Orange,Thick],Arrow[{layoutCircular[[1]],layoutCircular[[4]]}],Arrow[{layoutCircular[[4]],layoutCircular[[7]]}],Arrow[{layoutCircular[[7]],layoutCircular[[10]]}],Arrow[{layoutCircular[[10]],layoutCircular[[12]]}],MapIndexed[Style[Disk[layoutCircular[[#1]],0.12],Black,EdgeForm[Directive[Black,Thick]]]&,Range[nNodes]],MapIndexed[Text[vertexLabels[#1],layoutCircular[[#2[[1]]]]+{0,0.15}]&,Range[nNodes]],Text[Style["Example Deterministic Path",16,Orange,Bold],{0,-1.4}]},PlotRange->{{-1.5,1.5},{-1.5,1.5}},ImageSize->350,Background->LightGray,Frame->True]}}];Column[{Style["4.15 Advantages of the Layer 2 Scouting Protocol",Bold,20],Spacer[15],Grid[Table[{advantageTexts[[i]]},{i,Length[advantageTexts]}],Alignment->Left,Spacings->{1,2}],Spacer[20],advantageGraphics}]]


Module[{advantages={"No need for Layer 3 routing tables","Supports programmable switching (e.g., in SmartNICs or eBPF)","Scales to large networks with sparse connectivity","Deterministic pathing avoids congestion and loops"},circleRadius=1,nAdvantages,angles,points,graphicsElements,labels,center={0,0}},nAdvantages=Length[advantages];angles=Table[(2 \[Pi] i)/nAdvantages,{i,0,nAdvantages-1}];points=(center+circleRadius {Cos[#1],Sin[#1]}&)/@angles;graphicsElements=Table[{EdgeForm[Black],LightBlue,Disk[points[[i]],0.5],Black,Text[Style[Row[{i,". ",advantages[[i]]}],Medium,Bold,Black,FontFamily->"Arial"],points[[i]],{0,0}]},{i,nAdvantages}];Graphics[{Darker[Blue,0.4],Disk[center,1.2],White,Text[Style["Advantages of the Protocol",16,Bold,FontFamily->"Arial"],center],graphicsElements,Table[{GrayLevel[0.5],Thick,Line[{center,points[[i]]}]},{i,nAdvantages}]},ImageSize->500,PlotRange->{{-2,2},{-2,2}},Background->Lighter[Gray,0.9],Frame->False,Axes->False]]


Module[{advantages={"No need for Layer 3 routing tables","Supports programmable switching (e.g., SmartNICs, eBPF)","Scales to large networks with sparse connectivity","Deterministic pathing avoids congestion and loops"},iconSize=50,iconSpacing=70,textOffset=60,positions,icons,iconShapes},positions=Table[{0,-i iconSpacing},{i,Length[advantages]}];iconShapes={Graphics[{Blue,Disk[{0,0},iconSize/3],Black,Text[Style["L3",20,Bold,White],{0,0}]}],Graphics[{Green,Rectangle[{-(iconSize/3),-(iconSize/4)},{iconSize/3,iconSize/4}],Black,Text[Style["eBPF",16,Bold,White],{0,0}]}],Graphics[{Orange,Polygon[{{-(iconSize/3),-(iconSize/4)},{iconSize/3,0},{-(iconSize/3),iconSize/4}}],Black,Text[Style["Scale",16,Bold,White],{0,0}]}],Graphics[{Red,Circle[{0,0},iconSize/3,{0,\[Pi]}],Black,Text[Style["Deterministic",12,Bold,White],{0,0}]}]};Graphics[{Table[{EdgeForm[None],Inset[iconShapes[[i]],positions[[i]],Center],Black,Text[Style[advantages[[i]],16,Bold,Black],positions[[i]]+{textOffset,0}]},{i,Length[advantages]}]},ImageSize->600,PlotRange->{{-50,450},{-iconSpacing (Length[advantages]-1)-40,40}},Background->Lighter[Gray,0.95]]]


Module[{advantages={"No need for Layer 3 routing tables.","Supports programmable switching (e.g., in SmartNICs or eBPF).","Scales to large networks with sparse connectivity.","Deterministic pathing avoids congestion and loops."},bullet=Style["\[FilledCircle]",14,Black],styledList},styledList=Grid[Table[{bullet,Style[advantages[[i]],14,Black]},{i,Length[advantages]}],Alignment->{Left,Top},Spacings->{0.5,1}];Panel[Column[{Style["4.15 Advantages",20,Bold,Black,FontFamily->"Arial"],Spacer[10],styledList}],ImageSize->500,Background->LightYellow,FrameStyle->Directive[GrayLevel[0.7],Thick],BaseStyle->{FontFamily->"Arial"}]]


Module[{nNodes=10,edgesCount=15,graph,vertices,edges,maxDegree,palette,localTags,globalTags,MTU=1500,tagSize=2,maxPISLength,examplePISLength,tagConflicts,resolvedTags,changedGraph,newGlobalTags,layout,coloredGraph,pathSeq,PIS},SeedRandom[2025];graph=RandomGraph[{nNodes,edgesCount}];While[!ConnectedGraphQ[graph],graph=RandomGraph[{nNodes,edgesCount}]];vertices=VertexList[graph];edges=EdgeList[graph];maxDegree=Max[VertexDegree[graph]];palette=Table[ColorData["Rainbow"][i/(maxDegree+1)],{i,0,maxDegree}];assignLocalTags[g_Graph]:=Module[{assign=Association[],adjEdges},adjEdges=Association[Table[v->Select[EdgeList[g],MemberQ[List@@#1,v]&],{v,VertexList[g]}]];Do[Module[{usedColors={}},Do[Module[{availColors=Complement[Range[maxDegree+1],usedColors]},assign[e]=First[availColors];AppendTo[usedColors,assign[e]];],{e,adjEdges[v]}];],{v,VertexList[g]}];assign];localTags=assignLocalTags[graph];gossipTags[tags_Association,rounds_:5]:=Module[{currentTags=tags,updatedTags,changed},Do[changed=False;updatedTags=currentTags;Do[Do[Module[{conflicts},conflicts=Select[Select[EdgeList[graph],MemberQ[List@@#1,v]&],currentTags[#1]===currentTags[edge]&&#1=!=edge&];If[Length[conflicts]>0,updatedTags[edge]=updatedTags[edge]+1;changed=True;]],{edge,Select[EdgeList[graph],MemberQ[List@@#1,v]&]}],{v,VertexList[graph]}];currentTags=updatedTags;If[!changed,Break[]],{round,rounds}];currentTags];globalTags=gossipTags[localTags];maxPISLength=Floor[MTU/tagSize];examplePISLength=Min[maxPISLength,50];examplePIS=Table[RandomInteger[{1,maxDegree+1}],{examplePISLength}];tagConflicts=Association[Take[globalTags,3]];tagConflicts[edges[[1]]]=tagConflicts[edges[[2]]];resolvedTags=Module[{tags=tagConflicts},Do[If[Count[Values[tags],tags[e]]>1,tags[e]=tags[e]+1;],{e,Keys[tags]}];tags];changedGraph=EdgeDelete[graph,edges[[1]]];newGlobalTags=gossipTags[assignLocalTags[changedGraph]];layout=GraphEmbedding[graph,"SpringElectricalEmbedding"];Column[{Style["4.16 Challenges Visualization",Bold,20],Spacer[10],Style["Challenge 1: Path Identifier Sequence (PIS) Length Limited by MTU",Bold,14],TextCell[StringForm["MTU = `` bytes, Tag Size = `` bytes, Max PIS Length = `` tags", MTU, tagSize, maxPISLength],"Text",LineIndent->20],TextCell[StringForm["Example PIS Length Used in Frame: `` tags", examplePISLength],"Text",LineIndent->20],BarChart[ConstantArray[1,examplePISLength],ChartStyle->ColorData["Rainbow"]/@examplePIS,ChartLabels->None,ImageSize->Large,PlotLabel->"Example PIS (Color-coded tags)"],Spacer[20],Style["Challenge 2: Coordination to Avoid Tag Conflicts",Bold,14],Grid[{{"Initial Tags with Conflict (first 3 edges)",Normal[tagConflicts]},{"Resolved Tags after Coordination",Normal[resolvedTags]}},Alignment->Left],Spacer[20],Style["Challenge 3: Topology Changes Require Propagation of New Tags",Bold,14],Row[{"Original Graph: ",Graph[graph,VertexLabels->"Name",GraphLayout->"SpringElectricalEmbedding",ImageSize->300]}],Row[{"Changed Graph (Edge Removed): ",Graph[changedGraph,VertexLabels->"Name",GraphLayout->"SpringElectricalEmbedding",ImageSize->300]}],TextCell[StringForm["Updated tags propagated after topology change (first 5 edges):\n``", Take[Normal[newGlobalTags], 5]],"Text",LineIndent->20]}]]


Module[{challenges={"Path sequence length is limited by MTU","Requires coordination to avoid inconsistent tag assignment","Topology changes require propagation of new path info"},nChallenges,angles,points,center={0,0},radius=1.5,graphicsElements},nChallenges=Length[challenges];angles=Table[(2 \[Pi] i)/nChallenges,{i,0,nChallenges-1}];points=(center+radius {Cos[#1],Sin[#1]}&)/@angles;graphicsElements=Table[{EdgeForm[Black],Lighter[Red,0.6],Disk[points[[i]],0.6],Black,Text[Style[Row[{i,". ",challenges[[i]]}],14,Bold,Black,FontFamily->"Arial",LineIndent->0],points[[i]],{0,0}]},{i,nChallenges}];Graphics[{Darker[Red,0.4],Disk[center,1.3],White,Text[Style["Challenges",18,Bold,FontFamily->"Arial"],center],graphicsElements,Table[{GrayLevel[0.4],Thick,Line[{center,points[[i]]}]},{i,nChallenges}]},ImageSize->500,PlotRange->{{-3,3},{-3,3}},Background->Lighter[Gray,0.9],Frame->False,Axes->False]]


Module[{challenges={"Path sequence length limited by MTU","Requires coordination to avoid inconsistent tag assignment","Topology changes require propagation of new path info"},iconSize=50,iconSpacing=70,textOffset=60,positions,iconShapes},positions=Table[{0,-i iconSpacing},{i,Length[challenges]}];iconShapes={Graphics[{Orange,Style[Rectangle[{-(iconSize/3),-(iconSize/4)},{iconSize/3,iconSize/4}],LightOrange,EdgeForm[Black]],Text[Style["MTU",20,Bold,Black],{0,0}]}],Graphics[{Red,Style[Circle[{0,0},iconSize/3],LightRed,EdgeForm[Black]],Text[Style["Coord.",16,Bold,Black],{0,0}]}],Graphics[{Blue,Style[Polygon[{{-(iconSize/3),-(iconSize/4)},{iconSize/3,0},{-(iconSize/3),iconSize/4}}],LightBlue,EdgeForm[Black]],Text[Style["Topology",14,Bold,Black],{0,0}]}]};Graphics[Table[{EdgeForm[None],Inset[iconShapes[[i]],positions[[i]],Center],Black,Text[Style[challenges[[i]],16,Bold,Black],positions[[i]]+{textOffset,0}]},{i,Length[challenges]}],ImageSize->600,PlotRange->{{-50,450},{-iconSpacing (Length[challenges]-1)-40,40}},Background->Lighter[Gray,0.95]]]


Module[{challenges={"Path sequence length is limited by MTU.","Requires coordination to avoid inconsistent tag assignment.","Topology changes require propagation of new path info."},bullet=Style["\[FilledCircle]",14,Black],styledList},styledList=Grid[Table[{bullet,Style[challenges[[i]],14,Black]},{i,Length[challenges]}],Alignment->{Left,Top},Spacings->{0.5,1}];Panel[Column[{Style["4.16 Challenges",20,Bold,Black,FontFamily->"Arial"],Spacer[10],styledList}],ImageSize->600,Background->LightRed,FrameStyle->Directive[GrayLevel[0.7],Thick],BaseStyle->{FontFamily->"Arial"}]]


Module[{hpcSize=3,hpcGraph,hpcCoords,edgeZoneCenter=1,edgeZoneSize=12,edgeZoneGraph,dcOverlayNodes=20,dcOverlayEdges=40,dcOverlayGraph,hpcLabels,edgeZoneLabels,dcOverlayLabels,hpcLayout,edgeZoneLayout,dcOverlayLayout},SeedRandom[2025];hpcGraph=Graph[Join[Join[Flatten[Table[If[x<hpcSize,ToString[{x,y,z}]\[UndirectedEdge]ToString[{x+1,y,z}],Nothing],{x,hpcSize},{y,hpcSize},{z,hpcSize}],3],Flatten[Table[If[y<hpcSize,ToString[{x,y,z}]\[UndirectedEdge]ToString[{x,y+1,z}],Nothing],{x,hpcSize},{y,hpcSize},{z,hpcSize}],3]],Flatten[Table[If[z<hpcSize,ToString[{x,y,z}]\[UndirectedEdge]ToString[{x,y,z+1}],Nothing],{x,hpcSize},{y,hpcSize},{z,hpcSize}],3]],VertexLabels->"Name"];hpcCoords=Association[(Flatten[#1,2]&)[Table[ToString[{x,y,z}]->{x,y,z},{x,hpcSize},{y,hpcSize},{z,hpcSize}]]];edgeZoneGraph=Graph[Prepend[Table[ToString[i],{i,2,edgeZoneSize+1}],"Center"],UndirectedEdge@@@Table[{"Center",ToString[i]},{i,2,edgeZoneSize+1}],VertexLabels->"Name"];edgeZoneLayout=Association[Join[{"Center"->{0,0}},Table[ToString[i]->{Cos[(2 \[Pi] i)/edgeZoneSize],Sin[(2 \[Pi] i)/edgeZoneSize]},{i,1,edgeZoneSize}]]];dcOverlayGraph=RandomGraph[{dcOverlayNodes,dcOverlayEdges},VertexLabels->"Name"];dcOverlayLayout=GraphEmbedding[dcOverlayGraph,"SpringElectricalEmbedding"];dcOverlayLabels=AssociationThread[VertexList[dcOverlayGraph]->"Node-"<>ToString/@VertexList[dcOverlayGraph]];Column[{Style["4.17 Applications Visualization",Bold,20],Spacer[10],Style["HPC Clusters: Low-Latency 3D Mesh Topology",Bold,16],Graph[hpcGraph,VertexCoordinates->hpcCoords,VertexLabels->Placed["Name",Center],GraphStyle->"NameLabeled",ImageSize->400],Spacer[20],Style["Edge Compute Zones: Fixed Star Topology",Bold,16],Graph[edgeZoneGraph,VertexCoordinates->edgeZoneLayout,VertexLabels->Placed["Name",Center],GraphStyle->"NameLabeled",ImageSize->400],Spacer[20],Style["Datacenter Overlays: Random Network (IP Inefficient/Unavailable)",Bold,16],Graph[dcOverlayGraph,VertexCoordinates->dcOverlayLayout,VertexLabels->dcOverlayLabels,GraphStyle->"NameLabeled",ImageSize->500]}]]


Module[{hpcCluster,edgeComputeZone,datacenterOverlay,hpcLabels,edgeLabels,dcLabels,hpcLayout,edgeLayout,dcLayout,descStyle={FontSize->14,FontColor->Darker[Gray]},macLabels,drawNetwork},SeedRandom[2025];macLabels[n_]:=Table["MAC-"<>IntegerString[i,10,3],{i,n}];hpcCluster=RandomGraph[{12,30}];While[!ConnectedGraphQ[hpcCluster],hpcCluster=RandomGraph[{12,30}]];hpcLabels=AssociationThread[VertexList[hpcCluster]->macLabels[VertexCount[hpcCluster]]];hpcLayout=GraphEmbedding[hpcCluster,"SpringElectricalEmbedding"];edgeComputeZone=Graph[{"A1", "A2", "A3", "B1", "B2", "B3"}, {UndirectedEdge["A1", "A2"], UndirectedEdge["A1", "A3"], UndirectedEdge["A2", "A3"], UndirectedEdge["B1", "B2"], UndirectedEdge["B2", "B3"], UndirectedEdge["B1", "B3"], UndirectedEdge["A1", "B1"], UndirectedEdge["A2", "B2"], UndirectedEdge["A3", "B3"]}, {VertexLabels -> {"Name"}}];edgeLabels=AssociationThread[VertexList[edgeComputeZone]->macLabels[VertexCount[edgeComputeZone]]];edgeLayout=GraphEmbedding[edgeComputeZone,"SpringElectricalEmbedding"];datacenterOverlay=RandomGraph[{10,12}];While[!ConnectedGraphQ[datacenterOverlay],datacenterOverlay=RandomGraph[{10,12}]];dcLabels=AssociationThread[VertexList[datacenterOverlay]->macLabels[VertexCount[datacenterOverlay]]];dcLayout=GraphEmbedding[datacenterOverlay,"SpringElectricalEmbedding"];drawNetwork[g_,labels_,layout_,title_,desc_]:=Column[{Style[title,Bold,16],Graph[g,VertexLabels->(labels[#1]&),VertexCoordinates->layout,ImageSize->400,GraphLayout->"SpringElectricalEmbedding"],Style[desc,descStyle],Spacer[15]}];Column[{drawNetwork[hpcCluster,hpcLabels,hpcLayout,"HPC Cluster Mesh Topology","Dense, low-latency mesh network ideal for high-performance computing clusters."],drawNetwork[edgeComputeZone,edgeLabels,edgeLayout,"Edge Compute Zone with Fixed Link-Layer Infrastructure","Hierarchical clusters with fixed MAC-layer links supporting programmable switching."],drawNetwork[datacenterOverlay,dcLabels,dcLayout,"Datacenter Overlay Network","Sparse overlay topology where IP routing is inefficient or unavailable, relying on Layer 2 deterministic paths."]}]]


Module[{applications={"HPC clusters with low-latency mesh topologies","Edge compute zones with fixed link-layer infrastructure","Datacenter overlays where IP is inefficient or unavailable"},nApps,angles,points,center={0,0},radius=1.7,graphicsElements},nApps=Length[applications];angles=Table[(2 \[Pi] i)/nApps,{i,0,nApps-1}];points=(center+radius {Cos[#1],Sin[#1]}&)/@angles;graphicsElements=Table[{EdgeForm[Black],Lighter[Green,0.6],Disk[points[[i]],0.65],Black,Text[Style[Row[{i,". ",applications[[i]]}],14,Bold,Black,FontFamily->"Arial",LineIndent->0],points[[i]],{0,0}]},{i,nApps}];Graphics[{Darker[Green,0.45],Disk[center,1.4],White,Text[Style["Applications",18,Bold,FontFamily->"Arial"],center],graphicsElements,Table[{GrayLevel[0.4],Thick,Line[{center,points[[i]]}]},{i,nApps}]},ImageSize->520,PlotRange->{{-3,3},{-3,3}},Background->Lighter[Gray,0.9],Frame->False,Axes->False]]


Module[{applications={"HPC clusters with low-latency mesh topologies.","Edge compute zones with fixed link-layer infrastructure.","Datacenter overlays where IP is inefficient or unavailable."},bullet=Style["\[FilledCircle]",14,Black],styledList},styledList=Grid[Table[{bullet,Style[applications[[i]],14,Black]},{i,Length[applications]}],Alignment->{Left,Top},Spacings->{0.5,1}];Panel[Column[{Style["4.17 Applications",20,Bold,Black,FontFamily->"Arial"],Spacer[10],styledList}],ImageSize->600,Background->LightBlue,FrameStyle->Directive[GrayLevel[0.7],Thick],BaseStyle->{FontFamily->"Arial"}]]


Module[{nNodes=12,edgeCount=25,graph,vertices,edges,maxDegree,palette,edgeColors,src,dst,path,layout,coloredGraph,conclusionText},SeedRandom[2025];graph=RandomGraph[{nNodes,edgeCount}];While[!ConnectedGraphQ[graph],graph=RandomGraph[{nNodes,edgeCount}]];vertices=VertexList[graph];edges=EdgeList[graph];maxDegree=Max[VertexDegree[graph]];palette=Table[ColorData["Rainbow"][i/(maxDegree+1)],{i,0,maxDegree}];edgeColors=Module[{assign=Association[],adjEdges},adjEdges=Association[Table[v->Select[EdgeList[graph],MemberQ[List@@#1,v]&],{v,vertices}]];Do[Module[{usedColors={}},Do[Module[{availColors=Complement[Range[maxDegree+1],usedColors]},assign[e]=First[availColors];AppendTo[usedColors,assign[e]];],{e,adjEdges[v]}];],{v,vertices}];assign];src=RandomChoice[vertices];dst=RandomChoice[DeleteCases[vertices,src]];path=FindShortestPath[graph,src,dst];layout=GraphEmbedding[graph,"SpringElectricalEmbedding"];coloredGraph=Graph[graph,EdgeStyle->Thread[edges->(palette[[edgeColors[#1]]]&)/@edges],VertexLabels->Placed["Name",Center],GraphLayout->"SpringElectricalEmbedding",ImageSize->600,GraphHighlight->path,GraphHighlightStyle->Directive[Black,Thick]];conclusionText=Column[{Style["Conclusion",Bold,20],Style["Scouting at Layer 2 leverages recent edge-coloring advances for deterministic path discovery and forwarding.",Italic,14],Style["This approach offers a robust, scalable, and efficient MAC-layer routing solution.",Italic,14],Style["It is especially well-suited for programmable and high-performance networking environments such as SmartNICs and HPC clusters.",Italic,14]},Alignment->Left];Column[{coloredGraph,Spacer[20],conclusionText}]]


Module[{conclusionText="By leveraging edge-coloring strategies for deterministic path discovery and forwarding, Scouting at Layer 2 offers a novel approach to MAC-layer routing. Its foundation in recent algorithmic advances such as those by Li et al. provides a robust and efficient scheme, particularly suited to programmable and high-performance environments.",bgColor=Lighter[Gray,0.95],titleStyle={Bold,18,Darker[Blue]},bodyStyle={FontFamily->"Arial",14},stopWords,words,tallies,maxCnt,scale,cloud},stopWords={"the","and","to","of","a","in","as","by","such","its","at","for","is","on","with"};words=StringSplit[ToLowerCase[conclusionText],Except[LetterCharacter]..];tallies=Select[Tally[words],!MemberQ[stopWords,#1[[1]]]&];maxCnt=Max[tallies[[All,2]]];scale[c_]:=Rescale[c,{1,maxCnt},{0.8,2}];cloud=Graphics[Table[Text[Style[tallies[[i,1]],FontSize->12 scale[tallies[[i,2]]],FontFamily->"Arial",Darker[Blue,.3]],RandomReal[{-3,3},2]],{i,Length[tallies]}],ImageSize->400,Background->bgColor,PlotRange->4,Axes->False,Frame->False];FramedParagraph=Framed[Pane[Style[conclusionText,bodyStyle,LineSpacing->1.2],{400,150},Scrollbars->True],FrameStyle->Directive[Thick,Darker[Blue]],Background->Lighter[Blue,0.9]];Grid[{{Style["4.18 Conclusion",(##1&)@@titleStyle]},{FramedParagraph},{Spacer[15]},{Style["Keyword Word Cloud (auto-extracted)",Bold,14]},{cloud}},Alignment->Center]]


Module[{title="4.18 Conclusion",conclusionText={"Scouting at Layer 2 leverages edge-coloring strategies for deterministic path discovery and forwarding.","This novel MAC-layer routing approach is grounded in recent algorithmic advances (e.g., Li et al.) providing robustness and efficiency.","It is especially well-suited for programmable and high-performance network environments."},bgColor=Lighter[Blue,0.9],textColor=Darker[Blue,0.7],iconSize=120,edgeColoringIcon,textPos={0,-150},iconPos={0,0}},edgeColoringIcon=Graphics[{Table[{ColorData[97,"ColorList"][[i]],Thick,Circle[{0,0},50-i 8],Text[Style[ToString[i],Bold,7,White],{0,50-i 8}]},{i,1,5}]},ImageSize->iconSize];Graphics[{bgColor,EdgeForm[None],Rectangle[{-350,-250},{350,80}],Text[Style[title,Bold,7,textColor],{0,20}],Text[Style[Row[Riffle[conclusionText,"\n\n"]],7,textColor,FontFamily->"Helvetica",LineSpacing->1.5],textPos,{0,1}],Inset[edgeColoringIcon,iconPos]},ImageSize->700,PlotRange->{{-400,400},{-260,90}},Background->White]]


Module[{n=8,N=4,states,forwardStates,rollbackStates,masks,xorVec,applyTransformation,applyInverseTransformation,formatVec,visualizeStates,acknowledgments,step=0,maxStep,dyn},SeedRandom[1234];states=Table[ConstantArray[0,n],{i,0,N}];masks=Table[RandomInteger[{0,1},n],{i,1,N}];xorVec[v1_,v2_]:=Mod[v1+v2,2];applyTransformation[S_,mask_]:=xorVec[S,mask];applyInverseTransformation[S_,mask_]:=xorVec[S,mask];forwardStates=Table[Null,{N+1}];forwardStates[[1]]=states[[1]];Do[forwardStates[[i+1]]=applyTransformation[forwardStates[[i]],masks[[i]]],{i,1,N}];rollbackStates=Table[Null,{N+1}];rollbackStates[[N+1]]=forwardStates[[N+1]];Do[rollbackStates[[i]]=applyInverseTransformation[rollbackStates[[i+1]],masks[[i]]],{i,N,1,-1}];maxStep=2 N+2;formatVec[v_]:=StringJoin[ToString/@v];visualizeStates[currentStep_]:=Module[{displayStates,acknowledgments},displayStates=Table[Which[currentStep<=N+1,If[i<=currentStep-1,forwardStates[[i]],states[[i]]],currentStep>N+1,If[i>=N+2-(currentStep-(N+1)),rollbackStates[[i]],forwardStates[[i]]],True,states[[i]]],{i,1,N+1}];acknowledgments=Table[Which[currentStep<=N+1,i<=currentStep-1,currentStep>N+1,i>=N+2-(currentStep-(N+1)),True,False],{i,1,N+1}];Grid[Prepend[Table[{Style["Node A"<>ToString[i-1],Bold],Style[formatVec[displayStates[[i]]],FontFamily->"Courier",16],If[acknowledgments[[i]],Style["\:2714",Green,Bold,18],Style["\:2718",Red,Bold,18]]},{i,1,N+1}],{"Node","State Vector","Ack"}],Frame->All,ItemSize->{{8,16,3}}]];dyn=DynamicModule[{step=0},Column[{Style["Reversible Transactions Simulation",Bold,20],Dynamic[Column[{visualizeStates[step],Spacer[10],Style[Which[step==0,"Initial states before any transaction",step<=N+1,"Forward Execution: Applying transformations down the chain",step==N+2,"All forward transformations applied",step<=maxStep,"Rollback Execution: Applying inverse transformations up the chain",True,"Transaction fully rolled back"],Italic,14],Spacer[10],Row[{Button["Previous",If[step>0,step--],ImageSize->Medium],Spacer[20],Button["Next",If[step<maxStep,step++],ImageSize->Medium],Spacer[20],Style[Row[{"Step: ",Dynamic[step],"/",maxStep}],Bold]}]}]]}]];dyn]


Module[{n=8,N=5,states,initialState,transformations,inverses,xorMasks,forwardStates,rollbackStates,acknowledgments,showVector,showTransformation,nodes,step=1},SeedRandom[2025];nodes=Table["A"<>ToString[i],{i,0,N}];initialState=ConstantArray[0,n];states=AssociationThread[nodes->ConstantArray[initialState,Length[nodes]]];xorMasks=Table[RandomInteger[{0,1},n],{N}];applyXORMask[vec_,mask_]:=Mod[vec+mask,2];forwardStates=states;Do[forwardStates[nodes[[i+1]]]=applyXORMask[forwardStates[nodes[[i+1]]],xorMasks[[i]]];forwardStates[nodes[[i]]]=applyXORMask[forwardStates[nodes[[i]]],xorMasks[[i]]];,{i,1,N}];rollbackStates=forwardStates;Do[rollbackStates[nodes[[i]]]=applyXORMask[rollbackStates[nodes[[i]]],xorMasks[[i]]];rollbackStates[nodes[[i+1]]]=applyXORMask[rollbackStates[nodes[[i+1]]],xorMasks[[i]]];,{i,N,1,-1}];acknowledgments=AssociationThread[nodes,Table[If[i==0,False,True],{i,0,N}]];showVector[vec_]:=Row[(Style[ToString[#1],Bold]&)/@vec," "];showTransformation[i_]:=Row[{"Mask \[Delta]_",ToString[i],": ",showVector[xorMasks[[i]]]}];DynamicModule[{currentStep=1,forwardPhase=True},Column[{Style["5. Reversible Transactions Visualization",Bold,20],Spacer[10],Style["Initial State (All zero vector) at each node:",Bold,14],Grid[Table[{nodes[[i]],showVector[initialState]},{i,Length[nodes]}],Alignment->Left],Spacer[10],Dynamic[If[forwardPhase,Style["Forward Execution Phase: Applying Masks Along Chain",Bold,16,Darker[Green]],Style["Rollback Phase: Reverting Transformations",Bold,16,Darker[Red]]]],Spacer[5],Dynamic[Grid[Table[With[{node=nodes[[i]]},{node,If[forwardPhase,If[i<=currentStep+1,showVector[forwardStates[node]],Style["--",Gray]],If[i>=N-currentStep,showVector[rollbackStates[node]],Style["--",Gray]]]}],{i,Length[nodes]}],Alignment->Left]],Spacer[10],Dynamic[If[forwardPhase,If[currentStep<=N,showTransformation[currentStep],Style["Forward phase complete. Switch to rollback.",Italic]],If[currentStep>=1,showTransformation[currentStep],Style["Rollback phase complete.",Italic]]]],Spacer[10],Row[{Button["Prev",If[currentStep>1,currentStep--;If[forwardPhase&&currentStep==0,currentStep=1];If[!forwardPhase&&currentStep==0,currentStep=1];],Enabled->Dynamic[currentStep>1]],Spacer[20],Button["Next",If[forwardPhase,If[currentStep<N,currentStep++,forwardPhase=False;currentStep=N;],If[currentStep>1,currentStep--]],Enabled->Dynamic[If[forwardPhase,currentStep<N||True,currentStep>1]]],Spacer[40],Button[Dynamic[If[forwardPhase,"Switch to Rollback","Switch to Forward"]],forwardPhase=!forwardPhase;currentStep=If[forwardPhase,1,N];]}]}]]]


Module[{n=8,N=3,S0,Sforward,Srollback,masks,showBitVector,showMask,forwardRows,rollbackRows},S0=ConstantArray[0,{N+1,n}];SeedRandom[1234];masks=RandomInteger[{0,1},{N,n}];xor[u_,v_]:=BitXor[u,v];Sforward=S0;Do[Sforward[[i]]=xor[Sforward[[i]],masks[[i]]];Sforward[[i+1]]=xor[Sforward[[i+1]],masks[[i]]],{i,N}];Srollback=Sforward;Do[Srollback[[i+1]]=xor[Srollback[[i+1]],masks[[i]]];Srollback[[i]]=xor[Srollback[[i]],masks[[i]]],{i,N,1,-1}];showBitVector[vec_List]:=Graphics[Table[{If[vec[[j]]==1,Darker[Blue],GrayLevel[0.85]],Rectangle[{(j-1)/n,0},{j/n,1}]},{j,n}],ImageSize->140,PlotRange->{{0,1},{0,1}},Axes->False];showMask[mask_List]:=Style["Mask: "<>StringJoin[ToString/@mask],11,Bold,Darker[Red]];forwardRows=Table[{"Link "<>ToString[i],showMask[masks[[i]]],showBitVector[S0[[i]]],"\[RightArrow]",showBitVector[Sforward[[i+1]]]},{i,1,N}];rollbackRows=Table[{"Link "<>ToString[i],showMask[masks[[i]]],showBitVector[Sforward[[i+1]]],"\[RightArrow]",showBitVector[S0[[i]]]},{i,N,1,-1}];DynamicModule[{step=0,max=N},Panel[Column[{Style["5. Reversible Transactions \[Dash] XOR Mask Example",17,Bold],Spacer[8],Style["Initial states (all 0):",Bold,13],Grid[Table[{"Node A"<>ToString[i],showBitVector[S0[[i+1]]]},{i,0,N}]],Spacer[15],Style["Forward execution",Bold,13],Dynamic[Grid[Take[forwardRows,step],Alignment->Left]],Row[{Button["Prev",If[step>0,step--]],Spacer[6],Button["Next",If[step<max,step++]]}],Spacer[20],Style["Rollback execution",Bold,13],Dynamic[Grid[Take[rollbackRows,step],Alignment->Left]],Row[{Button["Prev",If[step>0,step--]],Spacer[6],Button["Next",If[step<max,step++]]}]},FrameMargins->15,ImageSize->700]]]]


Module[{nodes={"Coordinator","Participant1","Participant2"},colors=Association["Coordinator"->LightBlue,"Participant1"->LightGreen,"Participant2"->LightGreen],edgeOpts={Arrowheads[0.03],Thick},styles,onePhaseGraph,twoPhaseGraph,fourPhaseGraph,onePhaseTimeline,twoPhaseTimeline,fourPhaseTimeline,timelineHeight=2,timelineSpacing=1,msgStyle={Black,Bold,FontSize->12}},styles=MapThread[#1->Style[#1,Background->#2,Frame->True,FrameStyle->Directive[Black,Thick],RoundingRadius->5,Padding->10]&,{nodes,Lookup[colors,nodes]}];onePhaseGraph=Rasterize[Graph[nodes,{DirectedEdge["Coordinator","Participant1","Commit"],DirectedEdge["Coordinator","Participant2","Commit"]},VertexLabels->styles,EdgeLabels->Placed[{"Commit","Commit"},Center],GraphLayout->{"LayeredDigraphEmbedding","Orientation"->LeftToRight},ImageSize->400,EdgeStyle->edgeOpts]];onePhaseTimeline=Graphics[{Style[Line[{{0,timelineHeight},{8,timelineHeight}}],Gray,Dashed],Style[Line[{{0,timelineHeight-timelineSpacing},{8,timelineHeight-timelineSpacing}}],Gray,Dashed],Style[Line[{{0,timelineHeight+timelineSpacing},{8,timelineHeight+timelineSpacing}}],Gray,Dashed],Text[Style["Coordinator",Bold,14],{-0.5,timelineHeight+timelineSpacing}],Text[Style["Participant1",Bold,14],{-0.5,timelineHeight}],Text[Style["Participant2",Bold,14],{-0.5,timelineHeight-timelineSpacing}],{Arrowheads[0.03],Blue,Arrow[{{1,timelineHeight+timelineSpacing},{3,timelineHeight}}]},Text[Style["Commit",msgStyle],{2,timelineHeight+0.5}],{Arrowheads[0.03],Blue,Arrow[{{1,timelineHeight+timelineSpacing},{3,timelineHeight-timelineSpacing}}]},Text[Style["Committed",Darker[Green],Bold,12],{7.5,timelineHeight}],Text[Style["Committed",Darker[Green],Bold,12],{7.5,timelineHeight-timelineSpacing}]},PlotRange->{{-1,9},{timelineHeight-2 timelineSpacing,timelineHeight+2 timelineSpacing}},ImageSize->450];twoPhaseGraph=Rasterize[Graph[nodes,{"Coordinator"\[DirectedEdge]"Participant1","Coordinator"\[DirectedEdge]"Participant2","Participant1"\[DirectedEdge]"Coordinator","Participant2"\[DirectedEdge]"Coordinator","Coordinator"\[DirectedEdge]"Participant1","Coordinator"\[DirectedEdge]"Participant2"},VertexLabels->styles,EdgeLabels->Placed[{"Prepare","Prepare","Ack","Ack","Commit","Commit"},Center],GraphLayout->{"LayeredDigraphEmbedding","Orientation"->LeftToRight},ImageSize->500,EdgeStyle->edgeOpts]];twoPhaseTimeline=Graphics[{Style[Line[{{0,timelineHeight},{12,timelineHeight}}],Gray,Dashed],Style[Line[{{0,timelineHeight-timelineSpacing},{12,timelineHeight-timelineSpacing}}],Gray,Dashed],Style[Line[{{0,timelineHeight+timelineSpacing},{12,timelineHeight+timelineSpacing}}],Gray,Dashed],Text[Style["Coordinator",Bold,14],{-0.5,timelineHeight+timelineSpacing}],Text[Style["Participant1",Bold,14],{-0.5,timelineHeight}],Text[Style["Participant2",Bold,14],{-0.5,timelineHeight-timelineSpacing}],{Arrowheads[0.03],Blue,Arrow[{{1,timelineHeight+timelineSpacing},{3,timelineHeight}}]},Text[Style["Prepare",msgStyle],{2,timelineHeight+0.5}],{Arrowheads[0.03],Blue,Arrow[{{1,timelineHeight+timelineSpacing},{3,timelineHeight-timelineSpacing}}]},{Arrowheads[0.03],Red,Dashed,Arrow[{{4,timelineHeight},{6,timelineHeight+timelineSpacing}}]},Text[Style["Ack",msgStyle],{5,timelineHeight+0.5}],{Arrowheads[0.03],Red,Dashed,Arrow[{{4,timelineHeight-timelineSpacing},{6,timelineHeight+timelineSpacing}}]},{Arrowheads[0.03],Blue,Arrow[{{7,timelineHeight+timelineSpacing},{9,timelineHeight}}]},Text[Style["Commit",msgStyle],{8,timelineHeight+0.5}],{Arrowheads[0.03],Blue,Arrow[{{7,timelineHeight+timelineSpacing},{9,timelineHeight-timelineSpacing}}]},Text[Style["Committed",Darker[Green],Bold,12],{11,timelineHeight}],Text[Style["Committed",Darker[Green],Bold,12],{11,timelineHeight-timelineSpacing}]},PlotRange->{{-1,13},{timelineHeight-2 timelineSpacing,timelineHeight+2 timelineSpacing}},ImageSize->550];fourPhaseGraph=Rasterize[Graph[nodes,{"Coordinator"\[DirectedEdge]"Participant1","Coordinator"\[DirectedEdge]"Participant2","Participant1"\[DirectedEdge]"Coordinator","Participant2"\[DirectedEdge]"Coordinator","Coordinator"\[DirectedEdge]"Participant1","Coordinator"\[DirectedEdge]"Participant2","Participant1"\[DirectedEdge]"Coordinator","Participant2"\[DirectedEdge]"Coordinator","Coordinator"\[DirectedEdge]"Participant1","Coordinator"\[DirectedEdge]"Participant2"},VertexLabels->styles,EdgeLabels->Placed[{"Prepare","Prepare","Ack","Ack","PreCommit","PreCommit","Ack2","Ack2","Commit","Commit"},Center],GraphLayout->{"LayeredDigraphEmbedding","Orientation"->LeftToRight},ImageSize->700,EdgeStyle->edgeOpts]];fourPhaseTimeline=Graphics[{Style[Line[{{0,timelineHeight},{18,timelineHeight}}],Gray,Dashed],Style[Line[{{0,timelineHeight-timelineSpacing},{18,timelineHeight-timelineSpacing}}],Gray,Dashed],Style[Line[{{0,timelineHeight+timelineSpacing},{18,timelineHeight+timelineSpacing}}],Gray,Dashed],Text[Style["Coordinator",Bold,14],{-0.5,timelineHeight+timelineSpacing}],Text[Style["Participant1",Bold,14],{-0.5,timelineHeight}],Text[Style["Participant2",Bold,14],{-0.5,timelineHeight-timelineSpacing}],Text[Style["Prepare",msgStyle],{2,timelineHeight+0.5}],{Arrowheads[0.03],Blue,Arrow[{{1,timelineHeight+timelineSpacing},{3,timelineHeight}}]},{Arrowheads[0.03],Blue,Arrow[{{1,timelineHeight+timelineSpacing},{3,timelineHeight-timelineSpacing}}]},Text[Style["Ack",msgStyle],{5,timelineHeight+0.5}],{Arrowheads[0.03],Red,Dashed,Arrow[{{4,timelineHeight},{6,timelineHeight+timelineSpacing}}]},{Arrowheads[0.03],Red,Dashed,Arrow[{{4,timelineHeight-timelineSpacing},{6,timelineHeight+timelineSpacing}}]},Text[Style["PreCommit",msgStyle],{8,timelineHeight+0.5}],{Arrowheads[0.03],Blue,Dotted,Arrow[{{7,timelineHeight+timelineSpacing},{9,timelineHeight}}]},{Arrowheads[0.03],Blue,Dotted,Arrow[{{7,timelineHeight+timelineSpacing},{9,timelineHeight-timelineSpacing}}]},Text[Style["Ack2",msgStyle],{11,timelineHeight+0.5}],{Arrowheads[0.03],Red,Dashed,Arrow[{{10,timelineHeight},{12,timelineHeight+timelineSpacing}}]},{Arrowheads[0.03],Red,Dashed,Arrow[{{10,timelineHeight-timelineSpacing},{12,timelineHeight+timelineSpacing}}]},Text[Style["Commit",msgStyle],{14,timelineHeight+0.5}],{Arrowheads[0.03],Blue,Arrow[{{13,timelineHeight+timelineSpacing},{15,timelineHeight}}]},{Arrowheads[0.03],Blue,Arrow[{{13,timelineHeight+timelineSpacing},{15,timelineHeight-timelineSpacing}}]},Text[Style["Committed",Darker[Green],Bold,12],{17.5,timelineHeight}],Text[Style["Committed",Darker[Green],Bold,12],{17.5,timelineHeight-timelineSpacing}]},PlotRange->{{-1,19},{timelineHeight-2 timelineSpacing,timelineHeight+2 timelineSpacing}},ImageSize->700];Column[{Style["5.2 Atomic Transactions on \[CapitalAE]-Link: Commit Protocol Visualizations",Bold,16],Spacer[10],Style["One-Phase Commit: Immediate, single-broadcast commit without acknowledgment (unsafe in failures).",Italic,12],onePhaseGraph,onePhaseTimeline,Spacer[20],Style["Two-Phase Commit: Prepare and Commit phases with acknowledgments to enforce consensus.",Italic,12],twoPhaseGraph,twoPhaseTimeline,Spacer[20],Style["Four-Phase Commit: Adds PreCommit and additional acknowledgments to enable safe abort and rollback.",Italic,12],fourPhaseGraph,fourPhaseTimeline},Spacings->2]]


Module[{coordinator="Coordinator",participant="Participant",tOnePhase=Range[0,3],tTwoPhase=Range[0,5],tFourPhase=Range[0,7],nodeRadius=0.4,yCoordNodes={1,0},drawNode,drawMessage,drawTimeline,drawOnePhaseCommit,drawTwoPhaseCommit,drawFourPhaseCommit,msgStyle=Directive[Black,Thick,Arrowheads[0.04]],labelStyle=Style[#1,FontSize->12,Bold]&,combinedGraphics},drawNode[node_,y_]:=Style[Disk[{0,y},nodeRadius],LightBlue,EdgeForm[Black]];drawNodeLabel[node_,y_]:=Text[labelStyle[node],{0,y-nodeRadius-0.2}];drawMessage[t_,from_,to_,msg_]:=Module[{yFrom,yTo,xPos=t},yFrom=If[from===coordinator,yCoordNodes[[1]],yCoordNodes[[2]]];yTo=If[to===coordinator,yCoordNodes[[1]],yCoordNodes[[2]]];{Arrow[{{xPos,yFrom-Sign[yFrom-yTo] nodeRadius},{xPos,yTo+Sign[yFrom-yTo] nodeRadius}}],Text[labelStyle[msg],{xPos+0.15,(yFrom+yTo)/2}]}];drawTimeline[timeRange_]:={Table[{GrayLevel[0.8],Dashed,Line[{{t,yCoordNodes[[1]]+nodeRadius},{t,yCoordNodes[[2]]-nodeRadius}}]},{t,timeRange}],Table[{Black,Thick,Line[{{timeRange[[1]]-0.5,y},{timeRange[[-1]]+0.5,y}}]},{y,yCoordNodes}]};drawOnePhaseCommit[]:=Module[{t=tOnePhase},Graphics[{drawTimeline[t],drawNode[coordinator,yCoordNodes[[1]]],drawNode[participant,yCoordNodes[[2]]],drawNodeLabel[coordinator,yCoordNodes[[1]]],drawNodeLabel[participant,yCoordNodes[[2]]],drawMessage[t[[2]],coordinator,participant,"Commit"],Text[Style["Commit",Green,Bold,14],{t[[3]],Mean[yCoordNodes]-0.2}]},PlotRange->{{t[[1]]-0.5,t[[-1]]+0.5},{-0.5,1.5}},ImageSize->400,Background->Lighter[Yellow,0.85],PlotLabel->Style["5.2.1 One-Phase Commit",16,Bold]]];drawTwoPhaseCommit[]:=Module[{t=tTwoPhase},Graphics[{drawTimeline[t],drawNode[coordinator,yCoordNodes[[1]]],drawNode[participant,yCoordNodes[[2]]],drawNodeLabel[coordinator,yCoordNodes[[1]]],drawNodeLabel[participant,yCoordNodes[[2]]],drawMessage[t[[2]],coordinator,participant,"Prepare?"],drawMessage[t[[3]],participant,coordinator,"Vote Commit"],drawMessage[t[[4]],coordinator,participant,"Commit"],Text[Style["Commit",Green,Bold,14],{t[[5]],Mean[yCoordNodes]-0.2}]},PlotRange->{{t[[1]]-0.5,t[[-1]]+0.5},{-0.5,1.5}},ImageSize->450,Background->Lighter[LightBlue,0.9],PlotLabel->Style["5.2.2 Two-Phase Commit",16,Bold]]];drawFourPhaseCommit[]:=Module[{t=tFourPhase},Graphics[{drawTimeline[t],drawNode[coordinator,yCoordNodes[[1]]],drawNode[participant,yCoordNodes[[2]]],drawNodeLabel[coordinator,yCoordNodes[[1]]],drawNodeLabel[participant,yCoordNodes[[2]]],drawMessage[t[[2]],coordinator,participant,"Prepare?"],drawMessage[t[[3]],participant,coordinator,"Vote Commit"],drawMessage[t[[4]],coordinator,participant,"Pre-Commit"],drawMessage[t[[5]],participant,coordinator,"Ack Pre-Commit"],drawMessage[t[[6]],coordinator,participant,"Commit"],Text[Style["Commit",Green,Bold,14],{t[[7]],Mean[yCoordNodes]-0.2}]},PlotRange->{{t[[1]]-0.5,t[[-1]]+0.5},{-0.5,1.5}},ImageSize->500,Background->Lighter[LightGreen,0.9],PlotLabel->Style["5.2.3 Four-Phase Commit",16,Bold]]];combinedGraphics=Grid[{{drawOnePhaseCommit[],drawTwoPhaseCommit[],drawFourPhaseCommit[]}},Spacings->{3,2}];combinedGraphics]


Manipulate[Module[{p=0,c=0,b=0,q={},hist={0}},Do[If[Mod[i,producerRate]==0&&p<totalChunks,If[Length[q]<highWatermark,p++;AppendTo[q,p],b++]];If[Mod[i,consumerRate]==0&&q=!={},c++;q=Rest[q];];AppendTo[hist,Length[q]],{i,1,tick}];Column[{Style["Flow-Control / Back-Pressure Simulation",16,Bold],ProgressIndicator[c/totalChunks,ImageSize->Large],Grid[{{"Produced:",ProgressIndicator[p/totalChunks],Style[p,Bold],"/"<>ToString[totalChunks]},{"Consumed:",ProgressIndicator[c/totalChunks],Style[c,Bold],"/"<>ToString[totalChunks]},{"Buffer:",ProgressIndicator[Length[q]/highWatermark],Style[Length[q],Bold],"/"<>ToString[highWatermark]},{"Back-Pressure Events:",Style[b,Bold,Red]}},Alignment->Left,Spacings->{2,1}],ListLinePlot[hist,ImageSize->Large,PlotRange->{{0,maxTicks},{0,highWatermark+5}},AxesLabel->{"Time (Ticks)","Buffer Size"},PlotLabel->Style["Buffer Occupancy Over Time",Bold],PlotStyle->Directive[Thick,Blue],Filling->Axis,FillingStyle->Directive[Opacity[0.1],Blue],Epilog->{{Opacity[0.2],Red,Rectangle[{0,highWatermark},{maxTicks,highWatermark+5}]},{Orange,Dashed,Thick,Line[{{tick,0},{tick,highWatermark+5}}]}}],If[c>=totalChunks,Style["\:2714\:fe0e Simulation Complete",14,Bold,Darker[Green]],Spacer[20]]},Spacings->1.5,Alignment->Center]],{{tick,0,"Time"},0,maxTicks,1,Appearance->"Labeled"},Button["Reset",tick=0,ImageSize->Automatic],Delimiter,Style["Parameters",Bold],{{maxTicks,1500,"Simulation Ticks"},500,5000,100,Appearance->"Labeled"},{{producerRate,2,"Producer Speed (Faster \[RightArrow])"},1,3,0.5,Appearance->"Labeled"},{{consumerRate,5,"Consumer Speed (Faster \[RightArrow])"},1,10,1,Appearance->"Labeled"},{{highWatermark,30,"Buffer Size"},10,100,5,Appearance->"Labeled"},Initialization:>{fileSize=20 2^10;chunkSize=2^6;totalChunks=Ceiling[fileSize/chunkSize];},TrackedSymbols:>{tick,producerRate,consumerRate,highWatermark,maxTicks}]


a={1,2,4,7,11,15,20,26,33,41};
x1=Range[0,Length[a]-1];
x2=Pick[x1,EvenQ/@x1];
b=Pick[a,EvenQ/@x1];
plt1=ListLinePlot[{Transpose[{x1,a}],Transpose[{x2,b}]},PlotMarkers->{{"\[EmptyCircle]",10},{"\[UpPointer]",12}},PlotStyle->{Black,Darker[Blue]},PlotLegends->{"a","b"},Frame->True,FrameLabel->{"Index","Value"},ImageSize->350,PlotLabel->"Replicating  test.py"];
\[Theta]={1,2,2,3};
\[Gamma]={2,10,5,0.6};
labels={"\[Theta]=1, \[Gamma]=2","\[Theta]=2, \[Gamma]=10","\[Theta]=2, \[Gamma]=5","\[Theta]=3, \[Gamma]=0.6"};
marks={"\[EmptyCircle]","\[DownPointer]","\:2715","\[FilledDiamond]"};
u[x_,\[Theta]_,\[Gamma]_]:=1-Exp[-(x^\[Theta]/(x+\[Gamma]))];
curves=Table[{labels[[i]],marks[[i]],Table[{x,u[x,\[Theta][[i]],\[Gamma][[i]]]},{x,0,9}]},{i,Length[\[Theta]]}];
plt2=ListLinePlot[curves[[All,3]],PlotMarkers->Thread[{curves[[All,2]],11}],PlotLegends->curves[[All,1]],PlotStyle->Thick,Frame->True,FrameLabel->{"Data size  (x)","System income  (u)"},ImageSize->350,PlotLabel->"Replicating  utility.py"];
srv={{20,20},{30,120},{50,250},{70,355},{80,220},{120,140},{150,300},{200,200},{220,300},{250,150},{280,70},{330,200},{350,30},{380,180},{400,400},{200,450},{450,60},{470,160},{475,300},{490,400}};
usr={{50,200},{150,200},{250,200},{350,200},{450,200},{50,400},{150,400},{250,400},{350,400},{450,400}};
SeedRandom[42];
rounds=10;
userSequence=RandomChoice[usr,rounds];
choiceSequence=ConstantArray[{0,0},rounds];
battery=10.;
energy[x_,y_]:=1/20 0.1 Sqrt[x^2+y^2];
utility[t_]:=t/20.;
rewardSeq=ConstantArray[0.,rounds];
Do[Module[{target,best,bestDist=\[Infinity]},target=userSequence[[r]];Do[With[{d=Norm[srv[[i]]-target]},If[d<bestDist,bestDist=d;best=srv[[i]]]],{i,Length[srv]}];choiceSequence[[r]]=best;rewardSeq[[r]]=2 utility[RandomInteger[{0,20}]]-energy@@best;battery-=energy@@best;],{r,rounds}];
pathCoords=Prepend[choiceSequence,{0,0}];
plt3=Graphics[{{Blue,PointSize[0.015],Point[srv]},{Black,PointSize[0.02],Point[usr]},{Red,Thick,Arrow/@Partition[pathCoords,2,1]},{Yellow,EdgeForm[Black],(Disk[#1,6]&)/@Rest[pathCoords]}},PlotRange->{{-10,510},{-10,510}},AspectRatio->1,Frame->True,FrameLabel->{"x (m)","y (m)"},ImageSize->350,PlotLabel->"Toy UAV path \[Dash] 10 greedy hops"];
avgReward=Mean[rewardSeq];
Column[{plt1,plt2,Column[{plt3,Style["Average reward (toy model): "<>ToString[NumberForm[avgReward,{4,3}]],12,Bold]}]},Spacings->2]


a={1,2,4,7,11,15,20,26,33,41};
x1=Range[0,Length[a]-1];
x2=Pick[x1,EvenQ/@x1];
b=Pick[a,EvenQ/@x1];
fig1=ListLinePlot[{Transpose[{x1,a}],Transpose[{x2,b}]},PlotMarkers->{{"\[FilledCircle]",Medium},{"\[FilledUpTriangle]",Medium}},PlotStyle->{Black,Red},InterpolationOrder->None,PlotLegends->{"a","b"},AxesLabel->{"index","value"},PlotLabel->Style["Figure 1 \[Dash] data \:201fa\:02bc and subset \:201fb\:02bc",14,Bold],ImageSize->400];
theta={1,2,2,3};
gamma={2,10,5,0.6};
labels={"\[Theta]=1,\[Gamma]=2","\[Theta]=2,\[Gamma]=10","\[Theta]=2,\[Gamma]=5","\[Theta]=3,\[Gamma]=0.6"};
markers={"\[FilledCircle]","\[FilledDownTriangle]","\[Times]","\\[FivePointStar]"};
x=Range[0,9];
curves=Table[Module[{u=1-Exp[-(x^theta[[i]]/(x+gamma[[i]]))]},Style[Transpose[{x,u}],PlotMarkers->{{markers[[i]],Medium}},PlotStyle->Thick]],{i,Length[theta]}];
fig2=ListLinePlot[curves,InterpolationOrder->None,PlotLegends->Placed[labels,Right],AxesLabel->{"data size","system income"},PlotLabel->Style["Figure 2 \[Dash] income vs data-size for (\[Theta],\[Gamma]) pairs",14,Bold],ImageSize->440];
Column[{fig1,Spacer[15],fig2},Alignment->Center,Spacings->2]


Block[{},Print[Style["Utility Function Plot (from utility.py)","Subsection",14]];theta={1,2,2,3};gamma={2,10,5,0.6};la={"\[Theta]=1, \[Gamma]=2","\[Theta]=2, \[Gamma]=10","\[Theta]=2, \[Gamma]=5","\[Theta]=3, \[Gamma]=0.6"};ma={"\[EmptyCircle]","\[EmptyDownTriangle]","\[Times]","p"};x=Range[0,9,1];plotData=Table[1-Exp[-(x^theta[[i]]/(x+gamma[[i]]))],{i,1,Length[theta]}];Print[ListPlot[Table[Transpose[{x,plotData[[i]]}],{i,Length[plotData]}],PlotLegends->la,PlotMarkers->ma,AxesLabel->{"data size","System income"},ImageSize->Medium]]];


GF2Det[matrix_]:=Module[{m=Mod[matrix,2]},Mod[Det[m],2]]
GF2MatrixInverse[matrix_]:=Module[{n=Length[matrix],aug,i,j,pivotRow},aug=ArrayFlatten[{{Mod[matrix,2],IdentityMatrix[n]}}];For[i=1,i<=n,i++,pivotRow=i;While[pivotRow<=n&&aug[[pivotRow,i]]==0,pivotRow++];If[pivotRow>n,Return[$Failed]];If[pivotRow!=i,aug[[{i,pivotRow}]]=aug[[{pivotRow,i}]]];For[j=i+1,j<=n,j++,If[aug[[j,i]]==1,aug[[j]]=Mod[aug[[j]]+aug[[i]],2]]];];For[i=n,i>=1,i--,For[j=i-1,j>=1,j--,If[aug[[j,i]]==1,aug[[j]]=Mod[aug[[j]]+aug[[i]],2]]];];aug[[All,n+1;;2 n]]]
T={{1,0,0,0},{1,1,0,0},{0,1,1,0},{0,0,1,1}};
Print["Determinant mod 2: ",GF2Det[T]];
If[GF2Det[T]!=1,Print["Matrix T is NOT invertible over GF(2). Choose a different matrix."],d={1,0,1,1};GF2MatMul[A_,B_]:=Mod[A . B,2];r=GF2MatMul[T,d];Tinv=GF2MatrixInverse[T];If[Tinv===$Failed,Print["Failed to invert matrix T."],dRecovered=GF2MatMul[Tinv,r];Column[{Style["Original message d:",Bold],d,Style["Transformation matrix T:",Bold],MatrixForm[T],Style["Transmitted vector r = T\[CenterDot]d:",Bold],r,Style["Inverse matrix T^{-1}:",Bold],MatrixForm[Tinv],Style["Recovered message dRecovered = T^{-1}\[CenterDot]r:",Bold],dRecovered,Style["Recovery successful? ",Bold],If[dRecovered==d,Style["Yes, exact recovery.",Darker[Green]],Style["No, recovery failed.",Red]]}]]]


Module[{nSpines=4,nLeafs=16,nPods=4,meshGraph,closGraph,getNeighbors},closEdges=Flatten[Table["Pod"<>ToString[p]<>"-Leaf"<>ToString[l]\[UndirectedEdge]"Spine"<>ToString[s],{p,1,nPods},{l,1,nLeafs/nPods},{s,1,nSpines}]]\[Union]Flatten[Table["Host"<>ToString[h]\[UndirectedEdge]"Pod"<>ToString[p]<>"-Leaf"<>ToString[l],{p,1,nPods},{l,1,nLeafs/nPods},{h,((p-1) nLeafs 2)/nPods+(l-1) 2+1,((p-1) nLeafs 2)/nPods+l 2}]];closGraph=Graph[closEdges,VertexLabels->"Name",VertexSize->{"Scaled",0.01},GraphLayout->{"LayeredEmbedding","Orientation"->Top},ImageSize->500,PlotLabel->Style["Conventional Clos Topology",Bold,14]];getNeighbors[{x_Integer,y_Integer}]:=Select[{{x,y+1},{x+1,y+1},{x+1,y},{x+1,y-1},{x,y-1},{x-1,y-1},{x-1,y},{x-1,y+1}},0<=#1[[1]]<=7&&0<=#1[[2]]<=7&];meshCoords=Flatten[Table[{x,y},{y,0,7},{x,0,7}],1];meshEdges=Flatten[Function[{node},(node\[UndirectedEdge]#1&)/@getNeighbors[node]]/@meshCoords];meshGraph=Graph[meshCoords,meshEdges,VertexCoordinates->Thread[meshCoords->meshCoords],VertexSize->Small,VertexLabels->None,EdgeStyle->GrayLevel[0.7],ImageSize->500];meshPlot=HighlightGraph[meshGraph,{(Style[#1,Red]&)/@Cases[VertexList[meshGraph],v_/;VertexDegree[meshGraph,v]==8]},PlotLabel->Style["8-Valency Mesh (Full-Valency Nodes in Red)",Bold,14]];Print[Style["Topological Comparison: Clos vs. \[CapitalAE]thernet Mesh",18,"Title"]];Row[{closGraph,Spacer[30],meshPlot}]]


numPods=4;
numLeafPerPod=4;
numSpines=4;
spines=Table["S"<>ToString[i],{i,numSpines}];
leafs=Flatten[Table["L"<>ToString[p]<>"_"<>ToString[l],{p,numPods},{l,numLeafPerPod}]];
closEdges=Flatten[Table[leaf\[UndirectedEdge]spine,{leaf,leafs},{spine,spines}]];
closGraph=Graph[spines\[Union]leafs,closEdges,VertexLabels->"Name",GraphLayout->{"LayeredDigraphEmbedding","Orientation"->Left},VertexSize->Medium,ImagePadding->30,PlotLabel->Style["Traditional Clos Topology (Spine-Leaf)",Bold,16]];
gridSize=4;
coords=Flatten[Table[{i,j},{i,gridSize},{j,gridSize}],1];
neighborOffsets=DeleteCases[Tuples[{-1,0,1},2],{0,0}];
getNeighbors[{x_,y_}]:=Select[({x,y}+#1&)/@neighborOffsets,1<=#1[[1]]<=gridSize&&1<=#1[[2]]<=gridSize&];
verticesMesh=Table["G_"<>ToString[i]<>"_"<>ToString[j],{i,gridSize},{j,gridSize}];
verticesMeshFlat=Flatten[verticesMesh];
meshEdges=Flatten[Table[Module[{v=verticesMesh[[i,j]],neighbors},neighbors=getNeighbors[{i,j}];(v\[UndirectedEdge]verticesMesh[[#1[[1]],#1[[2]]]]&)/@neighbors],{i,gridSize},{j,gridSize}],2];
meshEdges=DeleteDuplicatesBy[meshEdges,Sort[{#1[[1]],#1[[2]]}]&];
meshGraph=Graph[verticesMeshFlat,meshEdges,VertexCoordinates->AssociationThread[verticesMeshFlat->coords],VertexLabels->None,VertexSize->Small,EdgeStyle->GrayLevel[0.7],ImagePadding->30,PlotLabel->Style["Direct-Connected 8-Valency IPU Mesh",Bold,16]];
highlightNode="G_2_2";
gvmGraph=HighlightGraph[meshGraph,{highlightNode,NeighborhoodGraph[meshGraph,highlightNode,1]},VertexStyle->{highlightNode->Red,_->LightGray},EdgeStyle->{highlightNode<->_->Red,_->LightGray},PlotLabel->Style["Graph Virtual Machine (GVM) Concept: Decentralized Execution\nLocal 1-Hop Neighborhood Highlighted",Bold,14]];
GraphicsRow[{closGraph,meshGraph,gvmGraph},Spacings->Scaled[0.05]]


Module[{n=20,radius=0.40,rngSeed=1234,pts,coords,edges,g,highlightPath,safeClusters,traverse,bfsPath,dfsPath,partition,kMeansClusters,mstClusters,spectralClusters,optimize,shortestPath,maxFlowVal,deploy,trType="BFS",srcV=1,tgtV=15,pMethod="KMeans",kVal=3,oMetric="ShortestPath",dMethod="KMeans",dTenants=3,deployPol="Affinity"},SeedRandom[rngSeed];pts=RandomReal[{0,1},{n,2}];coords=AssociationThread[Range[n],pts];edges=UndirectedEdge@@@Select[Subsets[Range[n],{2}],EuclideanDistance@@(pts[[#1]]&)/@#1<radius&];g=Graph[Range[n],edges,VertexCoordinates->coords,VertexLabels->"Name",ImagePadding->15];highlightPath[path_List]:=If[Length[path]<2,g,HighlightGraph[g,UndirectedEdge@@@Partition[path,2,1]]];safeClusters[cls_]:=If[cls==={}||!ListQ[First[cls]],{Range[n]},cls];bfsPath[s_,t_]:=FindShortestPath[g,s,t];dfsPath[s_,t_]:=With[{p=FindPath[g,s,t,1]},If[p==={},{},First[p]]];traverse["BFS",s_,t_]:=bfsPath[s,t];traverse["DFS",s_,t_]:=dfsPath[s,t];traverse[_,s_,t_]:={};kMeansClusters[k_]:=safeClusters[FindClusters[pts->Range[n],k]];mstClusters[k_]:=Module[{mst,byDist,toRemove,comps},mst=FindSpanningTree[g];byDist=SortBy[EdgeList[mst],EuclideanDistance@@coords/@List@@#1&];toRemove=Take[byDist,-Min[k-1,Length[byDist]]];comps=ConnectedComponents[EdgeDelete[mst,toRemove]];safeClusters[comps]];spectralClusters[k_]:=Module[{lap=GraphLaplacianMatrix[g],vecs,embed,cls},vecs=Take[Eigenvectors[lap],UpTo[k]];If[Length[vecs]<k,Return[{Range[n]}]];embed=Transpose[vecs];cls=FindClusters[embed->Range[n],k];safeClusters[cls]];partition["KMeans",k_]:=kMeansClusters[k];partition["MST",k_]:=mstClusters[k];partition["Spectral",k_]:=spectralClusters[k];partition[_,_]:={Range[n]};shortestPath[s_,t_]:=FindShortestPath[g,s,t];maxFlowVal[s_,t_]:=MaxFlow[g,s,t];optimize["ShortestPath",s_,t_]:=highlightPath[shortestPath[s,t]];optimize["MaxFlow",s_,t_]:=Labeled[g,Style["Max flow = "<>ToString[maxFlowVal[s,t]],Bold,12],Bottom];optimize["Latency",___]:=Module[{w=AssociationThread[EdgeList[g]->(1/EuclideanDistance@@coords/@List@@#1&)/@EdgeList[g]]},Graph[g,EdgeWeight->w,EdgeLabels->"EdgeWeight",VertexCoordinates->coords,VertexLabels->"Name"]];optimize[_,___]:=g;deploy[method_,tenantCnt_,policy_]:=Module[{clusters=partition[method,tenantCnt],colormap=Table[ColorData["Rainbow"][i/tenantCnt],{i,tenantCnt}],vStyles},vStyles=Flatten[Table[Thread[clusters[[i]]->colormap[[i]]],{i,Length[clusters]}],1];Graph[g,VertexStyle->vStyles,VertexLabels->"Name"]];Manipulate[Column[{Style["Graph Virtual Machine (GVM) Interactive Playground",Bold,16,Darker[Blue]],"\:2666 Traversal",Row[{"Type:",PopupMenu[Dynamic[trType],{"BFS","DFS"}],Spacer[15],"Source:",PopupMenu[Dynamic[srcV],Range[n]],Spacer[15],"Target:",PopupMenu[Dynamic[tgtV],Range[n]]}],Dynamic[highlightPath[traverse[trType,srcV,tgtV]]],Divider[],"\:2666 Partition",Row[{"Method:",PopupMenu[Dynamic[pMethod],{"KMeans","MST","Spectral"}],Spacer[20],"k:",SetterBar[Dynamic[kVal],Range[2,6]]}],Dynamic[Module[{cls=partition[pMethod,kVal],cols=Table[ColorData["Rainbow"][i/Length[partition[pMethod,kVal]]],{i,Length[partition[pMethod,kVal]]}]},Graph[g,VertexStyle->Flatten[Table[Thread[cls[[i]]->cols[[i]]],{i,Length[cls]}],1],VertexLabels->"Name"]]],Divider[],"\:2666 Optimize",Row[{"Metric:",PopupMenu[Dynamic[oMetric],{"ShortestPath","MaxFlow","Latency"}]}],Dynamic[optimize[oMetric,srcV,tgtV]],Divider[],"\:2666 Deploy",Row[{"Method:",PopupMenu[Dynamic[dMethod],{"KMeans","MST","Spectral"}],Spacer[20],"Tenants:",SetterBar[Dynamic[dTenants],Range[2,6]]}],Dynamic[deploy[dMethod,dTenants,deployPol]]}],TrackedSymbols:>{trType,srcV,tgtV,pMethod,kVal,oMetric,dMethod,dTenants},SaveDefinitions->True]]


Module[{n=10000,side,coords,adjList,g,startNode=1,bfsQueue,visited,step=0,failedNodes={},failureStep=20,failureCount=50,maxSteps=200,dynamicBFS,nodeRadius=0.3,neighborsOffsets={{-1,-1},{0,-1},{1,-1},{-1,0},{1,0},{-1,1},{0,1},{1,1}},failRandomNodes},side=Ceiling[Sqrt[n]];coords=Association[Table[i->{Mod[i-1,side]+1,Quotient[i-1,side]+1},{i,n}]];adjList=Association[Table[i->Module[{x,y,neighbors},{x,y}=coords[i];neighbors=Select[Flatten[Table[With[{nx=x+dx,ny=y+dy},If[1<=nx<=side&&1<=ny<=side,(ny-1) side+nx,Nothing]],{dx,{-1,0,1}},{dy,{-1,0,1}}]],#1!=i&];neighbors],{i,n}]];failRandomNodes[]:=Module[{candidates},candidates=Complement[Range[n],failedNodes];If[Length[candidates]<failureCount,Return[]];failedNodes=Join[failedNodes,RandomSample[candidates,failureCount]];];visited=Association[Table[i->False,{i,n}]];bfsQueue={startNode};visited[startNode]=True;dynamicBFS=DynamicModule[{localStep=0,localQueue=bfsQueue,localVisited=visited,localFailed=failedNodes,newlyVisited={},toEnqueue={}},Panel[Column[{"Graph Virtual Machine: BFS Traversal and Failure Handling Simulation",Dynamic[Grid[{{"Step",localStep},{"Queue Length",Length[localQueue]},{"Visited Nodes",Count[Values[localVisited],True]},{"Failed Nodes",Length[localFailed]}},Alignment->Left]],Dynamic[Graphics[Module[{shownNodes,nodeColors,edges,shownEdges,failedSet=AssociationThread[localFailed->Table[True,{Length[localFailed]}]],maxDrawNodes=800},shownNodes=Take[Select[Keys[localVisited],localVisited[#1]&&!KeyExistsQ[failedSet,#1]&],UpTo[maxDrawNodes]];nodeColors=Association[Table[i->If[KeyExistsQ[failedSet,i],Red,If[MemberQ[localQueue,i],Blue,Green]],{i,shownNodes}]];edges=Flatten[Table[With[{nbrs=adjList[i]},Table[If[KeyExistsQ[failedSet,nbr]||!MemberQ[shownNodes,nbr],Nothing,Line[{coords[i],coords[nbr]}]],{nbr,nbrs}]],{i,shownNodes}]];shownEdges=edges;Graphics[{({LightGray,Circle[{#1,#2},nodeRadius]}&)@@@coords/@shownNodes,({nodeColors[#1],Disk[coords[#1],nodeRadius]}&)/@shownNodes,{Gray,Thin,shownEdges}},PlotRange->{{0,side+1},{0,side+1}},ImageSize->Large,Background->Black,Frame->True,FrameTicks->None,AspectRatio->1]],UpdateInterval->0.2]],Row[{Button["Next Step",If[localStep==failureStep,failRandomNodes[];localFailed=failedNodes];newlyVisited={};toEnqueue={};If[localQueue==={},MessageDialog["BFS complete or no more nodes to visit."],Module[{current=First[localQueue],neighbors},neighbors=Select[adjList[current],!localVisited[#1]&&!MemberQ[localFailed,#1]&];Do[localVisited[nbr]=True;AppendTo[newlyVisited,nbr];AppendTo[toEnqueue,nbr],{nbr,neighbors}];localQueue=Rest[localQueue];localQueue=Join[localQueue,toEnqueue];];];localStep++;],Button["Reset",localStep=0;localQueue={startNode};localVisited=Association[Table[i->False,{i,n}]];localVisited[startNode]=True;localFailed={};failedNodes={};]}]}]]];dynamicBFS]


Module[{n=400,side=20,coords,adjList,g,numCovers=5,coverAssignments,coverColors,spanningTrees,anomalousTenant=1,migrationSteps=0,maxMigrationSteps=5,isolatedSubgraphs,neighborsOffsets={{-1,0},{1,0},{0,-1},{0,1}},buildAdjList,assignCovers,buildSpanningTrees,drawGraphWithCovers,simulateMigration,migrationQueue,migratedNodes,nodeRadius=0.3,blastRadiusLimit=32},coords=Association[Table[i->{Mod[i-1,side]+1,Quotient[i-1,side]+1},{i,n}]];buildAdjList[]:=Association[Table[i->Module[{x,y,nbrs},{x,y}=coords[i];nbrs=Select[Flatten[Table[With[{nx=x+dx,ny=y+dy},If[1<=nx<=side&&1<=ny<=side,(ny-1) side+nx,Nothing]],{dx,{-1,0,1,0}},{dy,{0,-1,0,1}}]],#1!=i&];nbrs],{i,n}]];adjList=buildAdjList[];assignCovers[]:=Module[{row,col,coverGrid,nodesPerCover,coverMap},nodesPerCover=Ceiling[Sqrt[numCovers]];coverGrid=Table[Floor[(i-1)/(side/nodesPerCover)] nodesPerCover+Floor[(j-1)/(side/nodesPerCover)]+1,{j,side},{i,side}];coverMap=Association[Table[idx->coverGrid[[coords[idx][[2]],coords[idx][[1]]]],{idx,n}]];coverMap];coverAssignments=assignCovers[];coverColors=ColorData[97,"ColorList"];If[Length[coverColors]<numCovers,coverColors=Table[ColorData["BrightBands"][i/(numCovers-1)],{i,0,numCovers-1}];];buildSpanningTrees[]:=Table[Module[{nodes,subgraphEdges,tree},nodes=Keys[Select[coverAssignments,#1==c&]];subgraphEdges=Flatten[Table[Module[{nbrs=adjList[node]},Table[If[MemberQ[nodes,nbr],node\[UndirectedEdge]nbr,Nothing],{nbr,nbrs}]],{node,nodes}],1];tree=FindSpanningTree[Graph[nodes,subgraphEdges]];tree],{c,numCovers}];spanningTrees=buildSpanningTrees[];drawGraphWithCovers[migratedNodes_:{}]:=Module[{nodesToDraw,edgesToDraw,coverNodes,baseGraph,baseEdges,anomalousNodes,blastNodes,blastRadius,blastSet,spanningEdges,spanningEdgeGraphics,migratedSet=AssociationThread[migratedNodes->Table[True,{Length[migratedNodes]}]]},nodesToDraw=Keys[coverAssignments];baseEdges=Flatten[Table[Table[If[coverAssignments[e1]==coverAssignments[e2],e1\[UndirectedEdge]e2,Nothing],{e2,adjList[e1]}],{e1,nodesToDraw}],1];baseGraph=Graph[nodesToDraw,baseEdges,VertexCoordinates->coords/@nodesToDraw];anomalousNodes=Keys[Select[coverAssignments,#1==anomalousTenant&]];blastRadius=blastRadiusLimit;blastNodes=Take[anomalousNodes,UpTo[blastRadius]];blastSet=AssociationThread[blastNodes->Table[True,{Length[blastNodes]}]];spanningEdgeGraphics=Table[Module[{edges=EdgeList[spanningTrees[[c]]]},{Directive[Thickness[0.006],Opacity[0.6],coverColors[[c]]],Line[coords/@Flatten[List@@@edges,1]]}],{c,numCovers}];Graphics[{Table[{If[MemberQ[migratedNodes,node],GrayLevel[0.5],coverColors[[coverAssignments[node]]]],Disk[coords[node],nodeRadius]},{node,nodesToDraw}],spanningEdgeGraphics,{Black,Thick,Table[Circle[coords[node],nodeRadius+0.05],{node,anomalousNodes}]},{Red,Opacity[0.15],Table[Disk[coords[node],nodeRadius+0.15],{node,blastNodes}]}},PlotRange->{{0,side+1},{0,side+1}},Background->LightGray,Frame->True,AspectRatio->1,ImageSize->Large]];migrationQueue={};migratedNodes={};simulateMigration[]:=Module[{anomalousNodes,targetPartition,stepNodes},anomalousNodes=Keys[Select[coverAssignments,#1==anomalousTenant&]];If[migrationSteps==0,migrationQueue=anomalousNodes;migratedNodes={};,stepNodes=Take[migrationQueue,UpTo[10]];migrationQueue=Drop[migrationQueue,Length[stepNodes]];migratedNodes=Join[migratedNodes,stepNodes];];migrationSteps++;If[migrationSteps>maxMigrationSteps,migrationSteps=maxMigrationSteps;migrationQueue={};];];DynamicModule[{stepCount=0},Panel[Column[{Style["Security via Confinement and Covers Simulation",Bold,16],Dynamic[drawGraphWithCovers[migratedNodes]],Row[{Button["Migrate Anomalous Tenant Nodes",simulateMigration[];stepCount++;,Enabled->Dynamic[stepCount<maxMigrationSteps]],Spacer[20],Button["Reset",migrationSteps=0;migrationQueue={};migratedNodes={};stepCount=0;]}],Dynamic["Migration Step: "<>ToString[stepCount]<>" / "<>ToString[maxMigrationSteps]],Dynamic["Anomalous Tenant Blast Radius \[LessEqual] "<>ToString[blastRadiusLimit]<>" nodes (confined)"]}]]]]


Column[{Module[{nodes={"A","B","C","Service1","Service2","Service3"},edges={"A"\[UndirectedEdge]"Service1","B"\[UndirectedEdge]"Service2","C"\[UndirectedEdge]"Service3","A"\[UndirectedEdge]"B","Service1"\[UndirectedEdge]"Service2","Service2"\[UndirectedEdge]"Service3"},g,plotBefore,plotAfter},g=Graph[nodes,edges,VertexLabels->"Name",VertexSize->Medium];plotBefore=Graph[g,ImageSize->350,PlotLabel->Style["Initial Layout",Bold]];plotAfter=Graph[g,VertexCoordinates->{"A"->{0,0},"B"->{1,0},"C"->{5,2},"Service1"->{0,1},"Service2"->{1,1},"Service3"->{4,2}},ImageSize->350,PlotLabel->Style["Layout After AI Policy Translation",Bold]];Grid[{{Style["1. Policy Translation",14,Bold],\[SpanFromLeft]},{plotBefore,plotAfter}},Spacings->2]],Delimiter,Module[{data=RandomReal[1,{50,2}],clusters,plot},clusters=FindClusters[data,3];plot=ListPlot[clusters,PlotStyle->{Red,Green,Blue},PlotMarkers->"OpenMarkers",Frame->True,FrameLabel->{"Resource Axis 1","Resource Axis 2"},ImageSize->400,PlotLabel->Style["AI Suggestion: partition(k-means)",Bold]];Grid[{{Style["2. Optimization Hints",14,Bold]},{plot}}]],Delimiter,Module[{g,compromisedNode={5,5},gIsolated,plotBefore,plotAfter},g=GridGraph[{10,10},VertexLabels->None,VertexSize->Small];plotBefore=HighlightGraph[g,{Style[compromisedNode,Red,PointSize[Large]]},ImageSize->350,PlotLabel->Style["Fabric with Compromised Node",Bold]];gIsolated=EdgeDelete[g,compromisedNode\[UndirectedEdge]_];plotAfter=HighlightGraph[gIsolated,{Style[compromisedNode,Red,PointSize[Large]]},ImageSize->350,PlotLabel->Style["AI Action: Isolate Node",Bold]];Grid[{{Style["3. Security Monitoring & Isolation",14,Bold],\[SpanFromLeft]},{plotBefore,plotAfter}},Spacings->2]],Delimiter,Module[{g1,g2,barbellGraph,bottleneckEdge,plot},g1=CompleteGraph[7];g2=CompleteGraph[7];bottleneckEdge=First[VertexList[g1]]\[UndirectedEdge]First[VertexList[g2]];barbellGraph=Graph[Join[VertexList[g1],VertexList[g2]],Join[EdgeList[g1],EdgeList[g2],{bottleneckEdge}],GraphLayout->"SpringElectricalEmbedding",ImageSize->400];plot=HighlightGraph[barbellGraph,{Style[bottleneckEdge,Red,Thick,Opacity[1]]},PlotLabel->Style["AI Debugging: Bottleneck Detected",Bold]];Grid[{{Style["4. Graph Debugging",14,Bold]},{plot}}]]},Spacings->3]


Module[{gridSize=6,g,startNode=1,endNode,pathBefore,pathAfter,failedLinks,criticalNodes},g=GridGraph[{gridSize,gridSize},VertexLabels->None,VertexSize->0.3,EdgeStyle->{LightGray,Thin}];endNode=gridSize^2;SeedRandom[123];pathBefore=FindShortestPath[g,startNode,endNode];failedLinks=RandomSample[EdgeList[g],5];pathAfter=FindShortestPath[EdgeDelete[g,failedLinks],startNode,endNode];criticalNodes={startNode,endNode};HighlightGraph[g,{Style[UndirectedEdge@@@Partition[pathBefore,2,1],Gray,Dashed],Style[UndirectedEdge@@@Partition[pathAfter,2,1],Green,Thick],Style[failedLinks,Red,Dashed],Style[criticalNodes,Orange,PointSize[Large]]},VertexLabels->None,ImageSize->500,PlotLabel->Style["Self-Healing in an N2N Lattice",Bold,16],PlotLegends->Placed[LineLegend[{Green,Gray,Red},{"Healed Path","Original Path","Failed Link"}],{Left,Top}]]]


ClearAll["Global`*"];
m2e=1.027491252;
marsSolSeconds=24 3600+39 60+35.244;
earthEpoch={1970,4,28,0,0,0};
earthEpochAbs=AbsoluteTime[earthEpoch];
isLeapMartian[y_Integer?Positive]:=Module[{n=y},Which[Mod[n,3000]==0,False,Mod[n,1000]==0,True,Mod[n,100]==0,False,Mod[n,10]==0&&Mod[n,2]==0,True,True,False]];
solsInYear[y_Integer?Positive]:=If[isLeapMartian[y],669,668];
monthLengths[y_Integer?Positive]:=Module[{pat=Flatten[Table[{28,27},12]]},If[isLeapMartian[y],ReplacePart[pat,24->28],pat]];
solsBeforeYear[y_Integer?Positive]:=\!\(
\*UnderoverscriptBox[\(\[Sum]\), \(i = 1\), \(y - 1\)]\(solsInYear[i]\)\);
solsBeforeMonth[y_Integer?Positive,m_Integer?Positive]:=If[m<=1,0,Total[monthLengths[y][[1;;m-1]]]];
earthToMarsDate[date_List]:=Module[{d=PadRight[date,6,0],totalSol,intSol,fracSol,yr=1,solsLeft,mo=1,ml,hrs,mins,secs},totalSol=(AbsoluteTime[d]-earthEpochAbs)/marsSolSeconds;intSol=Floor[totalSol];fracSol=FractionalPart[totalSol];solsLeft=intSol;While[solsLeft>=solsInYear[yr],solsLeft-=solsInYear[yr];yr++];ml=monthLengths[yr];While[solsLeft>=ml[[mo]],solsLeft-=ml[[mo]];mo++];solsLeft+=1;secs=fracSol marsSolSeconds;hrs=Floor[secs/3600];mins=Floor[1/60 (secs-3600 hrs)];secs=secs-3600 hrs-60 mins;Association["MartianYear"->yr,"MartianMonth"->mo,"MartianSol"->solsLeft,"MartianTime"->{hrs,mins,secs},"TotalSolsSinceEpoch"->totalSol]];
marsToEarthDate[assoc_Association]/;KeyExistsQ[assoc,"MartianYear"]&&KeyExistsQ[assoc,"MartianMonth"]&&KeyExistsQ[assoc,"MartianSol"]:=Module[{yr=assoc["MartianYear"],mo=assoc["MartianMonth"],sol=assoc["MartianSol"],time=Lookup[assoc,"MartianTime",{0,0,0}],totalSol,absTime},totalSol=solsBeforeYear[yr]+solsBeforeMonth[yr,mo]+(sol-1)+(time[[1]] 3600+time[[2]] 60+time[[3]])/marsSolSeconds;absTime=earthEpochAbs+totalSol marsSolSeconds;DateList[absTime]];
earthToMars[date_List]:=earthToMarsDate[date][["MartianYear","MartianMonth","MartianSol","MartianTime"]];
marsToEarth[y_,m_,s_,t_:{0,0,0}]:=marsToEarthDate[Association["MartianYear"->y,"MartianMonth"->m,"MartianSol"->s,"MartianTime"->t]];
earthSample={2000,1,6,0,0,0};
marsResult=earthToMarsDate[earthSample];
Print["Earth date  : ",earthSample];
Print["Mars result : Year ",marsResult["MartianYear"],", Month ",marsResult["MartianMonth"],", Sol ",marsResult["MartianSol"],", Time ",marsResult["MartianTime"]];
back=marsToEarthDate[marsResult];
Print["Back-converted Earth date \[TildeTilde] ",back];


startDate={2025,1,1};
todayDate=Date[];
wednesdays=DateRange[startDate,todayDate,"Wednesday"];
numWednesdays=Length[wednesdays];
wedTable=Dataset[Table[Association["Label"->"Wednesday "<>ToString[i],"Date"->DateString[wednesdays[[i]],"ISODate"]],{i,numWednesdays}]];
Print["Number of Wednesdays since 2025-01-01 (inclusive): ",numWednesdays];
wedTable


Module[{metrics,kubernetesData,gvmData,keys,barChart,textTable,marsGraph,marsNodes,marsEdges,failedNodes,nodeCoords,nodeStyles,edgeStyles,marsGraphPlot,latencyScale,annotationStyle},metrics={"Configuration"->{"Manual YAML, CNI plugins","Self-partitioning graph ops"},"Operation"->{"Human-tuned schedulers","Fully autonomous"},"Security"->{"Declarative + fragile","Dynamic + confined"},"Latency (ns)"->{20000,75},"Failure Domain"->{"Rack-wide (32+ nodes)","1\[Dash]8 nodes max"},"Scaling (nodes)"->{"~1,000 ceiling","\[GreaterEqual]10,000 trivial"}};keys=metrics[[All,1]];kubernetesData=metrics[[All,2,1]];gvmData=metrics[[All,2,2]];textTable=Grid[Prepend[MapThread[{#1,Style[#2,Blue],Style[#3,Darker[Green]]}&,{keys,kubernetesData,gvmData}],{Style["Metric",Bold,14],Style["Kubernetes/Clos",Blue,Bold,14],Style["GVM/IPU",Darker[Green],Bold,14]}],Frame->All,Alignment->Left,Spacings->{2,1}];barChart=BarChart[{{20000,1000},{75,10000}},ChartLabels->Placed[{"Latency (ns)","Scaling (nodes)"},Below],ChartStyle->{Blue,Darker[Green]},BarSpacing->Large,ImageSize->400,PlotLabel->Style["Latency and Scaling Comparison",Bold,14]];marsNodes=Range[32];nodeCoords=Association[Table[i->{Mod[i-1,8],Floor[(i-1)/8]},{i,marsNodes}]];marsEdges=Flatten[Table[{If[Mod[i,8]!=0,i\[UndirectedEdge]i+1,Sequence@@{}],If[i+8<=32,i\[UndirectedEdge]i+8,Sequence@@{}]},{i,marsNodes}],1];failedNodes={3,4,5};nodeStyles=Thread[marsNodes->(If[MemberQ[failedNodes,#1],Red,Darker[Green]]&)/@marsNodes];edgeStyles=Thread[marsEdges->(If[MemberQ[failedNodes,#1[[1]]]&&MemberQ[failedNodes,#1[[2]]],Directive[Red,Dashed],GrayLevel[0.7]]&)/@marsEdges];annotationStyle=Style[#1,Italic,12,Gray]&;Column[{Style["5.13 Why This Replaces Kubernetes",Bold,20],Spacer[10],textTable,Spacer[20],barChart,Spacer[20],Spacer[10],annotationStyle["Red nodes and edges show a localized failure domain (max 8 nodes)"],annotationStyle["Green nodes are healthy, illustrating fine-grained failure confinement"],annotationStyle["Mesh topology supports autonomous operation and low latency (~50-100 ns)"]}]]


Module[{metricsLabels={"Latency (\[Micro]s)","Failure Domain (nodes)","Scaling Capacity (nodes)"},kubernetesValues={20,32,1000},gvmValues={0.075,8,10000},configText,operationText,securityText,netVertices,netEdges,failedNodes,failedEdges,graphCoords,netGraph,styledGraph,kubColor=RGBColor[0.2,0.4,0.8],gvmColor=RGBColor[0.9,0.3,0.2]},configText=Grid[{{"Configuration:","Manual YAML, CNI plugins","Self-partitioning graph ops"},{"Operation:","Human-tuned schedulers","Fully autonomous"},{"Security:","Declarative + fragile","Dynamic + confined"}},Frame->All,Spacings->{2,1},Alignment->Left,Background->{None,{Lighter[Gray,0.9],None,None}}];operationText=Style["Configuration and Operation Comparison",Bold,14];netVertices=Range[25];graphCoords=Association[Table[i->{Mod[i-1,5]+RandomReal[{-0.1,0.1}],5-Quotient[i-1,5]+RandomReal[{-0.1,0.1}]},{i,netVertices}]];netEdges=Flatten[Table[{If[Mod[i,5]!=0,i\[UndirectedEdge]i+1,Sequence@@{}],If[i<=20,i\[UndirectedEdge]i+5,Sequence@@{}]},{i,netVertices}],1];failedNodes={7,8,12};failedEdges=Select[netEdges,MemberQ[failedNodes,#1[[1]]]||MemberQ[failedNodes,#1[[2]]]&];netGraph=Graph[netVertices,netEdges,VertexCoordinates->graphCoords,VertexSize->Medium,VertexLabels->Placed["Name",Center],EdgeStyle->Directive[Gray,Thin],VertexStyle->Directive[LightBlue],ImageSize->400,PlotRangePadding->Scaled[0.1],GraphHighlight->failedNodes,GraphHighlightStyle->Directive[Red,Thick]];styledGraph=Show[netGraph,Graph[failedNodes,failedEdges,VertexStyle->Red,EdgeStyle->{Red,Thick},VertexSize->Large],PlotLabel->Style["Hypothetical GVM Deployment on Mars\n(Resilient, Low-latency, Self-operating Network)",Bold,14],ImageSize->Large];(Row[{#1,Spacer[20],configText,Spacer[20],styledGraph}]&)[BarChart[{kubernetesValues,gvmValues},ChartLabels->Placed[metricsLabels,Below],ChartStyle->{kubColor,gvmColor},BarSpacing->0.4,ChartLegends->Placed[{"Kubernetes/Clos","GVM/IPU"},Above],PlotLabel->Style["Key Metric Comparison",Bold,14],ImageSize->450,Frame->True,FrameTicks->{{Automatic,None},{Automatic,None}},BaseStyle->{FontFamily->"Arial",FontSize->12},ScalingFunctions->{"Log10",None}]]]


Module[{metrics,metricsTable,latencyData,failureDomainGraph,scalingPlot,networkGraph,gvmColor=RGBColor[0.1,0.6,0.3],k8sColor=RGBColor[0.7,0.2,0.2],labels,figWidth=700},metrics={{"Configuration","Manual YAML, CNI plugins","Self-partitioning graph ops"},{"Operation","Human-tuned schedulers","Fully autonomous"},{"Security","Declarative + fragile","Dynamic + confined"},{"Latency (\[Micro]s)","10\[Dash]30","0.05\[Dash]0.1"},{"Failure Domain","Rack-wide (32+ nodes)","1\[Dash]8 nodes max"},{"Scaling Ceiling","n \[Tilde] 1,000","n \[GreaterEqual] 10,000 trivial"}};metricsTable=Grid[Prepend[({#1[[1]],Style[#1[[2]],k8sColor],Style[#1[[3]],gvmColor]}&)/@metrics,{Style["Metric",Bold,14],Style["Kubernetes/Clos",Bold,14],Style["GVM/IPU",Bold,14]}],Frame->All,Spacings->{2,1},Alignment->Left,Background->{None,{LightGray,None}}];latencyData={{"Kubernetes/Clos",20},{"GVM/IPU",0.075}};latencyChart=BarChart[latencyData[[All,2]],ChartLabels->Placed[latencyData[[All,1]],Below],BarSpacing->0.7,PlotRange->{0,25},Frame->True,FrameLabel->{"System","Latency (\[Micro]s)"},BaseStyle->{FontFamily->"Helvetica",FontSize->12},ChartStyle->{k8sColor,gvmColor},ImageSize->figWidth,PlotLabel->Style["Latency Comparison (Lower is Better)",Bold,14]];failureDomainGraph=Module[{k8sNodes,gvmNodes,k8sEdges,gvmEdges,k8sGraph,gvmGraph,k8sLayout,gvmLayout,combinedGraph},k8sNodes=Range[32];gvmNodes=Range[8];k8sEdges=UndirectedEdge@@@Partition[Append[k8sNodes,1],2,1];gvmEdges=UndirectedEdge@@@Partition[Append[gvmNodes,1],2,1];k8sGraph=Graph[k8sNodes,k8sEdges,VertexSize->Small,VertexStyle->k8sColor,GraphLayout->"CircularEmbedding",PlotLabel->Style["Kubernetes Failure Domain: Rack-wide (32+ nodes)",12]];gvmGraph=Graph[gvmNodes,gvmEdges,VertexSize->Medium,VertexStyle->gvmColor,GraphLayout->"CircularEmbedding",PlotLabel->Style["GVM Failure Domain: 1\[Dash]8 nodes max",12]];GraphicsRow[{k8sGraph,Spacer[30],gvmGraph},ImageSize->figWidth]];scalingPlot=BarChart[{1000,10000},ChartLabels->Placed[{"Kubernetes \[Tilde]1,000 nodes","GVM \[GreaterEqual]10,000 nodes"},Below],ChartStyle->{k8sColor,gvmColor},Frame->True,FrameLabel->{"System","Scaling Ceiling (Number of Nodes)"},BaseStyle->{FontFamily->"Helvetica",FontSize->12},ImageSize->figWidth,PlotLabel->Style["Scaling Ceiling Comparison",Bold,14]];Column[{Style["5.13 Why This Replaces Kubernetes: Comparative Metrics",Bold,16],metricsTable,Spacer[20],latencyChart,Spacer[20],failureDomainGraph,Spacer[20],scalingPlot,Spacer[20],Style["Figure 5.2: Hypothetical GVM deployment on Mars \[LongDash] resilient, low-latency, self-operating network under environmental duress.",Italic,12]},Spacings->2,Alignment->Center]]


Module[{metrics={"Configuration"->{"Manual YAML, CNI plugins","Self-partitioning graph ops"},"Operation"->{"Human-tuned schedulers","Fully autonomous"},"Security"->{"Declarative + fragile","Dynamic + confined"},"Latency (\[Micro]s)"->{"10-30","0.05-0.1"},"Failure Domain"->{"Rack-wide (32+ nodes)","1-8 nodes max"},"Scaling Ceiling (n)"->{"~1,000","\[GreaterEqual]10,000 (trivial)"}},metricNames,kubeVals,gvmVals,latencyKube=20,latencyGvm=0.075,kubeGridSize=6,gvmGridSize=20,kubeGraph,gvmGraph,textStyle=Directive[FontFamily->"Arial",FontSize->14,FontWeight->Bold],smallTextStyle=Directive[FontFamily->"Arial",FontSize->12],composedGraphics},metricNames=metrics[[All,1]];kubeVals=metrics[[All,2,1]];gvmVals=metrics[[All,2,2]];gridAdjacency[size_]:=Join[Flatten[Table[If[Mod[i,size]!=0,i\[UndirectedEdge]i+1,Nothing],{i,size^2}],1],Flatten[Table[If[i+size<=size^2,i\[UndirectedEdge]i+size,Nothing],{i,size^2}],1]];kubeGraph=Graph[Range[kubeGridSize^2],gridAdjacency[kubeGridSize],VertexSize->Small,GraphStyle->"NameLabeled",VertexLabels->None,ImageSize->300,GraphLayout->"GridEmbedding"];gvmGraph=Graph[Range[gvmGridSize^2],gridAdjacency[gvmGridSize],VertexSize->Tiny,GraphStyle->"NameLabeled",VertexLabels->None,ImageSize->300,GraphLayout->"GridEmbedding"];composedGraphics=Grid[{{Style["5.13 Why This Replaces Kubernetes: Metric Comparison",textStyle,Blue],\[SpanFromLeft]},{Grid[Prepend[MapThread[{Style[#1,Bold],Style[#2,Darker[Red]],Style[#3,Darker[Green]]}&,{metricNames,kubeVals,gvmVals}],{Style["Metric",Bold,14],Style["Kubernetes / Clos",Darker[Red],Bold,14],Style["GVM / IPU",Darker[Green],Bold,14]}],Frame->All,Spacings->{2,1},Alignment->Left,Background->{None,{Lighter[Red,0.9],Lighter[Green,0.9]}}],BarChart[{latencyKube,latencyGvm},ChartLabels->{"Kubernetes","GVM/IPU"},PlotLabel->"Latency (\[Micro]s) Comparison",BarSpacing->0.5,ChartStyle->{Red,Green},ImageSize->300,AxesLabel->{"System","Latency (\[Micro]s)"},ScalingFunctions->None,PlotRange->{0,25}]},{Style["Network Topology Simulation:",textStyle],\[SpanFromLeft]},{Column[{Style["Kubernetes/Clos Typical Network (Rack-wide ~32 nodes)",smallTextStyle],kubeGraph}],Column[{Style["Daedaelus GVM/IPU Large-scale Network (~10,000+ nodes)",smallTextStyle],gvmGraph}]},{Style["Summary and Mars-Scale Deployment Concept:",textStyle],\[SpanFromLeft]},{Pane[Column[{"\[Bullet] The Daedaelus GVM/IPU system replaces manual, fragile configuration with fully autonomous, self-partitioning graph operations.","\[Bullet] It achieves drastically lower latency (\[Tilde]50-100 ns) compared to Kubernetes (10-30 \[Micro]s), an improvement of approximately 200-400\[Times].","\[Bullet] Failure domains are drastically reduced, limiting impact to small node groups (1-8 nodes) versus entire racks (32+ nodes).","\[Bullet] Scalability is fundamentally improved from a ~1,000 node ceiling to trivial support for \[GreaterEqual]10,000 nodes, enabling Mars-scale deployments.","\[Bullet] These improvements collectively enable a resilient, low-latency, and self-operating network infrastructure under extreme environmental duress (e.g., Martian colonies)."}],ImageSize->600,Scrollbars->False,AppearanceElements->None,BaseStyle->{FontFamily->"Arial",FontSize->12}],\[SpanFromLeft]}},Alignment->Left,Spacings->{2,2}];composedGraphics]


Module[{n=4,randomInvertibleMatrix,T1,T2,T1inv,T2inv,v0,v1,v2,vRollback,snakeDiagram,gGraph,G,L,eigenValues,lambda2,fitoTimeline,reversibleTimeline,txtStyle=Directive[FontFamily->"Arial",FontSize->12]},randomInvertibleMatrix[dim_]:=Module[{m},While[True,m=RandomInteger[{0,1},{dim,dim}];If[Mod[Det[m],2]==1,Return[m]]]];f2MatMul[a_,b_]:=Mod[a . b,2];T1=randomInvertibleMatrix[n];T2=randomInvertibleMatrix[n];T1inv=Inverse[T1,Modulus->2];T2inv=Inverse[T2,Modulus->2];v0=RandomInteger[{0,1},{n,1}];v1=f2MatMul[T1,v0];v2=f2MatMul[T2,v1];vRollback=f2MatMul[T1inv,f2MatMul[T2inv,v2]];snakeDiagram=Graphics[{Thick,Blue,Circle[{0.5,0.5},0.4],Arrowheads[0.06],Green,Arrow[Circle[{0.5,0.5},0.4,{\[Pi]/4,(3 \[Pi])/2}]],Text[Style["Head(Tv)",Bold,Green],{0.5,1.1}],Red,Arrow[Circle[{0.5,0.5},0.4,{(3 \[Pi])/2,\[Pi]/4}]],Text[Style["Tail(T\:207b\.b9)",Bold,Red],{0.5,-0.1}]},ImageSize->250,PlotLabel->Style["Transaction Circulation Model",Bold]];gGraph=Graph[{1, 2, 3, 4}, {UndirectedEdge[1, 2], UndirectedEdge[2, 3], UndirectedEdge[3, 4], UndirectedEdge[4, 1], UndirectedEdge[1, 3], UndirectedEdge[2, 4]}, {GraphLayout -> "SpringElectricalEmbedding", VertexLabels -> {"Name"}}];L=GraphLaplacianMatrix[gGraph];eigenValues=Sort[Eigenvalues[N[L]]];lambda2=If[Length[eigenValues]>=2,eigenValues[[2]],0];G=Show[gGraph,EdgeStyle->Thick,ImageSize->Medium,PlotLabel->Style["Reversible Transaction Graph",Bold,14]];fitoTimeline=Graphics[{Text[Style["FITO: Forward-Only",Bold,12],{1.5,1}],Red,Thick,Arrowheads[0.05],Arrow[{{0,0.5},{4,0.5}}],Table[{Black,Line[{{t,0.4},{t,.6}}],Text[Style["Op"<>ToString[i],12],{t,.75}]},{i,1,4},{t,i-1}]},PlotRange->{{-0.5,4.5},{0,1.2}},ImageSize->300];reversibleTimeline=Graphics[{Text[Style["Daedaelus: Reversible",Bold,12],{1.5,1}],Blue,Thick,Arrowheads[0.05],Arrow[{{0,0.5},{2,0.5}}],Red,Dashed,Arrow[{{2,0.5},{0,0.5}}],Table[{Black,Line[{{t,0.4},{t,.6}}],Text[Style["Op"<>ToString[i],12],{t,.75}]},{i,1,2},{t,i-1}],Text[Style["Rollback Possible",Italic,Red],{1,.2}]},PlotRange->{{-0.5,4.5},{0,1.2}},ImageSize->300];Column[{Style["5.14 Rethinking Atomicity: Counterfactual Transactions",Bold,18,FontFamily->"Helvetica"],Spacer[10],Grid[{{Column[{Style["Mathematical Formulation over \|01d53d\:2082\:207f:",Bold,14],Grid[{{"Initial State v\:2080:",MatrixForm[v0]},{"Forward Transform T\:2081:",MatrixForm[T1]},{"Forward Transform T\:2082:",MatrixForm[T2]},{"Transformed v\:2082 = T\:2082\[CenterDot]T\:2081\[CenterDot]v\:2080:",MatrixForm[v2]},{"Reversed State:",Column[{MatrixForm[vRollback],Style["Perfect Recovery!",Green,Bold]},Alignment->Center]}},Frame->All,Spacings->{1,1},Alignment->Left,ItemStyle->txtStyle]}],Column[{Style["Transaction Models:",Bold,14],snakeDiagram,Spacer[10],G,Style[StringForm["Resilience Metric: \[Lambda]\:2082(G) = ``", NumberForm[lambda2, {3, 2}]],Bold,14,Darker[Green,.2]]},Alignment->Center]}},BaseStyle->{12,"Panel"}],Spacer[20],Style["Timeline Comparison: FITO vs Reversible Causality",Bold,14],Row[{fitoTimeline,Spacer[20],reversibleTimeline},Alignment->Center]},Spacings->2,Alignment->Center]]


Module[{n=4,k=5,Ts,Tsinv,v0,states,rollbackAt=3,txtStyle=Directive[FontFamily->"Arial",FontSize->12]},randomInvertibleMatrix[dim_]:=Module[{m},While[True,m=RandomInteger[{0,1},{dim,dim}];If[Mod[Det[m],2]==1,Return[m]]]];Ts=Table[randomInvertibleMatrix[n],{k}];Tsinv=(Inverse[#1,Modulus->2]&)/@Reverse[Ts];v0=RandomInteger[{0,1},{n,1}];states=FoldList[Mod[#2 . #1,2]&,v0,Ts];vRollback=Fold[Mod[#2 . #1,2]&,states[[-1]],Take[Tsinv,k-rollbackAt+1]];Grid[{{"Step","State (vector)"},Sequence@@Table[{i-1,MatrixForm[states[[i]]]},{i,Length[states]}],{"Rollback after step "<>ToString[rollbackAt-1],MatrixForm[vRollback]}},Alignment->Left,ItemStyle->txtStyle]]


Module[{n=4,k=5,rollbackAt=3,seqWidth=4,nestedTxLevels=3,txtStyle=Directive[FontFamily->"Arial",FontSize->12],Ts,Tsinv,v0,states,vRollback,randomInvertibleMatrix,step,chainOutput,conflictEdges,conflictGraph,conflictOutput,consensusStates,consensusOutput,faultyEdges,recoveryGraph,faultRecoveryOutput,seqNums,wrappedSeqNums,seqCounterOutput,txStates,txTree,nestedTxOutput},randomInvertibleMatrix[dim_]:=Module[{m},While[True,m=RandomInteger[{0,1},{dim,dim}];If[Mod[Det[m],2]==1,Return[m]]]];Ts=Table[randomInvertibleMatrix[n],{k}];Tsinv=(Inverse[#1,Modulus->2]&)/@Reverse[Ts];v0=RandomInteger[{0,1},n];step[vec_,mat_]:=Mod[mat . vec,2];states=FoldList[step,v0,Ts];vRollback=Fold[step,Last[states],Take[Tsinv,k-rollbackAt+1]];chainOutput=Grid[Join[{{"Step","State"}},Table[{i-1,MatrixForm[states[[i]],TableAlignments->Center]},{i,Length[states]}],{{"Rollback after step "<>ToString[rollbackAt-1],MatrixForm[vRollback,TableAlignments->Center]}}],Alignment->Left,ItemStyle->txtStyle];conflictEdges={1<->2,2<->3,3<->4,4<->1,1<->3,2<->4};conflictGraph=Graph[conflictEdges,VertexLabels->"Name",EdgeStyle->Join[Thread[{1<->3,2<->4}->Red],Thread[Complement[conflictEdges,{1<->3,2<->4}]->Black]],GraphLayout->"SpringElectricalEmbedding",PlotLabel->Style["Transaction Conflict Graph (Red = Conflict)",Bold,14],ImageSize->Medium];conflictOutput=conflictGraph;consensusStates=NestList[Module[{vals=#1,avg},avg=Mod[Round[Mean[vals]],2];If[RandomReal[]<0.3,Prepend[Rest[#1],avg],ConstantArray[avg,Length[#1]]]]&,RandomInteger[{0,1},4],5];consensusOutput=Grid[Prepend[Table[{"Step "<>ToString[i],consensusStates[[i+1]]},{i,Length[consensusStates]-1}],{"Step","Node States"}],Alignment->Left,ItemStyle->txtStyle];faultyEdges=RandomSample[conflictEdges,2];recoveryGraph=EdgeDelete[conflictGraph,faultyEdges];faultRecoveryOutput=Grid[{{Style["Faulty Edges (Removed):",Bold,12],faultyEdges},{Style["Network after Faults:",Bold,12],recoveryGraph}},Alignment->Left,ItemStyle->txtStyle];seqNums=Range[0,2^seqWidth+3];wrappedSeqNums=Mod[seqNums,2^seqWidth];seqCounterOutput=ListLinePlot[Transpose[{seqNums,wrappedSeqNums}],Mesh->All,MeshStyle->Red,PlotMarkers->Automatic,AxesLabel->{"Time","Sequence Number"},PlotLabel->Style["Reversible Modulo Sequence Numbers",Bold,14],ImageSize->Medium];txStates=Table[RandomInteger[{0,1},n],{nestedTxLevels}];txTree=Graph[Table[i<->i+1,{i,nestedTxLevels-1}],VertexLabels->"Name",GraphLayout->"LayeredDigraphEmbedding",PlotLabel->Style["Nested Reversible Transactions (Linear Chain)",Bold,14],ImageSize->Medium];nestedTxOutput=Grid[Join[{{"Nested Transaction States (per level):"}},Table[{"Level "<>ToString[i],MatrixForm[txStates[[i]],TableAlignments->Center]},{i,nestedTxLevels}],{{"Transaction Graph:",txTree}}],Alignment->Left,ItemStyle->txtStyle];Column[{Style["1. State Propagation & Rollback",Bold,16],chainOutput,Spacer[15],Style["2. Conflict Graph",Bold,16],conflictOutput,Spacer[15],Style["3. Simple Consensus Evolution",Bold,16],consensusOutput,Spacer[15],Style["4. Fault Injection & Recovery",Bold,16],faultRecoveryOutput,Spacer[15],Style["5. Sequence Number Wraparound",Bold,16],seqCounterOutput,Spacer[15],Style["6. Nested / Hyper-Transactions",Bold,16],nestedTxOutput},Spacings->2,Alignment->Center]]


Module[{n=4,k=5,rollbackAt=3,maxDegree=8,seqCounterLength=4,nestedTxTree,displayStyle=Directive[FontFamily->"Arial",FontSize->12],genRandomInvMat,step,Tchain,TchainInv,v0,states,vRollback,reversibleChainGrid,conflictGraph,consensusGraph,networkGraph,failedEdges,graphAfterFailures,laplacian,lambda2,resilienceText,seqMax,seqNums,revIncrement,seqPlot},genRandomInvMat[dim_]:=Module[{m},While[True,m=RandomInteger[{0,1},{dim,dim}];If[Mod[Det[m],2]==1,Return[m]]]];step[vec_,mat_]:=Mod[mat . vec,2];Tchain=Table[genRandomInvMat[n],{k}];TchainInv=(Inverse[#1,Modulus->2]&)/@Reverse[Tchain];v0=RandomInteger[{0,1},n];states=FoldList[step,v0,Tchain];vRollback=Fold[step,Last[states],Take[TchainInv,k-rollbackAt+1]];reversibleChainGrid=Grid[Prepend[Join[Table[{i-1,MatrixForm[states[[i]],TableAlignments->Center]},{i,Length[states]}],{{"Rollback after step "<>ToString[rollbackAt-1],MatrixForm[vRollback,TableAlignments->Center]}}],{"Step","State vector"}],Alignment->Left,ItemStyle->displayStyle];conflictGraph=Graph[{1, 2, 3, 4}, {UndirectedEdge[1, 2], UndirectedEdge[2, 4], UndirectedEdge[3, 4], UndirectedEdge[1, 3]}, {GraphStyle -> "NameLabeled", ImageSize -> Medium, PlotLabel -> Style["Transaction Conflict Graph", Bold, 14], VertexLabels -> {"Name"}}];consensusGraph=Graph[{1, 2, 3}, {UndirectedEdge[1, 2], UndirectedEdge[2, 3], UndirectedEdge[3, 1]}, {GraphStyle -> "NameLabeled", ImageSize -> Medium, PlotLabel -> Style["Reversible Consensus Triangle", Bold, 14], VertexLabels -> {"Name"}}];networkGraph=Graph[Range[6],{1<->2,2<->3,3<->4,4<->5,5<->6,6<->1,1<->4,2<->5},VertexLabels->"Name",EdgeStyle->Directive[Thin,Gray],GraphStyle->"NameLabeled",PlotLabel->Style["Network Graph Before Failures",Bold,14],ImageSize->Medium];failedEdges=Take[EdgeList[networkGraph],2];graphAfterFailures=EdgeDelete[networkGraph,failedEdges];laplacian=If[VertexList[graphAfterFailures]==={},{},GraphLaplacianMatrix[graphAfterFailures]];lambda2=If[laplacian==={}||Length[laplacian]<2,0,Sort[Eigenvalues[N[laplacian]]][[2]]];resilienceText=Style[StringForm["Algebraic Connectivity (\[Lambda]\:2082) after failures: ``", NumberForm[lambda2, {3, 3}]],Bold,14,Darker[Green,0.3]];seqMax=2^seqCounterLength;seqNums=Range[0,seqMax-1];revIncrement[x_]:=Mod[x+1,seqMax];seqPlot=ListLinePlot[Table[{i,revIncrement[i]},{i,seqNums}],PlotRange->All,AxesLabel->{"Sequence Number","Incremented"},PlotLabel->Style["Reversible Modulo Counter Increment",Bold,14],Mesh->All,MeshStyle->Red,ImageSize->350];nestedTxTree=Graph[{1, 2, 3, 4, 5}, {DirectedEdge[1, 2], DirectedEdge[1, 3], DirectedEdge[3, 4], DirectedEdge[3, 5]}, {GraphStyle -> "NameLabeled", ImageSize -> Medium, PlotLabel -> Style["Nested Reversible Subtransactions", Bold, 14], VertexLabels -> {"Name"}}];Column[{Style["1. Reversible State Chain & Rollback",Bold,16],reversibleChainGrid,Spacer[20],Style["2. Conflict Graph",Bold,16],conflictGraph,Spacer[20],Style["3. Reversible Consensus Protocol Sketch",Bold,16],consensusGraph,Spacer[20],Style["4. Network Fault and Recovery Simulation",Bold,16],networkGraph,resilienceText,Spacer[20],Style["5. Sequence Numbers as Reversible Modulo Counters",Bold,16],seqPlot,Spacer[20],Style["6. Nested and Hyper-transactions",Bold,16],nestedTxTree,Spacer[20]},Alignment->Center]]


Module[{n=5,v0,T1,T2,v1,v2,T1i,T2i,Tc,Tci,randInv,inv2,comp2,lambda2,g,badEdges,graphSeq,dlr,base=Directive[FontFamily->"Arial",12],head=Directive[Bold,17,Purple],sub=Directive[Bold,14,Darker[Blue]]},randInv[d_]:=Module[{m},While[True,m=RandomInteger[{0,1},{d,d}];If[Mod[Det[m],2]==1,Return[Mod[m,2]]]]];inv2[m_]:=Mod[Inverse[m,Modulus->2],2];comp2[ms__]:=Fold[Mod[#2 . #1,2]&,IdentityMatrix[n],{ms}];v0=RandomInteger[{0,1},n];T1=randInv[n];T1i=inv2[T1];T2=randInv[n];T2i=inv2[T2];v1=Mod[T1 . v0,2];v2=Mod[T2 . v1,2];Tc=comp2[T2,T1];Tci=inv2[Tc];alg=Grid[{{"init  \(v_0\)",MatrixForm[v0]},{"\(T_1\)",MatrixForm[T1]},{"\(T_2\)",MatrixForm[T2]},{"\(T_1^{-1}\)",MatrixForm[T1i]},{"\(T_2^{-1}\)",MatrixForm[T2i]},{"\(T_2 T_1\)",MatrixForm[Tc]},{"\((T_2 T_1)^{-1}\)",MatrixForm[Tci]},{"result \(v_2\)",MatrixForm[v2]}},Alignment->Left,Spacings->{2,1},BaseStyle->base];oneSide[title_,arrows_,pts_]:=Graphics[{Text[Style[title,Bold,13],{2.5,1.2}],Arrow/@arrows,PointSize[0.03],Point/@pts},Axes->False,PlotRange->{{-0.5,5.5},{-1.5,1.5}},ImageSize->300];timeGrid=GraphicsGrid[{{oneSide["FITO",{{{0,0},{5,0}}},{{0,0},{5,0},{3,0}}],oneSide["Reversible",{{{0,0},{2,0}},{{2,0},{5,0}},{{2,0},{4,-1}}},{{0,0},{2,0},{4,-1},{5,0}}]}},Spacings->2];snake=Graphics[{Arrowheads[0.04],Thick,Blue,Arrow[{{0,0},{3,0},{3,2},{0,2},{0,0}}],Text[Style["head (Tv)",Bold,Blue],{1.5,2.4}],Text[Style["tail (T\:207b\.b9)",Bold,Blue],{1.5,-0.4}],Dashed,Red,Line[{{3,0},{4,1},{3,2}}],Text[Style["close\[RightArrow]commit",Red,Italic],{3.8,1}]},ImageSize->400];g=Graph[{1, 2, 3, 4, 5}, {UndirectedEdge[1, 2], UndirectedEdge[2, 3], UndirectedEdge[3, 4], UndirectedEdge[4, 5], UndirectedEdge[5, 1], UndirectedEdge[2, 5], UndirectedEdge[3, 1]}, {ImageSize -> 300, VertexLabels -> {"Name"}}];badEdges=RandomSample[EdgeList[g],2];graphSeq=FoldList[EdgeDelete,g,badEdges];lambda2[gr_]:=Module[{ev=Sort[N[Eigenvalues[LaplacianMatrix[gr]]]]},If[Length[ev]>=2,ev[[2]],0]];dlr=Mean[lambda2/@graphSeq];showG=Graph[g,EdgeStyle->e_:>If[MemberQ[badEdges,e],Red,Darker[Blue]],VertexLabels->"Name",ImageSize->300];Grid[{{Style["Toward Reversible Thinking (\[Section]5.18\[Dash]5.29)",head],\[SpanFromLeft]},{timeGrid,\[SpanFromLeft]},{Style["Algebraic model (\|01d53d\:2082)",sub],\[SpanFromLeft]},{alg,\[SpanFromLeft]},{snake,\[SpanFromLeft]},{Style[Row[{"DLR (robustness) = ",NumberForm[dlr,{3,3}]}],Bold,Darker[Orange]],\[SpanFromLeft]},{showG,\[SpanFromLeft]}},Spacings->{2,3}]]


Module[{n=4,k=5,seqWidth=4,failSteps=4,display=Directive[FontFamily->"Helvetica",FontSize->12],randInv,step,T,Tinv,v0,vStates,vRollback,reversiblePanel,braidGraphic,causalDAG,twoPhaseGraphic,spanningTreeGraph,styleEdge,lambdas,dlrPlot},randInv[d_]:=Module[{m},While[True,m=RandomInteger[{0,1},{d,d}];If[Mod[Det[m],2]==1,Return[m]]]];step[vec_,mat_]:=Mod[mat . vec,2];T=Table[randInv[n],{k}];Tinv=(Inverse[#1,Modulus->2]&)/@Reverse[T];v0=RandomInteger[{0,1},n];vStates=FoldList[step,v0,T];vRollback=Fold[step,Last[vStates],Tinv];reversiblePanel=Grid[Prepend[Table[{i-1,MatrixForm[vStates[[i]]]},{i,Length[vStates]}],{"Step","State v"}],ItemStyle->display,Alignment->Left,Frame->All,Spacings->{1,1}];braidGraphic=Graphics[Table[{ColorData[97,i],Thick,BezierCurve[Table[{j,Sin[(i+j)/2]+0.3 i},{j,0,k}]]},{i,0,3}],PlotLabel->Style["Braided Transaction Log",Bold,14],ImageSize->350];causalDAG=Graph[{a, b, c, d, e}, {DirectedEdge[a, b], DirectedEdge[a, c], DirectedEdge[b, d], DirectedEdge[c, d], DirectedEdge[d, e]}, {GraphLayout -> "LayeredDigraphEmbedding", ImageSize -> Medium, PlotLabel -> Style["Precise Causal Dependencies", Bold, 14], VertexLabels -> {"Name"}}];twoPhaseGraphic=Graphics[{Black,Thick,Arrowheads[Medium],Arrow[{{0,0},{4,0}}],Text["Phase 1: Tentative Send (T)",{2,0.3}],Red,Arrow[{{4,-1},{0,-1}}],Text[Style["Phase 2: Rollback (T\\u207b\\u00b9)",Red],{2,-1.3}],Dashed,Line[{{0,0},{0,-1}}],Line[{{4,0},{4,-1}}],Text["Initiator",{-0.7,0}],Text["Responder",{-0.7,-1}]},PlotRange->{{-1,5},{-1.6,0.6}},PlotLabel->Style["Two-Phase Reversible Handshake",Bold,14],ImageSize->400];n=2^3;spanningTreeGraph=Graph[Range[n],Table[i->RandomInteger[{1,i-1}],{i,2,n}],VertexLabels->"Name"];styleEdge=Directive[Gray,Thin];lambdas=Table[Module[{gFail=EdgeDelete[spanningTreeGraph,RandomSample[EdgeList[spanningTreeGraph],i]]},If[ConnectedGraphQ[gFail],Sort[Eigenvalues[N[GraphLaplacianMatrix[gFail]]]][[2]],0]],{i,0,failSteps}];dlrPlot=ListPlot[lambdas,Joined->True,Mesh->All,AxesLabel->{"# Failures","\[Lambda]_2 (Connectivity)"},PlotLabel->Style["Dynamic Laplacian Resilience (DLR)",Bold,14],ImageSize->350];Column[{Style["5.18 Rethinking Atomicity & Reversible Transactions",Bold,20,FontFamily->"Helvetica"],Grid[{{Column[{Style["1. Reversible State Chain (v' = T \[CenterDot] v)",Bold,16],reversiblePanel},Spacings->1],Column[{Style["2. Counterfactual Braided Log",Bold,16],braidGraphic},Spacings->1]},{Column[{Style["3. Causal Dependency DAG",Bold,16],causalDAG},Spacings->1],Column[{Style["4. Spanning Tree & Resilience",Bold,16],dlrPlot},Spacings->1]},{Column[{Style["5. Two-Phase Reversible Handshake",Bold,16],twoPhaseGraphic},Spacings->1,Alignment->Center]}},Spacings->{2,3}]},Alignment->Center,Spacings->2]]


Module[{bits=4,radius=1,verts,coords,fwd,rev,edgeColours},verts=Range[0,2^bits-1];coords=Association[Table[v->radius {Cos[(2 \[Pi] v)/2^bits],Sin[(2 \[Pi] v)/2^bits]},{v,verts}]];fwd=(#1\[DirectedEdge]Mod[#1+1,2^bits]&)/@verts;rev=(#1\[DirectedEdge]Mod[#1-1,2^bits]&)/@verts;edgeColours=Join[Thread[fwd->Directive[Blue,Arrowheads[0.03]]],Thread[rev->Directive[Red,Arrowheads[0.03]]]];Graph[verts,Join[fwd,rev],VertexCoordinates->coords,VertexLabels->v_:>v,EdgeStyle->edgeColours,VertexSize->0.05,PlotRangePadding->Scaled[0.1],PlotLabel->Style[Row[{"Reversible Counter  (mod ",2^bits,")"}],Bold,14],ImageSize->350]]


Module[{n=4,k=5,rollbackStep=3,maxFailures=2,genRandomInvMat,gf2Mul,Tchain,TinvChain,v0,forwardStates,rollbackStates,forwardGrid,rollbackGrid,snakeGraphic,composedT,composedTinv,graph,spanningTree,laplacian,eigenvals,dlr},genRandomInvMat:=Module[{m},While[True,m=RandomInteger[{0,1},{n,n}];If[Mod[Det[m],2]==1,Return[m]]]];gf2Mul[a_,b_]:=Mod[a . b,2];Tchain=Table[genRandomInvMat,{k}];TinvChain=Reverse[(Inverse[#1,Modulus->2]&)/@Tchain];v0=RandomInteger[{0,1},n];forwardStates=FoldList[gf2Mul,v0,Tchain];rollbackStates=Module[{startVec=forwardStates[[rollbackStep+1]]},FoldList[gf2Mul,startVec,Take[TinvChain,k-rollbackStep]]];forwardGrid=Grid[Prepend[Table[{Style["Step "<>ToString[i-1],Bold],MatrixForm[forwardStates[[i]]]},{i,Length[forwardStates]}],{"Step","State Vector (v)"}],Frame->All,Alignment->{Left,Center}];rollbackGrid=Grid[Prepend[Table[{Style["Rollback "<>ToString[i-1],Bold],MatrixForm[rollbackStates[[i]]]},{i,Length[rollbackStates]}],{"Rollback Step","State Vector (v)"}],Frame->All,Alignment->{Left,Center}];snakeGraphic=Graphics[{Blue,Thick,Arrowheads[0.05],Arrow[Circle[{0,0},1,{0,2 \[Pi]-\[Pi]/4}]],Red,Thick,Dashed,Arrowheads[-0.05],Arrow[Circle[{0,0},1,{2 \[Pi]-\[Pi]/4,2 \[Pi]}]],Text[Style["Head (T)",Blue,Bold],{0,1.2}],Text[Style["Tail (T\:207b\.b9)",Red,Bold],{1.2,-0.9}]},ImageSize->250,PlotLabel->"Transaction Snake Model"];graph=CompleteGraph[6,VertexLabels->"Name",ImageSize->300,PlotLabel->"Network Fabric Graph (K_6)"];spanningTree=FindSpanningTree[graph];laplacian=N[GraphLaplacianMatrix[graph]];eigenvals=Sort[Eigenvalues[laplacian]];dlr=Module[{Gi,eigs,sum=0},Do[Gi=EdgeDelete[graph,RandomSample[EdgeList[graph],i]];eigs=Sort[Eigenvalues[N[GraphLaplacianMatrix[Gi]]]];sum+=If[Length[eigs]>1,eigs[[2]],0],{i,0,maxFailures}];sum/(maxFailures+1)];Column[{Style["\[Section]\[Section] 5.18-5.29: Reversible & Counterfactual Transactions",18,Bold,FontFamily->"Helvetica"],Grid[{{Column[{Style["Forward State Chain (v\:1d62 = T\:1d62\:22c5v\:1d62\:208b\:2081)",Bold],forwardGrid},Alignment->Center],Column[{Style["Rollback from Step "<>ToString[rollbackStep]<>" (Applying T\:207b\.b9)",Bold],rollbackGrid},Alignment->Center]}},Frame->All,Spacings->{2,2}],Spacer[15],Grid[{{Column[{Style["Transaction 'Snake' Model",Bold],snakeGraphic},Alignment->Center],Column[{Style["Network Resilience (DLR)",Bold],Show[graph,Highlighting->spanningTree,ImageSize->300,PlotLabel->"Fabric with Spanning Tree (Ts)"],Text[Style[StringForm["DLR Metric (avg \[Lambda]\:2082) = ``", NumberForm[dlr, {3, 2}]],Bold]]},Alignment->Center]}}]},Alignment->Center,Spacings->1]]


Module[{n=6,k=5,commitStep=5,genRandomInvMat,gf2MatMul,gf2VecMul,Tchain,TchainInv,v0,vStates,vRollback,displayGrid,twoPhaseSimulationPanel,snakeVisualization,algebraicClosureCheck,idMatrix,composedT,composedTinv},genRandomInvMat[dim_]:=Module[{m},While[True,m=RandomInteger[{0,1},{dim,dim}];If[Mod[Det[m],2]==1,Return[m]]]];gf2MatMul[A_,B_]:=Mod[A . B,2];gf2VecMul[M_,v_]:=Mod[M . v,2];Tchain=Table[genRandomInvMat[n],{k}];TchainInv=Reverse[(Inverse[#1,Modulus->2]&)/@Tchain];v0=RandomInteger[{0,1},n];vStates=FoldList[gf2VecMul,v0,Tchain];vRollback=Fold[gf2VecMul,Last[vStates],TchainInv];composedT=Fold[gf2MatMul,IdentityMatrix[n],Tchain];composedTinv=Fold[gf2MatMul,IdentityMatrix[n],Reverse[TchainInv]];algebraicClosureCheck=gf2MatMul[composedTinv,composedT]==IdentityMatrix[n];displayGrid=Grid[Prepend[Table[{Style["Step "<>ToString[i-1],Bold],MatrixForm[Tchain[[i]]],VectorForm[vStates[[i]]],VectorForm[vStates[[i+1]]]},{i,k}],{"Step","T_i (Transaction Matrix)","v_{i-1} (Input Vector)","v_i = T_i v_{i-1} (Output Vector)"}],Frame->All,Alignment->{Left,Center},Spacings->{1,2}];twoPhaseSimulationPanel:=DynamicModule[{phase="Initial",currentStep=1,maxStep=k,vCurrent=v0,vCommitted=v0,ackStatus="None"},Panel[Column[{Style["Two-Phase Semantics Simulation",Bold,16],Row[{Button["Send Tentative",phase="Tentative";vCurrent=gf2VecMul[Tchain[[currentStep]],vCurrent];,Enabled->phase=="Initial"||phase=="Committed"],Button["Acknowledge (Commit)",phase="Committed";vCommitted=vCurrent;ackStatus="Acknowledged";,Enabled->phase=="Tentative"],Button["Rollback (Inverse)",phase="Rolled Back";vCurrent=gf2VecMul[Inverse[Tchain[[currentStep]],Modulus->2],vCurrent];ackStatus="Rolled Back";,Enabled->phase=="Tentative"],Button["Reset",phase="Initial";currentStep=1;vCurrent=v0;vCommitted=v0;ackStatus="None";]}],Dynamic[Panel[Grid[{{"Phase:",Style[phase,Bold]},{"Tentative State v:",MatrixForm[vCurrent]},{"Committed State v:",MatrixForm[vCommitted]},{"ACK Status:",Style[ackStatus,Bold]}},Alignment->Left]]]},Alignment->Center]]];snakeVisualization:=Module[{snakeLength=12,angleStep,positions},angleStep=(2 \[Pi])/snakeLength;positions=Table[{Cos[angleStep i],Sin[angleStep i]},{i,0,snakeLength-1}];Graphics[{{Blue,Thick,Arrowheads[0.04],Arrow[Circle[{0,0},1,{0,\[Pi]}]]},{Red,Thick,Dashed,Arrowheads[0.04],Arrow[Circle[{0,0},1,{\[Pi],2 \[Pi]}]]},Text[Style["Head(Tv)",Blue,Bold,14],{0,1.2}],Text[Style["Tail(T\:207b\.b9)",Red,Bold,14],{0,-1.2}],{PointSize[Large],Blue,Point[Take[positions,snakeLength/2]]},{PointSize[Large],Red,Point[Drop[positions,snakeLength/2]]}},ImageSize->300,PlotLabel->Style["Snake-Based Circulation Model",Bold]]];Column[{Style["Reversible Transactions over a Single Ethernet Link",Bold,18,FontFamily->"Helvetica"],Spacer[10],Grid[{{Style["Initial Frame Vector v\:2080:",Bold],MatrixForm[v0]},{Style["Final Rolled-Back State:",Bold],MatrixForm[vRollback]},{Style["Perfect Recovery? (v_rollback == v_0)",Bold],Style[vRollback===v0,If[vRollback===v0,Darker[Green],Red],Bold]}},Alignment->Left],Spacer[10],Style["Transaction Chain States (v_i = T_i v_{i-1}):",Bold],displayGrid,Spacer[15],Grid[{{Column[{Style["Two-Phase Commit Semantics (Interactive)",Bold],twoPhaseSimulationPanel}],Column[{Style["Snake-Based Circulation Model",Bold],snakeVisualization}]}}]},Alignment->Center,Spacings->1]]


Module[{n=6,k=4,seed=12345,v0,Tchain,TchainInv,vStates,vRollback,displayStatesGrid,snakeVisualization,homologyCheck,vCommitted},genInvertibleMatrix[dim_]:=Module[{m},While[True,m=RandomInteger[{0,1},{dim,dim}];If[Mod[Det[m],2]==1,Return[m]]]];gf2Mul[a_,b_]:=Mod[a . b,2];gf2Inv[m_]:=Inverse[m,Modulus->2];SeedRandom[seed];v0=RandomInteger[{0,1},n];Tchain=Table[genInvertibleMatrix[n],{k}];TchainInv=Reverse[gf2Inv/@Tchain];vStates=FoldList[gf2Mul,v0,Tchain];vRollback=Fold[gf2Mul,Last[vStates],TchainInv];homologyCheck=Fold[gf2Mul,IdentityMatrix[n],Tchain];displayStatesGrid[states_]:=Grid[Prepend[Table[{i-1,StringJoin[ToString/@states[[i]]]},{i,Length[states]}],{"Step","Vector (binary)"}],Frame->All,Alignment->Left,Dividers->Center];snakeVisualization:=Module[{snakeLength=k+1,frames},frames=Range[snakeLength];Graph[Table[i<->i+1,{i,snakeLength-1}],VertexLabels->"Name",VertexStyle->Thread[frames->PadRight[{Red},snakeLength,Blue]],GraphLayout->"LinearEmbedding",PlotLabel->Style["Snake Model: Transaction Head (Red) and Tail (Blue)",Bold,14],ImageSize->Medium]];vCommitted=Last[vStates];Column[{Style["Reversible Transactions over a Single Ethernet Link",Bold,18,FontFamily->"Helvetica"],Pane[Grid[{{Style["Rollback Recovers Initial Vector?",Bold],Style[vRollback==v0,If[vRollback==v0,Darker[Green],Red],Bold]},{Style["Homology Closure (T_k...T_1 = I)?",Bold],Style[homologyCheck==IdentityMatrix[n],If[homologyCheck==IdentityMatrix[n],Darker[Green],Orange],Bold]}},Alignment->Left,Spacings->{2,1}],ImageSize->500],Grid[{{Style["Forward Transaction States (v0 to v_k):",Bold],Style["Rollback to v0:",Bold]},{displayStatesGrid[vStates],StringJoin[ToString/@vRollback]}},Dividers->Center,Alignment->Top],snakeVisualization},Alignment->Center,Spacings->1]]


n=6;
k=5;
seed=1234;RandomSeed[seed];
GenerateRandomInvMatrix[dim_]:=Module[{m},While[True,m=RandomInteger[{0,1},{dim,dim}];If[Mod[Det[m],2]==1,Return[m]]]];
GF2MatVecMul[m_,v_]:=Mod[m . v,2];
GF2MatMul[m1_,m2_]:=Mod[m1 . m2,2];
Tchain=Table[GenerateRandomInvMatrix[n],{k}];
TchainInv=(Inverse[#1,Modulus->2]&)/@Tchain;
v0=RandomInteger[{0,1},n];
vStates=FoldList[GF2MatVecMul,v0,Tchain];
RollbackState[vEnd_,TList_,start_,end_]:=Fold[GF2MatVecMul,vEnd,Take[TList,{start+1,end}]]
rollbackExample=RollbackState[Last[vStates],Reverse[Take[TchainInv,2]],0,1];
transactionTable=Table[{i,MatrixForm[vStates[[i+1]]]},{i,0,k}];
rollbackTable={{"Rollback Example (last 2 transactions) from v_"<>ToString[k],MatrixForm[rollbackExample]}};
stateEvolutionPlot=ListPlot[Table[{i,FromDigits[vStates[[i+1]],2]},{i,0,k}],Joined->True,PlotMarkers->Automatic,PlotRange->All,AxesLabel->{"Transaction step","Decimal Frame Vector Value"},PlotLabel->"Evolution of Frame Vector Through Transactions"];
Ttotal=Fold[GF2MatMul,IdentityMatrix[n],Reverse[Tchain]];
totalInv=Inverse[Ttotal,Modulus->2];
identityCheck=Mod[totalInv . Ttotal,2];
Grid[{{"Total Composed Transformation T_total:",MatrixForm[Ttotal]},{"Inverse of T_total:",MatrixForm[totalInv]},{"Product Inverse * T_total (Should be Identity):",MatrixForm[identityCheck]}}]
isClosedCycle=identityCheck===IdentityMatrix[n];
snakeCycleSteps=k+2;
headPositions=Table[{Cos[(2 \[Pi] i)/snakeCycleSteps],Sin[(2 \[Pi] i)/snakeCycleSteps]},{i,0,snakeCycleSteps-1}];
tailPositions=Reverse[headPositions];
snakeGraphics=Graphics[{Thick,Blue,Line[headPositions],Red,Line[tailPositions],Table[{Blue,Disk[headPositions[[i]],0.05],Text[Style["H",Blue,Bold],headPositions[[i]]+{0.1,0}]},{i,1,snakeCycleSteps,snakeCycleSteps-1}],Table[{Red,Disk[tailPositions[[i]],0.05],Text[Style["T",Red,Bold],tailPositions[[i]]+{-0.1,0}]},{i,1,snakeCycleSteps,snakeCycleSteps-1}],Black,Text["Commit Point (Head meets Tail)",{0,0}]}];
Column[{Style["Reversible Transactions Over Single Ethernet Link",Bold,16],Style["Transaction States v_i = T_i ... T_1 v0:",Bold,14],Grid[transactionTable,Frame->All,Alignment->Left],Spacer[10],Style["Rollback Example: Rollback last 2 transactions:",Bold,14],Grid[rollbackTable,Frame->All,Alignment->Left],Spacer[10],Style["Frame Vector Evolution Plot:",Bold,14],stateEvolutionPlot,Spacer[10],Style["Total Composed Transformation and Inverse:",Bold,14],Grid[{{"T_total",MatrixForm[Ttotal]},{"T_total^-1",MatrixForm[totalInv]},{"Product (T_total^-1 * T_total)",MatrixForm[identityCheck]}}],Spacer[10],Style["Homological Closure Check:",Bold,14],If[isClosedCycle,Style["Product of all transactions equals Identity Matrix (Cycle Closed).",Darker[Green]],Style["Product differs from Identity \[LongDash] cycle is open, requires commit.",Darker[Red]]],Spacer[10],Style["Snake-Based Circulation Model Visualization:",Bold,14],snakeGraphics}]


Module[{n=6,k=4,seed=12345,genInvertibleMatrix,gf2Mul,drawMatrixGrid,drawVector,v0,Tchain,TchainInv,vStates,rollbackStates,composeMatrix,snakeVisualization},genInvertibleMatrix[dim_]:=Module[{m},While[True,m=RandomInteger[{0,1},{dim,dim}];If[Mod[Det[m],2]==1,Return[m]]]];gf2Mul[a_,b_]:=Mod[a . b,2];drawMatrixGrid[m_]:=Grid[m,Frame->All,Background->{None,{{Lighter[Blue,0.9]}}}];drawVector[v_]:=MatrixForm[v,TableDirections->Row];SeedRandom[seed];Tchain=Table[genInvertibleMatrix[n],{k}];TchainInv=Reverse[(Inverse[#1,Modulus->2]&)/@Tchain];v0=RandomInteger[{0,1},n];vStates=FoldList[gf2Mul,v0,Tchain];rollbackStates=FoldList[gf2Mul,Last[vStates],TchainInv];composeMatrix=Fold[gf2Mul,IdentityMatrix[n],Tchain];snakeVisualization:=Graphics[{Blue,Thick,Arrowheads[0.05],Arrow[Circle[{0,0},1,{\[Pi]/6,(11 \[Pi])/6}]],Red,Dashed,Arrowheads[-0.05],Arrow[Circle[{0,0},1,{(11 \[Pi])/6,2 \[Pi]+\[Pi]/6}]],Text[Style["Head (T)",Bold,Blue],{0,1.2}],Text[Style["Tail (T\:207b\.b9)",Bold,Red],{0,-1.2}]},ImageSize->Medium];Column[{Style["5.21 Reversible Transactions over a Single Ethernet Link \[LongDash] Visualization",16,Bold],Grid[{{Style["Initial Frame Vector v\:2080:",Bold],drawVector[v0]},{Style["Transaction Matrices T\:2081..T\:2084:",Bold],Row[drawMatrixGrid/@Tchain,Spacer[10]]}},Alignment->Left,Spacings->{1,1}],Grid[{{Style["Forward States (v\:2080 to v\:2084):",Bold],Grid[Partition[drawVector/@vStates,UpTo[3]]]},{Style["Rollback States:",Bold],Grid[Partition[drawVector/@rollbackStates,UpTo[3]]]}},Frame->All,Alignment->{Left,Top},Spacings->2],Column[{Style["Transaction 'Snake' Model",Bold],snakeVisualization},Alignment->Center]},Alignment->Center,Spacings->2]]


Module[{n=8,k=6,rollbackAt=4,randInv,step,inverseChain,T,Tinv,v0,vStates,rollbackState,transactionAlgebraPlot,reversibleBufferGrid,g,pos,edgeTx,edgeInvTx,stateVecs,spanningTree,failedEdges,laplacians,lambda2s,dlr,font=Directive[FontFamily->"Arial",FontSize->12]},randInv[d_]:=Module[{m},While[True,m=RandomInteger[{0,1},{d,d}];If[Mod[Det[m],2]==1,Return[m]]]];step[v_,m_]:=Mod[m . v,2];inverseChain[mats_]:=Reverse[(Inverse[#1,Modulus->2]&)/@mats];T=Table[randInv[n],{k}];Tinv=inverseChain[T];v0=RandomInteger[{0,1},n];vStates=FoldList[step,v0,T];rollbackState=Fold[step,Last[vStates],Take[Tinv,k-rollbackAt+1]];reversibleBufferGrid=Grid[Prepend[Table[{i-1,MatrixForm[vStates[[i]]]},{i,Length[vStates]}],{"Step","Vector State"}],Frame->All,Alignment->Center,ItemStyle->font];transactionAlgebraPlot=ListLinePlot[Transpose[vStates],PlotMarkers->Automatic,PlotRange->All,PlotLabel->Style["Transaction Algebra: Tv Chain",font],AxesLabel->{"Step","Bit Value"},PlotLegends->Placed[LineLegend[Range[n]],Right]];g=RandomGraph[{8,10},DirectedEdges->True];pos=GraphEmbedding[g];spanningTree=FindSpanningTree[g];edgeTx=AssociationThread[EdgeList[g],Table[randInv[n],{EdgeCount[g]}]];edgeInvTx=AssociationMap[Inverse[#1,Modulus->2]&,edgeTx];stateVecs=AssociationThread[VertexList[g],Table[RandomInteger[{0,1},n],{VertexCount[g]}]];Do[Module[{src,dst,Tmat},{src,dst}=List@@e;Tmat=edgeTx[e];stateVecs[dst]=Mod[Tmat . stateVecs[src],2];],{e,EdgeList[spanningTree]}];Graph[stateVecs,VertexLabels->Placed[MatrixForm/@stateVecs,Center],VertexStyle->LightBlue,EdgeStyle->Black,GraphLayout->{"VertexCoordinates"->pos},PlotLabel->Style["Spanning Tree: State Propagation",font]];failedEdges=RandomSample[EdgeList[g],Min[5,EdgeCount[g]]];laplacians=Table[GraphLaplacian[EdgeDelete[g,Take[failedEdges,i]]],{i,Length[failedEdges]}];lambda2s=Table[With[{vals=Sort[Eigenvalues[L]]},If[Length[vals]>=2,vals[[2]],0]],{L,laplacians}];dlr=Mean[lambda2s];Print[Style["DLR (Dynamic Laplacian Resilience): "<>ToString[NumberForm[dlr,{4,3}]],font]];GraphicsGrid[{{Graphics[{Arrowheads[0.04],Style[Circle[{0,0},1],LightGray],(Arrow[{{Cos[#1],Sin[#1]},{Cos[#1+(2 \[Pi])/k],Sin[#1+(2 \[Pi])/k]}}]&)/@Range[0,2 \[Pi],(2 \[Pi])/k],Red,Disk[{0,0},0.1]},PlotLabel->Style["Circular Snake: Head \[RightArrow] Tail \[RightArrow] Commit",font],ImageSize->300],transactionAlgebraPlot},{reversibleBufferGrid,Graphics[{Blue,Arrow[{{0,0},{1,0}}],Text[Style["T",font],{0.5,0.1}],Dashed,Red,Arrow[{{1,0},{0,0}}],Text[Style["T^{-1}",font],{0.5,-0.1}]},PlotLabel->Style["Forward and Reverse: Linear Transform + Inverse",font],ImageSize->300]}}]]


Module[{n=6,k=4,rollbackPoint=3,randInv,applyGF2,drawMatrixGrid,drawVector,T,Tinv,v0,vStates,vRollback,composeGraphic,reversiblePanel,transactionGraph,spanningTreeGraph,DLR,snakeLoopDiagram},randInv[dim_]:=Module[{m},While[True,m=RandomInteger[{0,1},{dim,dim}];If[Mod[Det[m],2]==1,Return[m]]]];applyGF2[mat_,vec_]:=Mod[mat . vec,2];drawMatrixGrid[m_]:=Grid[m,Frame->All,Background->{None,{{Lighter[Blue,0.9]}}}];drawVector[v_]:=MatrixForm[v,TableDirections->Row];T=Table[randInv[n],{k}];Tinv=Reverse[(Inverse[#1,Modulus->2]&)/@T];v0=RandomInteger[{0,1},n];vStates=FoldList[applyGF2,v0,T];vRollback=Fold[applyGF2,vStates[[rollbackPoint]],Take[Tinv,k-rollbackPoint+1]];reversiblePanel=Grid[Prepend[Join[Table[{Style["Tx "<>ToString[i-1],Bold],MatrixForm[vStates[[i]]]},{i,Length[vStates]}],{{Style["Rollback from T2",Red],MatrixForm[vRollback]}}],{Style["Stage",Italic],Style["State Vector",Italic]}],Frame->All,Spacings->{2,1}];composeGraphic=GraphicsGrid[{{(MatrixPlot[#1,Frame->True,Mesh->True,ColorFunction->"GrayTones",ImageSize->Small]&)/@T},{(MatrixPlot[#1,Frame->True,Mesh->True,ColorFunction->"GrayTones",ImageSize->Small]&)/@Tinv}},Spacings->{0.5,0.5},PlotLabel->"Forward (Top) and Inverse (Bottom) Transaction Matrices"];transactionGraph=Graph[{1, 2, 3, 4, 5}, {DirectedEdge[1, 2], DirectedEdge[2, 3], DirectedEdge[3, 4], DirectedEdge[2, 5], DirectedEdge[5, 3], DirectedEdge[4, 1]}, {ImageSize -> Medium, PlotLabel -> "Transaction DAG", VertexLabels -> {"Name"}}];spanningTreeGraph=FindSpanningTree[transactionGraph,PlotLabel->"Deterministic Spanning Tree"];Module[{graphsAfterFailures,laplacian,lambda2},graphsAfterFailures={EdgeDelete[transactionGraph,2->3],EdgeDelete[transactionGraph,3->4]};laplacian[g_]:=N[LaplacianMatrix[g]];lambda2[g_]:=Module[{vals=Sort[Eigenvalues[laplacian[g]]]},If[Length[vals]>1,vals[[2]],0]];DLR=Mean[lambda2/@graphsAfterFailures];];snakeLoopDiagram=Graphics[{Text[Style["Tx = T\[CenterDot]v",{0,1.3}],FontSize->14],Arrow[{{-1,1},{1,1}}],Text[Style["ACK = T\:207b\.b9",{0,-0.3}],FontSize->14],Arrow[{{1,0},{-1,0}}],Dashed,Circle[{0,0.5},1.2]},PlotLabel->"Snake-Based Transaction Loop",ImageSize->Small];Column[{Style["5.21 Reversible Transactions over a Single Ethernet Link",18,Bold],reversiblePanel,Spacer[10],Grid[{{Column[{Style["Transaction Matrices",Bold],composeGraphic},Alignment->Center],Column[{Style["Snake Commit Model",Bold],snakeLoopDiagram},Alignment->Center]}}],Spacer[10],Grid[{{Column[{Style["Transaction DAG",Bold],transactionGraph},Alignment->Center],Column[{Style["Spanning Tree for Determinism",Bold],spanningTreeGraph},Alignment->Center]}}],Style[StringForm["Dynamic Laplacian Resilience (DLR) after Failures = ``", NumberForm[DLR, {3, 2}]],14,Bold]},Alignment->Center,Spacings->1]]


Module[{n=6,k=4,seed=12345,v0,Tchain,TinvChain,vStates,rollbackStates,txGraph,loopCyclePlot,ackProjPlot,spanningTreePlot,snakeGraphics},SeedRandom[seed];genInvertibleMatrix[dim_]:=Module[{m},While[True,m=RandomInteger[{0,1},{dim,dim}];If[Mod[Det[m],2]==1,Return[m]]]];gf2Mul[a_,b_]:=Mod[a . b,2];Tchain=Table[genInvertibleMatrix[n],{k}];TinvChain=Reverse[(Inverse[#1,Modulus->2]&)/@Tchain];v0=RandomInteger[{0,1},n];vStates=FoldList[gf2Mul,v0,Tchain];rollbackStates=FoldList[gf2Mul,Last[vStates],TinvChain];txGraph=Graph[Table[i->i+1,{i,0,k-1}],DirectedEdges->True,VertexLabels->"Name",ImageSize->Medium];loopCyclePlot=GraphicsRow[Table[ArrayPlot[Mod[Fold[Dot,IdentityMatrix[n],Take[Tchain,i]],2],Frame->True,ImageSize->Small,PlotLabel->Style[Row[{"T",i,"\[EmptyCircle]...\[EmptyCircle]T\:2081"}],12]],{i,1,k}]];ackProjPlot=GraphicsGrid[{{Style["Unacknowledged",12],Style["Acknowledged (Projected)",12]},{ArrayPlot[Outer[BitXor,v0,v0],ImageSize->Small,Frame->False],ArrayPlot[Outer[BitXor,vStates[[-1]],vStates[[-1]]],ImageSize->Small,Frame->False]}}];spanningTreePlot=With[{g=GridGraph[{3,3}]},HighlightGraph[g,FindSpanningTree[g],GraphLayout->"SpringElectricalEmbedding",ImageSize->Medium]];snakeGraphics=Graphics[{Thick,Arrowheads[Medium],{Blue,Arrow[{{0,1},{2,1},{4,1}}]},Text[Style["Head (T\:22c5v)",Blue],{2,1.3}],{Red,Arrow[{{4,0},{2,0},{0,0}}]},Text[Style["Tail (T\:207b\.b9)",Red],{2,-0.3}]},PlotRange->{{-1,5},{-0.5,1.5}},ImageSize->Medium,Axes->False];Grid[{{Style["Reversible Transactions on \|01d53d\:2082\:2076",14,Bold],\[SpanFromLeft]},{"v\:2080",MatrixForm[v0]},{"Forward States",Column[MatrixForm/@vStates]},{"Rollback States",Column[MatrixForm/@rollbackStates]},{"Transaction DAG",txGraph},{"Loop Closure Demo",loopCyclePlot},{"Ack Projection",ackProjPlot},{"Spanning Tree",spanningTreePlot},{"Snake Model",snakeGraphics}},Alignment->Left,Frame->All,Spacings->{1,2},Background->{None,{Lighter[Gray,.92]}}]]


Module[{n=6,k=5,rollbackAt=3,T,Tinv,v0,vStates,vRollback,randInv,applyGF2,vectorPanel,snakeDiagram,rollbackDiagram,txChainDiagram,homologyCycle,graphG,graphFailSeq,laplacians,lambda2Vals,DLR,projectionDemo},randInv[dim_]:=Module[{m},While[True,m=RandomInteger[{0,1},{dim,dim}];If[Mod[Det[m],2]==1,Return[m]]]];applyGF2[mat_,vec_]:=Mod[mat . vec,2];T=Table[randInv[n],{k}];Tinv=Reverse[(Inverse[#1,Modulus->2]&)/@T];v0=RandomInteger[{0,1},n];vStates=FoldList[applyGF2,v0,T];vRollback=Fold[applyGF2,vStates[[rollbackAt]],Take[Tinv,k-rollbackAt+1]];vectorPanel=Grid[Prepend[Table[{Style["v"<>ToString[i-1],Bold],MatrixForm[vStates[[i]]]},{i,Length[vStates]}],{"State","Vector"}],Frame->All];snakeDiagram=Graphics[{Arrowheads[0.05],Circle[{0,0},1],{Red,Thick,Arrow[{{1,0},{0.8,0.6}}]},{Blue,Thick,Arrow[{{-1,0},{-0.8,-0.6}}]},Text[Style["Head (T\:22c5v)",Red,Bold],{0.9,0.8}],Text[Style["Tail (T\:207b\.b9)",Blue,Bold],{-0.9,-0.8}],Text[Style["Reversible Ethernet Snake",Bold],{0,1.3}]},PlotRange->1.5,ImageSize->300];txChainDiagram=GraphicsGrid[Table[{MatrixPlot[T[[i]],ColorFunction->"GrayTones",Frame->True,Mesh->True,PlotLabel->"T"<>ToString[i]],MatrixPlot[Tinv[[k-i+1]],ColorFunction->"GrayTones",Frame->True,Mesh->True,PlotLabel->"T\:207b\.b9"<>ToString[k-i+1]]},{i,1,k}],Spacings->{2,1}];rollbackDiagram=Grid[{{"State at Step "<>ToString[k],MatrixForm[Last[vStates]]},{"Rollback from Step "<>ToString[rollbackAt-1],MatrixForm[vRollback]}},Frame->All];homologyCycle:=Module[{M},M=Fold[gf2Mul,IdentityMatrix[n],T];Grid[{{"Composition T\:2096...T\:2081",MatrixForm[M]},{"Is Identity?",Style[M===IdentityMatrix[n],Bold]}},Frame->All]];graphG=RandomGraph[{12,20},GraphLayout->"CircularEmbedding"];graphFailSeq=Table[EdgeDelete[graphG,RandomSample[EdgeList[graphG],i]],{i,0,3}];laplacians=LaplacianMatrix/@graphFailSeq;lambda2Vals=Table[Module[{vals=Sort[Eigenvalues[N[lap]]]},If[Length[vals]>1,vals[[2]],0]],{lap,laplacians}];DLR=Mean[lambda2Vals];projectionDemo:=Module[{v=vStates[[k]],Pv,mask=RandomInteger[{0,1},n]},Pv=BitAnd[v,mask];Grid[{{"Tentative State",MatrixForm[v]},{"ACK Mask",MatrixForm[mask]},{"Projected (Committed)",MatrixForm[Pv]}},Frame->All]];Column[{Style["5.21 Reversible Transactions over a Single Ethernet Link",Bold,16],Grid[{{vectorPanel,snakeDiagram,rollbackDiagram},{txChainDiagram,homologyCycle,projectionDemo}},Frame->All,Spacings->2],Style["DLR: Dynamic Laplacian Resilience",Bold,14],Show[graphG,PlotLabel->"Original Graph G",ImageSize->Medium],Row[{"\[Lambda]\:2082 values after 0..3 failures: ",(NumberForm[#1,{3,2}]&)/@lambda2Vals}],Row[{"DLR(G) Mean: ",NumberForm[DLR,{4,3}]}]},Spacings->1,Alignment->Center]]


Module[{n=6,k=5,rollbackAt=4,randInv,applyT,TList,TInvList,v0,vStates,vRollback,reversiblePanel,composeDemo,rollbackDemo,vectorGraphics,spanningTreeDemo,ackProjectionDemo,snakeLoopDiagram},randInv[dim_]:=Module[{m},While[True,m=RandomInteger[{0,1},{dim,dim}];If[Mod[Det[m],2]==1,Return[m]]]];applyT[v_,t_]:=Mod[t . v,2];v0=RandomInteger[{0,1},n];TList=Table[randInv[n],{k}];TInvList=Reverse[(Inverse[#1]&)/@TList];vStates=FoldList[applyT,v0,TList];vRollback=Fold[applyT,Last[vStates],Take[TInvList,k-rollbackAt+1]];reversiblePanel=Grid[Prepend[Table[{Style["Step "<>ToString[i-1],Bold],MatrixForm[vStates[[i]]]},{i,Length[vStates]}],{"Step","v \[Element] \|01d53d\:2082\:207f"}],Frame->All];composeDemo:=MatrixForm[Fold[Dot,IdentityMatrix[n],Reverse[TList]]];rollbackDemo:=MatrixForm[Fold[Dot,IdentityMatrix[n],Take[TInvList,k]]];vectorGraphics=ListLinePlot[Transpose[vStates],PlotMarkers->Automatic,PlotLabel->"Evolution of v under T\:2081...T\:2096 (over \|01d53d\:2082\:207f)",AxesLabel->{"Step","Bit value"},GridLines->Automatic];spanningTreeDemo:=Module[{g,tree},g=RandomGraph[{10,15},GraphStyle->"ThickEdge"];tree=FindSpanningTree[g];HighlightGraph[g,tree]];ackProjectionDemo:=Module[{T=randInv[n],v,Tv,P},v=RandomInteger[{0,1},n];Tv=Mod[T . v,2];P=IdentityMatrix[n];Grid[{{"Original Vector v",MatrixForm[v]},{"After Tx: T.v",MatrixForm[Tv]},{"After Projection P: commit(T.v)",MatrixForm[Mod[P . Tv,2]]}}]];snakeLoopDiagram:=Graphics[{Arrowheads[0.04],Style[Circle[{0,0},1],Thick],Style[Text["Head: Tv",{1.2,0}],14],Style[Text["Tail: T\:207b\.b9",{-1.2,0}],14],Arrow[{{0.5,0},{0.85,0.5}}],Arrow[{{-0.5,0},{-0.85,-0.5}}],Style[Text["Loop Completion \[DoubleRightArrow] Commit",{0,-1.5}],14,Red]},PlotRange->{{-2,2},{-2,2}}];Column[{Style["Reversible Transactions over a Single Ethernet Link",20,Bold],Style["Vector Evolution via GF(2) Linear Transformations",16,Bold],reversiblePanel,vectorGraphics,Style["Composed Transformation T\:2096 ... T\:2081",16,Bold],composeDemo,Style["Rollback Transformation T\:2081\:207b\.b9 ... T\:2096\:207b\.b9",16,Bold],rollbackDemo,Style["Spanning Tree Demonstration (for Reversible Graphs)",16,Bold],spanningTreeDemo,Style["Acknowledgment as Projection",16,Bold],ackProjectionDemo,Style["Circular Snake: Head and Tail Loop Model",16,Bold],snakeLoopDiagram}]]


Module[{sliceCount=8,drawSlices,drawSACKFlow,drawBidirectionalChannel,draw4LayerInfoFramework,drawAntBeeRouting,drawPacketClocks,drawDatacenterTopologies,drawABPsnake,colorSlice=Lighter[Blue,0.6]},drawSlices[]:=Grid[{{Style["Ethernet Frame Slices",Bold,14]},{Graphics[{Table[{EdgeForm[Black],colorSlice,Rectangle[{i 1.2,0},{i 1.2+1,1}]},{i,0,sliceCount-1}]},ImageSize->{sliceCount 15,30}]},{Style["Slices 1 to 8, each 8 bytes, totaling 64 bytes",Italic,10]}},Alignment->Center];drawSACKFlow[]:=Grid[{{Style["Feedback (SACK) Signals at Various Slices",Bold,14]},{Graphics[{Text[Style["TX Pipeline",Bold,12,Blue],{3.5,-0.5}],Text[Style["RX Pipeline",Bold,12,Green],{3.5,2.5}],Thick,Table[{Blue,Arrow[{{i 1.2,0},{i 1.2+0.8,0}}]},{i,0,sliceCount-1}],Table[{Green,Arrow[{{i 1.2+0.8,2},{i 1.2,2}}]},{i,0,sliceCount-1}],{Red,Thick,Arrow[{{7 1.2+0.4,0.5},{7 1.2+0.4,1.5}}],Text[Style["SACK8\n(Slice 8)",Red],{7 1.2+2,1}]},{Red,Thick,Arrow[{{0.4,1.5},{0.4,0.5}}],Text[Style["SACK1\n(Slice 1)",Red],{-1,1}]}},PlotRange->{{-2,sliceCount 1.5},{-1,3}},ImageSize->450]}}];drawBidirectionalChannel[]:=Graphics[{Text[Style["Bidirectional Full-Duplex Shannon-Metcalfe Channel",Bold,14],{4,1.2}],Blue,Arrowheads[0.04],Thick,Arrow[{{0,0},{8,0}}],Green,Arrowheads[0.04],Thick,Arrow[{{8,-0.5},{0,-0.5}}],Text[Style["TX Channel",Blue,Bold,12],{4,0.3}],Text[Style["RX Channel",Green,Bold,12],{4,-0.8}]},ImageSize->500];draw4LayerInfoFramework[]:=Grid[{{Style["Four Shannon-Like Levels of Certainty",Bold,14]},{Graphics[{Text[Style["Layer 1: Information (Surprisal)",Blue,Bold,12],{1.5,1.3}],Rectangle[{0,0},{3,1},RoundingRadius->0.1],Text["Bits arrived\nor not",{1.5,0.5}],Text[Style["Layer 2: Knowledge (Captured Info)",Green,Bold,12],{5,1.3}],Rectangle[{3.5,0},{6.5,1},RoundingRadius->0.1],Text["Bits buffered &\nvalidated",{5,0.5}],Text[Style["Layer 3: Semantics (Meaning)",Orange,Bold,12],{8.5,1.3}],Rectangle[{7,0},{10,1},RoundingRadius->0.1],Text["Partial decode,\nstate machine",{8.5,0.5}],Text[Style["Layer 4: Understanding (Syntax)",Red,Bold,12],{12,1.3}],Rectangle[{10.5,0},{13.5,1},RoundingRadius->0.1],Text["Full message\nrecognized",{12,0.5}]},ImageSize->650,PlotRange->{{-0.5,14},{-0.5,1.8}}]}}];drawAntBeeRouting[]:=Grid[{{Style["Biologically Inspired Routing",Bold,14]},{Graphics[{Text[Style["ANT Scouts (Local)",Darker[Green,0.3],Bold,12],{1,4.5}],{Darker[Green,0.3],Dashed,Circle[{2.5,2.5},1.5]},Text[Style["BEE Scouts (Global)",Darker[Orange,0.4],Bold,12],{5.5,4.5}],{Darker[Orange,0.4],Arrowheads[0.03],Arrow[{{5.5,4},{5.5,1}}],Arrow[{{5.5,4},{2.5,4}}]}},ImageSize->300]}}];drawPacketClocks[]:=Grid[{{Style["Packet Clocks: Race-Free Circulations",Bold,14]},{Graphics[{Text[Style["ANT Token Loop",Blue,Bold],{0,2.5}],{Blue,Thick,Circle[{0,0},2]},Text[Style["1-Hop Clock",Red,Bold],{0,1.3}],{Red,Thick,Circle[{0,0},1]},{Arrowheads[0.05],Red,Arrow[Circle[{0,0},1,{\[Pi]/2,2 \[Pi]+\[Pi]/2}]]}},ImageSize->250]}}];drawDatacenterTopologies[]:=Grid[{{Style["Datacenter Topologies",Bold,14]},{Graphics[{Text[Style["Centralized",Red,Bold,12],{2,3.5}],Disk[{2,2},0.1],Table[Line[{{2,2},{1+0.3 i,3}}],{i,1,5}],Text[Style["Decentralized",Orange,Bold,12],{6,3.5}],Disk[{6,2},0.1],Table[Line[{{6,2},{5+0.3 i,3}}],{i,1,3}],Table[Disk[{5+0.3 i,3},0.08],{i,1,3}],Text[Style["Distributed",Green,Bold,12],{9.5,3.5}],With[{center={9.5,2},r=1,numVerts=6},{Table[Disk[{center[[1]]+r Cos[(2 \[Pi] i)/numVerts],center[[2]]+r Sin[(2 \[Pi] i)/numVerts]},0.1],{i,1,numVerts}],Table[Line[{{center[[1]]+r Cos[(2 \[Pi] i)/numVerts],center[[2]]+r Sin[(2 \[Pi] i)/numVerts]},{center[[1]]+r Cos[(2 \[Pi] Mod[i,numVerts]+1)/numVerts],center[[2]]+r Sin[(2 \[Pi] Mod[i,numVerts]+1)/numVerts]}}],{i,1,numVerts}]}]},PlotRange->{{0,11},{1,4}},ImageSize->600]}}];drawABPsnake[]:=Graphics[{Text[Style["Alternating Bit Protocol (ABP) Snake Model",Bold,14],{6,4.5}],Thick,Blue,BezierCurve[{{1,1},{2,3},{5,3},{6,1}}],Thick,Red,Dashed,BezierCurve[{{6,1},{7,-1},{10,-1},{11,1}}],Text[Style["TX snake",Blue,Bold,12],{3.5,3.3}],Text[Style["RX snake (ACK)",Red,Bold,12],{8.5,-1.3}],{PointSize[Large],Black,Point[{1,1}],Point[{6,1}],Point[{11,1}]}},PlotRange->{{0,12},{-2,5}},ImageSize->500];Column[{drawSlices[],Spacer[20],drawSACKFlow[],Spacer[20],drawBidirectionalChannel[],Spacer[20],draw4LayerInfoFramework[],Spacer[20],drawAntBeeRouting[],Spacer[20],drawPacketClocks[],Spacer[20],drawDatacenterTopologies[],Spacer[20],drawABPsnake[]},Spacings->3]]


Module[{nSlices=8,pipeTX,pipeRX,sackedSlices,knowledgeLayers,sackColors,twoWayChannel,antScoutingPaths,beeScoutingPaths,hybridLogicalClockDemo,mkSliceLabels,mkPipelineGraphics,mkLayerDiagram,mkBidirectionalPipelines,mkScoutingVisualization,hlcStep},mkSliceLabels[slices_]:=Table["Slice "<>ToString[i],{i,slices}];mkPipelineGraphics[label_,slices_,highlight_:{}]:=Module[{rects,colors},colors=Table[If[MemberQ[highlight,i],LightGreen,LightGray],{i,slices}];Graphics[{Style[Text[label,{0.5,slices+0.5}],Bold,14],Table[{colors[[i]],Rectangle[{0,slices-i},{2,slices-i+0.8}]},{i,slices}],Table[Text[Style[mkSliceLabels[slices][[i]],12],{1,slices-i+0.4}],{i,slices}]},PlotRange->{{-0.5,2.5},{0,slices+1}},ImageSize->150]];knowledgeLayers={"Layer 1: Information (Surprisal) - SACK 00","Layer 2: Knowledge (Captured Info) - SACK 01","Layer 3: Semantics (Meaning) - SACK 10","Layer 4: Understanding (Syntax) - SACK 11"};sackColors={LightBlue,LightYellow,LightOrange,LightGreen};mkLayerDiagram[]:=Graphics[Table[{sackColors[[i]],Rectangle[{0,4-i},{6,5-i}],Black,Text[Style[knowledgeLayers[[i]],Bold,14],{3,4.5-i}]},{i,4}],PlotRange->{{-1,7},{0,5}},ImageSize->400];mkBidirectionalPipelines[]:=Graphics[{Style[Text["TX Pipeline",{1,9}],Bold,14],Style[Text["RX Pipeline",{8,1}],Bold,14],Table[{LightGray,Rectangle[{i,8},{i+1,9}],Black,Text["TX"<>ToString[i],{i+0.5,8.5}]},{i,1,8}],Table[{LightGray,Rectangle[{8,i},{9,i+1}],Black,Text["RX"<>ToString[i],{8.5,i+0.5}]},{i,1,8}],Style[Table[{If[Mod[i,2]==1,Red,Blue],Disk[{i+0.5,i+0.5},0.3],Black,Text["SACK "<>IntegerString[Quotient[i-1,2],2,2],{i+0.5,i+0.5}]},{i,1,8}],Opacity[0.6]],Table[{Arrowheads[0.02],Arrow[{{i+0.5,9.3},{i+0.5,9}}],Arrow[{{9.3,i+0.5},{9,i+0.5}}]},{i,1,8}]},PlotRange->{{0,10},{0,10}},ImageSize->400];antScoutingPaths={{{2,2},{2,3},{3,3},{3,4},{4,4}},{{2,2},{1,2},{1,1},{0,1},{0,0}}};beeScoutingPaths={Table[{2,i},{i,2,4}],Table[{i,2},{i,2,4}]};mkScoutingVisualization[]:=Module[{nodes,edges,g,nodeGridDim=5},nodes=Flatten[Table[{i,j},{i,0,nodeGridDim},{j,0,nodeGridDim}],1];edges=UndirectedEdge@@@Select[Flatten[Table[{{i,j}<->{i+1,j},{i,j}<->{i,j+1}},{i,0,nodeGridDim-1},{j,0,nodeGridDim-1}],1],MemberQ[nodes,#1[[1]]]&&MemberQ[nodes,#1[[2]]]&];g=Graph[nodes,edges,VertexSize->Medium,VertexLabels->None,ImageSize->400,EdgeStyle->LightGray];Show[g,Graphics[{Red,Thick,Arrowheads[0.03],Arrow/@Table[antScoutingPaths[[i]],{i,Length[antScoutingPaths]}],Blue,Thick,Arrowheads[0.03],Arrow/@Table[beeScoutingPaths[[i]],{i,Length[beeScoutingPaths]}]}]]];hlcStep[pt_,ctr_,now_]:=Module[{ptn=Max[pt,now],ctn},ctn=If[ptn==pt,ctr+1,0];{ptn,ctn}];hybridLogicalClockDemo:=Module[{steps=15,now=0,pt=0,ctr=0,values={}},Do[now+=RandomReal[{0.5,1.5}];{pt,ctr}=hlcStep[pt,ctr,now];AppendTo[values,{now,pt,ctr}],{i,steps}];ListLinePlot[{values[[All,1]],values[[All,2]],values[[All,3]]},PlotLegends->{"Physical Time (pt)","HLC Time (pt)","Logical Counter (ctr)"},PlotRange->All,ImageSize->400,PlotLabel->"Hybrid Logical Clock Demonstration"]];Grid[{{Style["6.1 Back to Back Shannon Channels (TX/RX Pipelines)",16,Bold]},{Row[{mkPipelineGraphics["TX Pipeline",nSlices,{1,8}],Spacer[20],mkPipelineGraphics["RX Pipeline",nSlices,{1,8}]}]},{Style["6.2 Four Shannon-Like Layers of Certainty via SACKs",16,Bold]},{mkLayerDiagram[]},{Style["6.3 Full-Duplex Bidirectional Pipelined Shannon-Metcalfe Channel",16,Bold]},{mkBidirectionalPipelines[]},{Style["6.4 Local and Global Scouting: ANT & BEE Agents",16,Bold]},{mkScoutingVisualization[]},{Style["6.36 Hybrid Logical Clocks (HLC) Demo",16,Bold]},{hybridLogicalClockDemo}},Spacings->3]]


Module[{tx,rx,edges,G1,G2,G3,pos,sliceGraph,sackGraph8,sackGraph1,layers,layerColors,layerNames,beePaths,antPaths,beeViz,antViz,routingMesh,hopGraph},tx=Table["TX"<>ToString[i],{i,1,8}];rx=Table["RX"<>ToString[i],{i,1,8}];edges=Thread[tx->rx];G1=Graph[Join[tx,rx],edges,VertexLabels->"Name",EdgeStyle->Arrowheads[0.03],ImageSize->400];G2=Graph[G1,EdgeAdd[G1,{"RX8"->"TX1"}]];G3=Graph[G1,EdgeAdd[G1,{"RX1"->"TX1"}]];layerNames={"Information","Knowledge","Semantics","Understanding"};layerColors={LightBlue,LightGreen,LightOrange,LightRed};layers=Grid[Table[{Style[layerNames[[i]],Bold,14],Style["SACK"<>IntegerString[i-1,2,2],layerColors[[i]],14]},{i,1,4}],Frame->All,Spacings->{2,2}];beePaths={Line[{{0,0},{1,1},{2,2},{3,3}}],Line[{{0,0},{-1,-1},{-2,-2},{-3,-3}}]};antPaths={Line[{{0,0},{1,0},{1,1},{0,1},{0,0}}],Line[{{0,0},{-1,0},{-1,-1},{0,-1},{0,0}}]};beeViz=Graphics[{Thick,Blue,beePaths},Axes->True,PlotLabel->"BEE Scouting Paths (Radial Return)",ImageSize->300];antViz=Graphics[{Thick,Green,antPaths},Axes->True,PlotLabel->"ANT Local Scouting Loops (Clockwise/Anti)",ImageSize->300];routingMesh=GridGraph[{3,3},VertexLabels->"Name",EdgeStyle->Gray,ImageSize->300];hopGraph=Graph[Table[i,{i,1,7 7}],Table[{i,i+1},{i,1,7 7-1}],VertexCoordinates->Table[{Mod[i-1,7],Floor[(i-1)/7]},{i,1,49}],GraphStyle->"NameLabeled",ImageSize->400];Column[{Style["Back-to-Back Metcalfe Channel Visualizations",Bold,16],Row[{G1,G2,G3}],Style["SACK Layers as Certainty Depth",Bold,16],layers,Row[{beeViz,antViz}],Style["Compass Topology (3\[Times]3)",Bold,16],routingMesh,Style["Race-Free Packet Clock (7\[Times]7 Tile)",Bold,16],hopGraph}]]


Module[{sliceCount=8,layers={"Information","Knowledge","Semantics","Understanding"},sackCodes={"00","01","10","11"},gridSize=5,layerColors,shannonChannelGraphics,duplexPipelineGraphics,centralizedPlot,decentralizedPlot,distributedPlot,hlcGraphics},layerColors=ColorData["Rainbow"]/@Rescale[Range[Length[layers]]];drawSlice[pos_,label_,col_,width_:1]:={col,EdgeForm[Black],Rectangle[{pos,0},{pos+width,1}],Black,Text[Style[label,Bold,12],{pos+width/2,0.5}]};drawSackMarker[pos_,label_,col_]:={col,Disk[{pos,1.3},0.12],Black,Text[Style[label,Bold,10],{pos,1.3}]};shannonChannelGraphics=Module[{shannonSlices,sackMarkers,sackPositions={1,2,4,8}},shannonSlices=Table[drawSlice[i,"Slice "<>ToString[i+1],LightBlue],{i,0,sliceCount-1}];sackMarkers=Table[drawSackMarker[sackPositions[[i]]-0.5,"SACK "<>sackCodes[[i]],layerColors[[i]]],{i,Length[sackPositions]}];Graphics[{shannonSlices,sackMarkers,Black,Text[Style["Pipelined Slices + SACKs",Bold,16],{sliceCount/2,2}]},PlotRange->{{-0.5,sliceCount+0.5},{-0.5,2.2}},ImageSize->600,Axes->False]];duplexPipelineGraphics=Graphics[{Table[{LightGreen,Rectangle[{i-0.5,0.5},{i+0.5,1.5}],Black,Text[Style["TX "<>ToString[i],Bold,12],{i,1}]},{i,1,sliceCount}],Table[{LightCoral,Rectangle[{i-0.5,-1.5},{i+0.5,-0.5}],Black,Text[Style["RX "<>ToString[i],Bold,12],{i,-1}]},{i,1,sliceCount}],Text[Style["Full-Duplex \[CapitalAE]thernet Frame Exchange",Bold,16],{sliceCount/2,2.8}]},PlotRange->{{0,sliceCount+1},{-2,3}},ImageSize->700,Axes->False];centralizedPlot=Graph[StarGraph[47],VertexLabels->None,VertexSize->0.3,PlotLabel->Style["Centralized",Bold,14],ImageSize->300];decentralizedPlot=Graph[CompleteGraph[7],VertexLabels->None,GraphLayout->"SpringElectricalEmbedding",PlotLabel->Style["Decentralized",Bold,14],ImageSize->300];distributedPlot=RandomGraph[{47,98},VertexLabels->None,GraphLayout->"SpringElectricalEmbedding",PlotLabel->Style["Distributed",Bold,14],ImageSize->300];hlcGraphics=Module[{hlcUpdates,hlcEpsilon=5},hlcUpdates=Table[{1000+RandomInteger[{-5,5}],RandomInteger[{0,3}]},{15}];GraphicsGrid[{{ListLinePlot[Transpose[hlcUpdates],PlotLegends->{"Physical Time","Logical Counter"},PlotLabel->"HLC Points (pt, ctr)",ImageSize->300]},{Graphics[{Black,Circle[{0,0},hlcEpsilon],Text[Style["HLC \[CurlyEpsilon] Bound (\[PlusMinus]"<>ToString[hlcEpsilon]<>")",Bold,12],{0,hlcEpsilon+3}]},PlotRange->All,ImageSize->300]}}]];Column[{Style["\[CapitalAE]thernet Architecture Visualizations \[LongDash] Chapter 6",20,Bold,"Helvetica"],Spacer[10],Style["6.1 Back-to-Back Shannon Channels",16,Bold],shannonChannelGraphics,Spacer[10],Style["6.31 Datacenter Network Topologies (Baran Classification)",16,Bold],Grid[{{centralizedPlot,decentralizedPlot,distributedPlot}},Spacings->2],Spacer[10],Style["6.36 Hybrid Logical Clock (HLC) Model",16,Bold],hlcGraphics},Spacings->2,Alignment->Center]]


Module[{n=6,k=5,rollbackAt=3,T,Tinv,v0,vStates,vRollback,randInv,applyGF2,vectorPanel,snakeDiagram,rollbackDiagram,txChainDiagram,homologyCycle,graphG,graphFailSeq,laplacians,lambda2Vals,DLR,projectionDemo},randInv[dim_]:=Module[{m},While[True,m=RandomInteger[{0,1},{dim,dim}];If[Mod[Det[m],2]==1,Return[m]]]];applyGF2[mat_,vec_]:=Mod[mat . vec,2];T=Table[randInv[n],{k}];Tinv=Reverse[(Inverse[#1,Modulus->2]&)/@T];v0=RandomInteger[{0,1},n];vStates=FoldList[applyGF2,v0,T];vRollback=Fold[applyGF2,vStates[[rollbackAt]],Take[Tinv,k-rollbackAt+1]];vectorPanel=Grid[Prepend[Table[{Style["v"<>ToString[i-1],Bold],MatrixForm[vStates[[i]]]},{i,Length[vStates]}],{"State","Vector"}],Frame->All];snakeDiagram=Graphics[{Arrowheads[0.05],Circle[{0,0},1],{Red,Thick,Arrow[{{1,0},{0.8,0.6}}]},{Blue,Thick,Arrow[{{-1,0},{-0.8,-0.6}}]},Text[Style["Head (T\:22c5v)",Red,Bold],{0.9,0.8}],Text[Style["Tail (T\:207b\.b9)",Blue,Bold],{-0.9,-0.8}],Text[Style["Reversible Ethernet Snake",Bold],{0,1.3}]},PlotRange->1.5,ImageSize->300];txChainDiagram=GraphicsGrid[Table[{MatrixPlot[T[[i]],ColorFunction->"GrayTones",Frame->True,Mesh->True,PlotLabel->"T"<>ToString[i]],MatrixPlot[Tinv[[k-i+1]],ColorFunction->"GrayTones",Frame->True,Mesh->True,PlotLabel->"T\:207b\.b9"<>ToString[k-i+1]]},{i,1,k}],Spacings->{2,1}];rollbackDiagram=Grid[{{"State at Step "<>ToString[k],MatrixForm[Last[vStates]]},{"Rollback from Step "<>ToString[rollbackAt-1],MatrixForm[vRollback]}},Frame->All];homologyCycle:=Module[{M},M=Fold[gf2Mul,IdentityMatrix[n],T];Grid[{{"Composition T\:2096...T\:2081",MatrixForm[M]},{"Is Identity?",Style[M===IdentityMatrix[n],Bold]}},Frame->All]];graphG=RandomGraph[{12,20},GraphLayout->"CircularEmbedding"];graphFailSeq=Table[EdgeDelete[graphG,RandomSample[EdgeList[graphG],i]],{i,0,3}];laplacians=LaplacianMatrix/@graphFailSeq;lambda2Vals=Table[Module[{vals=Sort[Eigenvalues[N[lap]]]},If[Length[vals]>1,vals[[2]],0]],{lap,laplacians}];DLR=Mean[lambda2Vals];projectionDemo:=Module[{v=vStates[[k]],Pv,mask=RandomInteger[{0,1},n]},Pv=BitAnd[v,mask];Grid[{{"Tentative State",MatrixForm[v]},{"ACK Mask",MatrixForm[mask]},{"Projected (Committed)",MatrixForm[Pv]}},Frame->All]];Column[{Style["5.21 Reversible Transactions over a Single Ethernet Link",Bold,16],Grid[{{vectorPanel,snakeDiagram,rollbackDiagram},{txChainDiagram,homologyCycle,projectionDemo}},Frame->All,Spacings->2],Style["DLR: Dynamic Laplacian Resilience",Bold,14],Show[graphG,PlotLabel->"Original Graph G",ImageSize->Medium],Row[{"\[Lambda]\:2082 values after 0..3 failures: ",(NumberForm[#1,{3,2}]&)/@lambda2Vals}],Row[{"DLR(G) Mean: ",NumberForm[DLR,{4,3}]}]},Spacings->1,Alignment->Center]]


Module[{sliceCount=8,drawSlices,drawSACKFlow,drawBidirectionalChannel,draw4LayerInfoFramework,drawAntBeeRouting,drawPacketClocks,drawDatacenterTopologies,drawABPsnake,colorSlice=Lighter[Blue,0.6]},drawSlices[]:=Grid[{{Style["Ethernet Frame Slices",Bold,14]},{Graphics[{Table[{EdgeForm[Black],colorSlice,Rectangle[{i 1.2,0},{i 1.2+1,1}]},{i,0,sliceCount-1}]},ImageSize->{sliceCount 15,30}]},{Style["Slices 1 to 8, each 8 bytes, totaling 64 bytes",Italic,10]}},Alignment->Center];drawSACKFlow[]:=Grid[{{Style["Feedback (SACK) Signals at Various Slices",Bold,14]},{Graphics[{Text[Style["TX Pipeline",Bold,12,Blue],{3.5,-0.5}],Text[Style["RX Pipeline",Bold,12,Green],{3.5,2.5}],Thick,Table[{Blue,Arrow[{{i 1.2,0},{i 1.2+0.8,0}}]},{i,0,sliceCount-1}],Table[{Green,Arrow[{{i 1.2+0.8,2},{i 1.2,2}}]},{i,0,sliceCount-1}],{Red,Thick,Arrow[{{7 1.2+0.4,0.5},{7 1.2+0.4,1.5}}],Text[Style["SACK8\n(Slice 8)",Red],{7 1.2+2,1}]},{Red,Thick,Arrow[{{0.4,1.5},{0.4,0.5}}],Text[Style["SACK1\n(Slice 1)",Red],{-1,1}]}},PlotRange->{{-2,sliceCount 1.5},{-1,3}},ImageSize->450]}}];drawBidirectionalChannel[]:=Graphics[{Text[Style["Bidirectional Full-Duplex Shannon-Metcalfe Channel",Bold,14],{4,1.2}],Blue,Arrowheads[0.04],Thick,Arrow[{{0,0},{8,0}}],Green,Arrowheads[0.04],Thick,Arrow[{{8,-0.5},{0,-0.5}}],Text[Style["TX Channel",Blue,Bold,12],{4,0.3}],Text[Style["RX Channel",Green,Bold,12],{4,-0.8}]},ImageSize->500];draw4LayerInfoFramework[]:=Grid[{{Style["Four Shannon-Like Levels of Certainty",Bold,14]},{Graphics[{Text[Style["Layer 1: Information (Surprisal)",Blue,Bold,12],{1.5,1.3}],Rectangle[{0,0},{3,1},RoundingRadius->0.1],Text["Bits arrived\nor not",{1.5,0.5}],Text[Style["Layer 2: Knowledge (Captured Info)",Green,Bold,12],{5,1.3}],Rectangle[{3.5,0},{6.5,1},RoundingRadius->0.1],Text["Bits buffered &\nvalidated",{5,0.5}],Text[Style["Layer 3: Semantics (Meaning)",Orange,Bold,12],{8.5,1.3}],Rectangle[{7,0},{10,1},RoundingRadius->0.1],Text["Partial decode,\nstate machine",{8.5,0.5}],Text[Style["Layer 4: Understanding (Syntax)",Red,Bold,12],{12,1.3}],Rectangle[{10.5,0},{13.5,1},RoundingRadius->0.1],Text["Full message\nrecognized",{12,0.5}]},ImageSize->650,PlotRange->{{-0.5,14},{-0.5,1.8}}]}}];drawAntBeeRouting[]:=Grid[{{Style["Biologically Inspired Routing",Bold,14]},{Graphics[{Text[Style["ANT Scouts (Local)",Darker[Green,0.3],Bold,12],{1,4.5}],{Darker[Green,0.3],Dashed,Circle[{2.5,2.5},1.5]},Text[Style["BEE Scouts (Global)",Darker[Orange,0.4],Bold,12],{5.5,4.5}],{Darker[Orange,0.4],Arrowheads[0.03],Arrow[{{5.5,4},{5.5,1}}],Arrow[{{5.5,4},{2.5,4}}]}},ImageSize->300]}}];drawPacketClocks[]:=Grid[{{Style["Packet Clocks: Race-Free Circulations",Bold,14]},{Graphics[{Text[Style["ANT Token Loop",Blue,Bold],{0,2.5}],{Blue,Thick,Circle[{0,0},2]},Text[Style["1-Hop Clock",Red,Bold],{0,1.3}],{Red,Thick,Circle[{0,0},1]},{Arrowheads[0.05],Red,Arrow[Circle[{0,0},1,{\[Pi]/2,2 \[Pi]+\[Pi]/2}]]}},ImageSize->250]}}];drawDatacenterTopologies[]:=Grid[{{Style["Datacenter Topologies",Bold,14]},{Graphics[{Text[Style["Centralized",Red,Bold,12],{2,3.5}],Disk[{2,2},0.1],Table[Line[{{2,2},{1+0.3 i,3}}],{i,1,5}],Text[Style["Decentralized",Orange,Bold,12],{6,3.5}],Disk[{6,2},0.1],Table[Line[{{6,2},{5+0.3 i,3}}],{i,1,3}],Table[Disk[{5+0.3 i,3},0.08],{i,1,3}],Text[Style["Distributed",Green,Bold,12],{9.5,3.5}],With[{center={9.5,2},r=1,numVerts=6},{Table[Disk[{center[[1]]+r Cos[(2 \[Pi] i)/numVerts],center[[2]]+r Sin[(2 \[Pi] i)/numVerts]},0.1],{i,1,numVerts}],Table[Line[{{center[[1]]+r Cos[(2 \[Pi] i)/numVerts],center[[2]]+r Sin[(2 \[Pi] i)/numVerts]},{center[[1]]+r Cos[(2 \[Pi] Mod[i,numVerts]+1)/numVerts],center[[2]]+r Sin[(2 \[Pi] Mod[i,numVerts]+1)/numVerts]}}],{i,1,numVerts}]}]},PlotRange->{{0,11},{1,4}},ImageSize->600]}}];drawABPsnake[]:=Graphics[{Text[Style["Alternating Bit Protocol (ABP) Snake Model",Bold,14],{6,4.5}],Thick,Blue,BezierCurve[{{1,1},{2,3},{5,3},{6,1}}],Thick,Red,Dashed,BezierCurve[{{6,1},{7,-1},{10,-1},{11,1}}],Text[Style["TX snake",Blue,Bold,12],{3.5,3.3}],Text[Style["RX snake (ACK)",Red,Bold,12],{8.5,-1.3}],{PointSize[Large],Black,Point[{1,1}],Point[{6,1}],Point[{11,1}]}},PlotRange->{{0,12},{-2,5}},ImageSize->500];Column[{drawSlices[],Spacer[20],drawSACKFlow[],Spacer[20],drawBidirectionalChannel[],Spacer[20],draw4LayerInfoFramework[],Spacer[20],drawAntBeeRouting[],Spacer[20],drawPacketClocks[],Spacer[20],drawDatacenterTopologies[],Spacer[20],drawABPsnake[]},Spacings->3]]


Module[{sliceCount=8,layers={"Information","Knowledge","Semantics","Understanding"},sackCodes={"00","01","10","11"},gridSize=5,layerColors,shannonChannelGraphics,centralizedPlot,decentralizedPlot,distributedPlot,hlcGraphics},layerColors=ColorData["Rainbow"]/@Rescale[Range[Length[layers]]];drawSlice[pos_,label_,col_,width_:1]:={col,EdgeForm[Black],Rectangle[{pos,0},{pos+width,1}],Black,Text[Style[label,Bold,12],{pos+width/2,0.5}]};drawSackMarker[pos_,label_,col_]:={col,Disk[{pos,1.3},0.12],Black,Text[Style[label,Bold,10],{pos,1.3}]};shannonChannelGraphics=Module[{shannonSlices,sackMarkers,sackPositions={1,2,4,8}},shannonSlices=Table[drawSlice[i,"Slice "<>ToString[i+1],LightBlue],{i,0,sliceCount-1}];sackMarkers=Table[drawSackMarker[sackPositions[[i]]-0.5,"SACK "<>sackCodes[[i]],layerColors[[i]]],{i,Length[sackPositions]}];Graphics[{shannonSlices,sackMarkers,Black,Text[Style["Pipelined Slices + SACKs",Bold,16],{sliceCount/2,2}]},PlotRange->{{-0.5,sliceCount+0.5},{-0.5,2.2}},ImageSize->600,Axes->False]];centralizedPlot=Graph[StarGraph[47],VertexLabels->None,VertexSize->0.3,PlotLabel->Style["Centralized",Bold,14],ImageSize->300];decentralizedPlot=Graph[CompleteGraph[7],VertexLabels->None,GraphLayout->"SpringElectricalEmbedding",PlotLabel->Style["Decentralized",Bold,14],ImageSize->300];distributedPlot=RandomGraph[{47,98},VertexLabels->None,GraphLayout->"SpringElectricalEmbedding",PlotLabel->Style["Distributed",Bold,14],ImageSize->300];hlcGraphics=Module[{hlcUpdates,hlcEpsilon=5},hlcUpdates=Table[{1000+RandomInteger[{-5,5}],RandomInteger[{0,3}]},{15}];GraphicsGrid[{{ListLinePlot[Transpose[hlcUpdates],PlotLegends->{"Physical Time","Logical Counter"},PlotLabel->"HLC Points (pt, ctr)",ImageSize->300]},{Graphics[{Black,Circle[{0,0},hlcEpsilon],Text[Style["HLC \[CurlyEpsilon] Bound (\[PlusMinus]"<>ToString[hlcEpsilon]<>")",Bold,12],{0,hlcEpsilon+3}]},PlotRange->All,ImageSize->300]}}]];Column[{Style["\[CapitalAE]thernet Architecture Visualizations \[LongDash] Chapter 6",20,Bold,"Helvetica"],Spacer[10],Style["6.1 Back-to-Back Shannon Channels",16,Bold],shannonChannelGraphics,Spacer[10],Style["6.31 Datacenter Network Topologies (Baran Classification)",16,Bold],Grid[{{centralizedPlot,decentralizedPlot,distributedPlot}},Spacings->2],Spacer[10],Style["6.36 Hybrid Logical Clock (HLC) Model",16,Bold],hlcGraphics},Spacings->2,Alignment->Center]]


Module[{n=6,k=5,rollbackAt=3,T,Tinv,v0,vStates,vRollback,composeTx,txGraph,loopCyclePlot,laplacianEigen,DLR,ackProjPlot,spanningTreePlot,snakeGraphics},randInv[d_]:=Module[{m},While[True,m=RandomInteger[{0,1},{d,d}];If[Mod[Det[m],2]==1,Return[m]]]];step[v_,M_]:=Mod[M . v,2];laplacianEigen[g_?GraphQ]:=Module[{L,vals},If[VertexCount[g]<2||EdgeCount[g]==0,Return[0]];L=Normal[LaplacianMatrix[g]];vals=DeleteCases[Eigenvalues[N[L]],x_/;x<1.*^-8];If[vals==={},0,Min[vals]]];DLR[g_?GraphQ,r_Integer?NonNegative]:=Mean[Table[laplacianEigen[EdgeDelete[g,RandomSample[EdgeList[g],Min[i,EdgeCount[g]]]]],{i,0,r}]];T=Table[randInv[n],{k}];Tinv=Reverse[(Inverse[#1,Modulus->2]&)/@T];v0=RandomInteger[{0,1},n];vStates=FoldList[step,v0,T];vRollback=Fold[step,vStates[[rollbackAt]],Take[Tinv,k-rollbackAt+1]];composeTx=Fold[Dot,IdentityMatrix[n],Reverse[T]];txGraph=Graph[Table[i->i+1,{i,0,k-1}],VertexLabels->"Name",DirectedEdges->True];loopCyclePlot=GraphicsRow[Table[ArrayPlot[Mod[Fold[Dot,IdentityMatrix[n],Take[T,i]],2],Frame->True,ImageSize->Small,PlotLabel->Style[Row[{"T",i," \[SmallCircle]\[SmallCircle] \[Ellipsis] \[SmallCircle]\[SmallCircle] T\:2081"}],11]],{i,1,k}]];ackProjPlot=GraphicsGrid[{{Style["Unacknowledged",11],Style["Acknowledged (Projection)",11]},{ArrayPlot[Outer[BitXor,v0,v0],Frame->False,ImageSize->Small],ArrayPlot[Outer[BitXor,vStates[[-1]],vStates[[-1]]],Frame->False,ImageSize->Small]}}];spanningTreePlot:=Module[{g=RandomGraph[{10,15}]},HighlightGraph[g,FindSpanningTree[g]]];snakeGraphics=Graphics[{Thick,Arrowheads[Medium],Arrow[{{0,0},{2,1},{4,0}}],Text["Tx(T\[CenterDot]v)",{0,0},{-1,-1}],Arrow[{{4,0},{2,-1},{0,0}}],Text["Ack(T\:207b\.b9)",{4,0},{1,-1}],Dashed,Circle[{2,0},2.2]},PlotRange->{{-1,5},{-2,2}},ImageSize->Medium,Axes->False];Grid[{{Style["Reversible Transactions on \|01d53d\:2082\:2076",14,Bold],\[SpanFromLeft]},{"Initial vector  v\:2080",MatrixForm[v0]},{"Forward states  (T\:1d62 applied)",Column[MatrixForm/@vStates]},{"Rollback starting at step "<>ToString[rollbackAt-1],MatrixForm[vRollback]},{"Transaction DAG",txGraph},{"Loop-closure sequence",loopCyclePlot},{"Ack projection demo",ackProjPlot},{"Spanning tree (deterministic recovery)",spanningTreePlot},{"Snake circulation model",snakeGraphics}},Alignment->Left,Frame->All,Spacings->{1,2}]]


ClearAll["Global`*"];
rxTxPipe=Graphics[{Arrowheads[0.04],Text["TX SLICE 1",{-4,2}],Arrow[{{-3.5,2},{-2,2}}],Text["SLICE 2",{-3,1}],Arrow[{{-2.5,1},{-1,1}}],Text["SLICE 3-4",{-2,0}],Arrow[{{-1.5,0},{0,0}}],Text["SLICE 5-8",{-1,-1}],Arrow[{{-0.5,-1},{1,-1}}],Text["SACK 11",{1.5,-1}],Dashed,Arrow[{{1,-1},{-0.5,2}}],Style[Text["Bidirectional Pipe",{0,3}],Bold,14]},PlotRange->{{-5,5},{-2,4}},ImageSize->400,PlotLabel->Style["Bidirectional Shannon Channel",14,Bold]];
semanticLayers=GraphicsGrid[{{Style["SACK 00  \[Dash]  Information",12,Bold],Style["SACK 01  \[Dash]  Knowledge",12,Bold]},{Style["SACK 10  \[Dash]  Semantics",12,Bold],Style["SACK 11  \[Dash]  Understanding",12,Bold]}},Frame->All,Spacings->2,Background->{None,{Lighter[Gray,.9]}}];
gClockTile=Graph[{1->2,2->3,3->6,6->9,9->8,8->7,7->4,4->1},VertexCoordinates->Thread[Range[9]->Tuples[Range[0,2],2]],DirectedEdges->True,VertexLabels->"Name",PlotLabel->"Race-Free ANT Clock \[CenterDot] 3\[Times]3",ImageSize->300];
scoutField=Graphics[Table[{Arrow[{{0,0},r {Cos[\[Theta]],Sin[\[Theta]]}}],Text["BEE",1.15 r {Cos[\[Theta]],Sin[\[Theta]]}]},{\[Theta],0,2 \[Pi]-\[Pi]/4,\[Pi]/4},{r,2}],PlotRange->2.5,ImageSize->300,PlotLabel->"Radial BEE Scouts"];
hybridClockSim:=Module[{\[CurlyEpsilon]=2,now=100,evts,shade},evts=Table[{i,RandomInteger[{now-\[CurlyEpsilon],now+\[CurlyEpsilon]}]},{i,1,10}];shade=Rectangle[{now-\[CurlyEpsilon],-1},{now+\[CurlyEpsilon],11}];Show[Graphics[{LightRed,shade}],ListPlot[evts,PlotStyle->Red,PlotMarkers->Automatic],Frame->True,PlotRange->{{90,110},{0,11}},PlotLabel->"Hybrid Logical Clock   \[PlusMinus]\[CurlyEpsilon]"]];
tsvfGraphic=GraphicsRow[{Graphics[{Arrowheads[0.04],Blue,Arrow[{{-3,0},{0,0}}]},PlotRange->{{-3,3},{-1,1}},ImageSize->200,PlotLabel->Style["|\[Psi](t)\:27e9  (forward)",Blue,11,Bold]],Graphics[{Arrowheads[0.04],Red,Arrow[{{3,0},{0,0}}]},PlotRange->{{-3,3},{-1,1}},ImageSize->200,PlotLabel->Style["\:27e8\[CurlyPhi](t)|  (backward)",Red,11,Bold]]}];
baranTopos=GraphicsGrid[{{Graph[StarGraph[5],PlotLabel->"Centralised",ImageSize->200],Graph[GraphData["PetersenGraph"],PlotLabel->"Decentralised",ImageSize->200],Graph[RandomGraph[{15,30}],PlotLabel->"Distributed",ImageSize->200]}},Spacings->2];
Panel[Column[{Style["Chapter 6  \[Dash]  \[CapitalAE]thernet Architectural Visuals",18,Bold,Blue],Spacer[5],rxTxPipe,semanticLayers,gClockTile,scoutField,hybridClockSim[],tsvfGraphic,baranTopos},Background->Lighter[Gray,.95],FrameMargins->15]]


ClearAll["Global`*"];
serDesDiagram[]:=Graphics[{Text[Style["ETHERNET TX",14,Bold],{-2,5}],Text[Style["ETHERNET RX",14,Bold],{6,5}],Text["TX SERDES",{0,4}],Text["RX SERDES",{4,4}],Arrowheads[0.04],Arrow[{{-3.5,3},{-2,3}}],Arrow[{{4,3},{6,3}}],Table[{Text[Style["TX SLICE "<>ToString[i],10],{0,3-.6 i}],Text[Style["RX SLICE "<>ToString[i],10],{4,3-.6 i}]},{i,1,4}]},PlotRange->{{-4,7},{-1,5}},ImageSize->400,PlotLabel->Style["Bidirectional Shannon Channels",14,Bold]];
sackFeedback[slice_Integer,lab_]:=Graphics[{Arrowheads[0.04],Arrow[{{0,0},{2,0}}],Text[Style[lab,12,Red],{2.7,0}]},PlotRange->{{-0.5,3.5},{-0.5,0.5}},ImageSize->200,PlotLabel->"Feedback on slice "<>ToString[slice]];
layeredSackPlot:=BarChart[{1,2,3,4},ChartLabels->(Style[#1,10]&)/@{"Information","Knowledge","Semantics","Syntax"},BarOrigin->Left,ChartStyle->{LightBlue,LightGreen,LightYellow,LightOrange},PlotLabel->"Progressive Layered Semantics (SACK 00 \[RightArrow] SACK 11)",ImageSize->400];
antClock:=HighlightGraph[GridGraph[{3,3}],PathGraph[{{2,2},{2,3},{3,3},{3,2},{2,2}}],GraphStyle->"NameLabeled",ImageSize->250,PlotLabel->"Race-Free ANT Clock (3\[Times]3)"];
beeScout:=Module[{g=GridGraph[{7,7}],center=25},HighlightGraph[g,PathGraph[{center,center+1,center+2,center+3,center+2,center+1,center}],GraphStyle->"NameLabeled",ImageSize->300,PlotLabel->"BEE Scout (radial) 7\[Times]7 mesh"]];
compassClock:=HighlightGraph[GridGraph[{3,3}],PathGraph[{{2,2},{2,3},{3,3},{3,2},{3,1},{2,1},{1,1},{1,2},{1,3},{2,3}}],GraphStyle->"NameLabeled",ImageSize->250,PlotLabel->"Compass-based One-Hop Clock"];
hlcDiagram:=Module[{eps=2,now=100,events},events=Table[{i,RandomInteger[Evaluate[{now-eps,now+eps}]]},{i,1,10}];Show[Graphics[{LightRed,Rectangle[{now-eps,-1},{now+eps,11}]}],ListPlot[events,PlotStyle->Red,PlotMarkers->Automatic],Frame->True,PlotRange->{{90,110},{0,11}},ImageSize->350,PlotLabel->"Hybrid Logical Clock window \[PlusMinus]\[CurlyEpsilon]"]];
traphOverlay:=Module[{g=RandomGraph[{15,25}]},HighlightGraph[g,FindSpanningTree[g],GraphStyle->"ThickEdge",ImageSize->300,PlotLabel->"TRAPH overlay on random mesh"]];
tsvfDiagram:=Graphics[{Arrowheads[0.06],Blue,Arrow[{{-3,0},{0,0}}],Text[Style["|\[Psi](t)\:27e9",Blue,12,Bold],{-3.3,0}],Red,Arrow[{{3,0},{0,0}}],Text[Style["\:27e8\[CurlyPhi](t)|",Red,12,Bold],{3.3,0}],Dashed,Line[{{0,-.6},{0,.6}}],Text["Layer \[ScriptL]",{0,0.8}],Darker[Green],Text[Style["update  \:27e8\[CurlyPhi]|A|\[Psi]\:27e9",11],{0,1.4}]},PlotRange->{{-4,4},{-1.5,2}},ImageSize->300,PlotLabel->"Two-State Vector Formalism"];
Column[{Style["Chapter 6 \[LongDash] Visual Reference",20,Bold,Blue]," ",Style["1. Independent Shannon Channels",14,Bold],serDesDiagram[],Style["2. Slice-ACK feedback",14,Bold],Row[{sackFeedback[1,"SACK 1"],Spacer[10],sackFeedback[8,"SACK 8"]}],Style["3. Four-layer semantics",14,Bold],layeredSackPlot,Style["4. Local ANT packet clock",14,Bold],antClock,Style["5. Long-range BEE scout",14,Bold],beeScout,Style["6. Compass-based one-hop clock",14,Bold],compassClock,Style["7. Hybrid Logical Clock view",14,Bold],hlcDiagram,Style["8. TRAPH overlay",14,Bold],traphOverlay,Style["9. TSVF bidirectional update",14,Bold],tsvfDiagram},Spacings->2,Frame->True,Background->Lighter[Gray,.97],FrameMargins->10]


Module[{n=8,k=6,rollbackAt=4,randInv,step,inverseChain,T,Tinv,v0,vStates,rollbackState,transactionAlgebraPlot,reversibleBufferGrid,g,pos,edgeTx,edgeInvTx,stateVecs,spanningTree,failedEdges,laplacians,lambda2s,dlr,font=Directive[FontFamily->"Arial",FontSize->12]},randInv[d_]:=Module[{m},While[True,m=RandomInteger[{0,1},{d,d}];If[Mod[Det[m],2]==1,Return[m]]]];step[v_,m_]:=Mod[m . v,2];inverseChain[mats_]:=Reverse[(Inverse[#1,Modulus->2]&)/@mats];T=Table[randInv[n],{k}];Tinv=inverseChain[T];v0=RandomInteger[{0,1},n];vStates=FoldList[step,v0,T];rollbackState=Fold[step,Last[vStates],Take[Tinv,k-rollbackAt+1]];reversibleBufferGrid=Grid[Prepend[Table[{i-1,MatrixForm[vStates[[i]]]},{i,Length[vStates]}],{"Step","Vector State"}],Frame->All,Alignment->Center,ItemStyle->font];transactionAlgebraPlot=ListLinePlot[Transpose[vStates],PlotMarkers->Automatic,PlotRange->All,PlotLabel->Style["Transaction Algebra: Tv Chain",font],AxesLabel->{"Step","Bit Value"},PlotLegends->Placed[LineLegend[Range[n]],Right]];g=RandomGraph[{8,10},DirectedEdges->True];pos=GraphEmbedding[g];spanningTree=FindSpanningTree[g];edgeTx=AssociationThread[EdgeList[g],Table[randInv[n],{EdgeCount[g]}]];edgeInvTx=AssociationMap[Inverse[#1,Modulus->2]&,edgeTx];stateVecs=AssociationThread[VertexList[g],Table[RandomInteger[{0,1},n],{VertexCount[g]}]];Do[Module[{src,dst,Tmat},{src,dst}=List@@e;Tmat=edgeTx[e];stateVecs[dst]=Mod[Tmat . stateVecs[src],2];],{e,EdgeList[spanningTree]}];Graph[stateVecs,VertexLabels->Placed[MatrixForm/@stateVecs,Center],VertexStyle->LightBlue,EdgeStyle->Black,GraphLayout->{"VertexCoordinates"->pos},PlotLabel->Style["Spanning Tree: State Propagation",font]];failedEdges=RandomSample[EdgeList[g],Min[5,EdgeCount[g]]];laplacians=Table[GraphLaplacian[EdgeDelete[g,Take[failedEdges,i]]],{i,Length[failedEdges]}];lambda2s=Table[With[{vals=Sort[Eigenvalues[L]]},If[Length[vals]>=2,vals[[2]],0]],{L,laplacians}];dlr=Mean[lambda2s];Print[Style["DLR (Dynamic Laplacian Resilience): "<>ToString[NumberForm[dlr,{4,3}]],font]];GraphicsGrid[{{Graphics[{Arrowheads[0.04],Style[Circle[{0,0},1],LightGray],(Arrow[{{Cos[#1],Sin[#1]},{Cos[#1+(2 \[Pi])/k],Sin[#1+(2 \[Pi])/k]}}]&)/@Range[0,2 \[Pi],(2 \[Pi])/k],Red,Disk[{0,0},0.1]},PlotLabel->Style["Circular Snake: Head \[RightArrow] Tail \[RightArrow] Commit",font],ImageSize->300],transactionAlgebraPlot},{reversibleBufferGrid,Graphics[{Blue,Arrow[{{0,0},{1,0}}],Text[Style["T",font],{0.5,0.1}],Dashed,Red,Arrow[{{1,0},{0,0}}],Text[Style["T^{-1}",font],{0.5,-0.1}]},PlotLabel->Style["Forward and Reverse: Linear Transform + Inverse",font],ImageSize->300]}}]]


Module[{layers={"Information","Knowledge","Semantics","Syntax"},colors={LightBlue,LightGreen,Orange,LightRed},nodeCount=49,valency=5,clockPath,beePath,randomTopology,layerGraphic,sackFlowGraphic,antClockGraphic,beeScoutGraphic,baranTopologyGraphic,hlcEventTimeline,hlcTimelineGraphic},layerGraphic:=GraphicsGrid[Table[{Style[layers[[i]],14,Bold],Graphics[{colors[[i]],Rectangle[{0,0},{4,1}]},PlotLabel->"SACK "<>StringJoin[IntegerString[i-1,2,2]],ImageSize->Medium]},{i,4}],Spacings->{2,1}];sackFlowGraphic:=Graphics[{Arrowheads[0.03],Table[{Arrow[{{i,0},{i,4}}],Arrow[{{i+0.5,4},{i+0.5,0}}]},{i,0,3}],Red,MapIndexed[Text[Style["SACK "<>StringJoin[IntegerString[#2[[1]]-1,2,2]],Bold,12],{#1,4.2}]&,Range[0.5,3.5,1]]},PlotRange->{{-1,5},{-1,5}},ImageSize->Large,PlotLabel->"Bi-directional Shannon-Metcalfe Channel with SACK Feedback"];clockPath={{1,1},{2,1},{2,2},{1,2},{1,1}};antClockGraphic:=Graphics[{LightGray,GridLines->Automatic,Table[Rectangle[{i,j},{i+1,j+1}],{i,0,2},{j,0,2}],Red,Thick,Arrow[clockPath],Blue,PointSize[Large],Point/@clockPath},PlotRange->{{0,3},{0,3}},ImageSize->Medium,PlotLabel->"Race-Free ANT Clock (3x3 Grid)"];beePath=Table[{i,i},{i,0,5}];beeScoutGraphic:=Graphics[{Dashed,Arrow[beePath],Blue,PointSize[Medium],Point/@beePath,Red,Text["Outbound",beePath[[1]]-{0.5,0.5}],Green,Text["Return",Last[beePath]+{0.5,0.5}]},PlotRange->{{-1,6},{-1,6}},ImageSize->Medium,PlotLabel->"BEE Scout: Radial Exploration + Return"];randomTopology:=RandomGraph[{nodeCount,Floor[(nodeCount valency)/2]},GraphLayout->"SpringElectrical"];baranTopologyGraphic:=Graph[randomTopology,VertexLabels->"Name",ImageSize->Medium,PlotLabel->"Distributed Topology (Baran Style, Valency \[TildeTilde] "<>ToString[valency]<>")"];hlcEventTimeline=Table[{{i,RandomReal[{0,10}]},{i,RandomReal[{10,20}]}},{i,1,6}];hlcTimelineGraphic:=ListLinePlot[hlcEventTimeline,Joined->True,PlotMarkers->Automatic,PlotStyle->Thick,AxesLabel->{"Node ID","Timestamp"},PlotLabel->"Hybrid Logical Clock Timeline (\[CurlyEpsilon]-bound)",ImageSize->Medium];Column[{Style["Chapter 6: \[CapitalAE]thernet Architecture \[LongDash] Mathematica Visualizations",18,Bold],Panel[layerGraphic,Style["6.1.2\[Dash]6.2.4: Shannon Feedback Layers",14,Bold]],Panel[sackFlowGraphic],Panel[antClockGraphic,Style["6.6\[Dash]6.7: ANT Packet Clocks",14,Bold]],Panel[beeScoutGraphic,Style["6.5, 6.9: BEE Radial Scouts",14,Bold]],Panel[baranTopologyGraphic,Style["6.31\[Dash]6.34: Distributed Baran Topology",14,Bold]],Panel[hlcTimelineGraphic,Style["6.36: Hybrid Logical Clock Events",14,Bold]]},Spacings->2]]


Module[{n=6,k=5,rollbackAt=3,T,Tinv,v0,vStates,vRollback,composeTx,txGraph,loopCyclePlot,laplacianEigen,DLR,ackProjPlot,snakeGraphics,assertIdentity},randInv[d_]:=Module[{m},While[True,m=RandomInteger[{0,1},{d,d}];If[Mod[Det[m],2]==1,Return[m]]]];step[v_,M_]:=Mod[M . v,2];laplacianEigen[g_?GraphQ]:=Module[{L,vals},If[VertexCount[g]<2||EdgeCount[g]==0,Return[0]];L=Normal[LaplacianMatrix[g]];vals=DeleteCases[Eigenvalues[N[L]],x_/;x<1.*^-8];If[vals==={},0,Min[vals]]];DLR[g_?GraphQ,r_Integer?NonNegative]:=Mean[Table[laplacianEigen[EdgeDelete[g,RandomSample[EdgeList[g],Min[i,EdgeCount[g]]]]],{i,0,r}]];T=Table[randInv[n],{k}];Tinv=Reverse[(Inverse[#1,Modulus->2]&)/@T];v0=RandomInteger[{0,1},n];vStates=FoldList[step,v0,T];vRollback=Fold[step,vStates[[rollbackAt]],Take[Tinv,k-rollbackAt+1]];composeTx=Fold[Dot,IdentityMatrix[n],Reverse[T]];assertIdentity=Mod[composeTx . Fold[Dot,IdentityMatrix[n],Tinv],2];txGraph=Graph[Table[i->i+1,{i,0,k-1}],VertexLabels->"Name",DirectedEdges->True];loopCyclePlot=GraphicsRow[Table[ArrayPlot[Mod[Fold[Dot,IdentityMatrix[n],Take[T,i]],2],Frame->True,ImageSize->Small,PlotLabel->Style[Row[{"T",i," \[SmallCircle] \[Ellipsis] \[SmallCircle] T\:2081"}],11]],{i,1,k}]];ackProjPlot=GraphicsGrid[{{Style["Unacknowledged",11],Style["Acknowledged",11]},{ArrayPlot[Outer[BitXor,v0,v0],Frame->False,ImageSize->Small],ArrayPlot[Outer[BitXor,vStates[[-1]],vStates[[-1]]],Frame->False,ImageSize->Small]}}];snakeGraphics=Graphics[{Thick,Arrowheads[Medium],Arrow[{{0,0},{2,1},{4,0}}],Text["Tx(T\[CenterDot]v)",{-0.3,0}],Arrow[{{4,0},{2,-1},{0,0}}],Text["Ack(T\:207b\.b9)",{4.3,0}],Dashed,Circle[{2,0},2.2]},PlotRange->{{-1,5},{-2,2}},ImageSize->Medium,Axes->False];Grid[{{Style["Reversible Transactions on \|01d53d\:2082\:2076",14,Bold],\[SpanFromLeft]},{"Initial vector  v\:2080",MatrixForm[v0]},{"Forward states  (T\:1d62 applied)",Column[MatrixForm/@vStates]},{"Rollback starting at step "<>ToString[rollbackAt-1],MatrixForm[vRollback]},{"Proof  T\[CenterDot]T\:207b\.b9 = I",MatrixForm[assertIdentity]},{"Transaction DAG",txGraph},{"Loop-closure sequence",loopCyclePlot},{"Ack projection demo",ackProjPlot},{"Snake circulation model",snakeGraphics}},Alignment->Left,Frame->All,Spacings->{1,2}]]


Module[{frameSlices=8,sackColors={LightBlue,LightGreen,LightOrange,LightRed},pipeHeight=0.5,sliceWidth=1,txPipeY=3,rxPipeY=1,layers={{"00","Information\n(Surprisal)\nValid Bits Received"},{"01","Knowledge\n(Buffer Storage)"},{"10","Semantics\n(Meaning & Action)"},{"11","Understanding\n(Syntax Finalisation)"}},drawSlices,drawSacks,serDesGraphic,layerGraphic,decentralizedGraph,distributedGraph,hlcGraph},drawSlices[baseY_,label_]:=Module[{rects,lbls},rects=Table[{EdgeForm[Black],FaceForm[LightGray],Rectangle[{(i-1) sliceWidth,baseY},{i sliceWidth,baseY+pipeHeight}]},{i,frameSlices}];lbls=Table[Text[Style[i,10,Bold],{(i-0.5) sliceWidth,baseY+pipeHeight/2}],{i,frameSlices}];{Text[Style[label,14,Bold],{-1.5,baseY+pipeHeight/2}],rects,lbls}];drawSacks[]:=Module[{pos},pos=Table[{(i-0.5) sliceWidth,(txPipeY+rxPipeY)/2},{i,frameSlices}];{Arrowheads[0.03],Blue,Table[Arrow[{pos[[i]]+{0,0.3},pos[[i]]-{0,0.3}}],{i,frameSlices}]}];serDesGraphic=Graphics[{drawSlices[txPipeY,"ETHERNET TX"],drawSlices[rxPipeY,"ETHERNET RX"],drawSacks[]},PlotRange->{{-2,frameSlices+1},{0,txPipeY+pipeHeight+1}},ImageSize->500,Background->Lighter[Gray,.95],Axes->False];layerGraphic=Graphics[Table[{EdgeForm[Black],FaceForm[sackColors[[i]]],Rectangle[{0,i-1},{4,i}],Text[Style[layers[[i,1]],16,White,Bold],{0.5,i-0.5},{-1,0}],Text[Style[layers[[i,2]],12],{2.6,i-0.5}]},{i,4}],PlotRange->{{0,4},{0,4}},ImageSize->330,Background->Lighter[Gray,.9],Axes->False];decentralizedGraph=Graph[Join[Table[i->47,{i,1,7}],Table[j->RandomInteger[{1,7}],{j,8,47}]],VertexLabels->"Name",ImageSize->230];distributedGraph=RandomGraph[{47,98},VertexLabels->"Name",ImageSize->230];hlcGraph=Graph[{"Local","Send","Recv"},DirectedEdge@@@{{"Local","Send"},{"Send","Recv"}},VertexLabels->{"Local"->"Local Event","Send"->"Send Msg","Recv"->"Receive Msg"},ImageSize->280];Column[{Style["\[Section]6 Architecture  \[Bullet]  Visual Companion",20,Bold,Blue],Spacer[8],Style["6.1  Bidirectional Shannon Channels",14,Bold],serDesGraphic,Spacer[8],Style["6.2  Four Shannon-like Layers via SACKs",14,Bold],layerGraphic,Spacer[8],Row[{Column[{"Decentralised",decentralizedGraph},Center],Spacer[12],Column[{"Distributed",distributedGraph},Center]}],Spacer[8],Style["6.36  Hybrid Logical Clock (concept DAG)",14,Bold],hlcGraph},Spacings->2]]


Module[{frameSlices=8,sackColors={Lighter[Blue,.7],Lighter[Green,.6],Lighter[Orange,.6],Lighter[Red,.6]},pipeHeight=.5,sliceWidth=1,txY=3,rxY=1,layers={{"00","Information\n(Surprisal)"},{"01","Knowledge\n(Buffer Storage)"},{"10","Semantics\n(Meaning & Action)"},{"11","Understanding\n(Syntax)"}},serDesGraf,fourLayerGraf,decTopo,distTopo,antGraf,beeGraf,hlcGraf},drawRow[y_,lab_]:=Module[{rects,lbls},rects=Table[{EdgeForm[Black],FaceForm[LightGray],Rectangle[{(i-1) sliceWidth,y},{i sliceWidth,y+pipeHeight}]},{i,frameSlices}];lbls=Table[Text[Style[i,10,Bold],{(i-.5) sliceWidth,y+pipeHeight/2}],{i,frameSlices}];Join[{Text[Style[lab,14,Bold],{-1.4,y+pipeHeight/2}]},rects,lbls]];serDesGraf=Graphics[{drawRow[txY,"ETHERNET TX"],drawRow[rxY,"ETHERNET RX"],Arrowheads[.03],Blue,Table[Arrow[{{(i-.5) sliceWidth,txY+.7},{(i-.5) sliceWidth,rxY-.2}}],{i,frameSlices}]},PlotRange->{{-2,frameSlices+1},{0,txY+1.2}},ImageSize->500,Background->Lighter[Gray,.95],Axes->False,PlotLabel->Style["6.1  Bidirectional Shannon Channels",14,Bold]];fourLayerGraf=Graphics[Table[{EdgeForm[Black],FaceForm[sackColors[[i]]],Rectangle[{0,i-1},{4,i}],Text[Style[layers[[i,1]],16,White,Bold],{.5,i-.5},{-1,0}],Text[Style[layers[[i,2]],12],{2.6,i-.5}]},{i,4}],PlotRange->{{0,4},{0,4}},ImageSize->330,Background->Lighter[Gray,.9],Axes->False,PlotLabel->Style["6.2  Four Shannon-like Layers",14,Bold]];decTopo=Graph[Join[Table[i->30,{i,1,7}],Table[j->RandomInteger[{1,7}],{j,8,30}]],VertexLabels->"Name",ImageSize->230];distTopo=RandomGraph[{30,60},VertexLabels->"Name",ImageSize->230];antGraf:=Module[{square=Tuples[Range[0,2],2]+1,cw={{1,1},{2,1},{3,1},{3,2},{3,3},{2,3},{1,3},{1,2},{1,1}},ccw=Reverse[{{1,1},{2,1},{3,1},{3,2},{3,3},{2,3},{1,3},{1,2},{1,1}}]},Graphics[{LightGray,EdgeForm[Black],Table[(Rectangle[#1-.5,#1+.5]&)/@square],Blue,Thick,Arrow[cw],Red,Thick,Arrow[ccw],Text[Style["CW",12,Blue],{3.5,1.3}],Text[Style["CCW",12,Red],{3.5,2.7}]},PlotRange->{{.3,4.3},{.3,4.3}},ImageSize->260,PlotLabel->Style["6.6\[Dash]6.7  Race-Free ANT Clock",14,Bold]]];beeGraf:=Module[{out=Table[{x,1},{x,1,6}],back=Table[{x,1.2},{x,6,1,-1}]},Graphics[{Thick,Blue,Arrow[out],Thick,Red,Arrow[back],Text[Style["outbound",11,Blue],{6.8,1}],Text[Style["return",11,Red],{.3,1.25}]},PlotRange->{{0,7},{.7,1.6}},ImageSize->260,PlotLabel->Style["6.9  BEE Scout Path",14,Bold]]];hlcGraf:=Graph[{"Local","Send","Recv"},DirectedEdge@@@{{"Local","Send"},{"Send","Recv"}},VertexLabels->{"Local"->"Local Event","Send"->"Send Msg","Recv"->"Receive Msg"},ImageSize->280,PlotLabel->Style["6.36  Hybrid Logical Clock DAG",14,Bold]];Column[{Style["\[Section]6  Architecture  \[Dash]  Visual Companion",20,Bold,Blue],Spacer[6],serDesGraf,Spacer[6],fourLayerGraf,Spacer[6],Row[{Column[{"Decentralised",decTopo},Center],Spacer[10],Column[{"Distributed",distTopo},Center]}],Spacer[6],antGraf,Spacer[6],beeGraf,Spacer[6],hlcGraf},Spacings->2]]


Module[{metcalfeGraph,sackLayers,bidirShannonGraph,antBeeScouting,tsvfLearning},metcalfeGraph:=Module[{tx={"BEGIN","TX 1-2","TX 3-4","TX 5-8","TX SERDES","ETH TX"},rx={"RX SERDES","RX 1-2","RX 3-4","RX 5-8","COMPLETE"},g,pos},g=Graph[Join[DirectedEdge@@@Partition[tx,2,1],DirectedEdge@@@Partition[Reverse[rx],2,1]],DirectedEdges->True,VertexLabels->"Name"];pos=Join[Thread[tx->Thread[{Range[Length[tx]],1}]],Thread[Reverse[rx]->Thread[{Range[Length[rx]],0}]]];Graph[g,VertexCoordinates->pos,ImageSize->280,PlotLabel->Style["Two Independent\nMetcalfe Channels",12,Bold]]];sackLayers:=Module[{layers={"Information\n(SACK 00)","Knowledge\n(SACK 01)","Semantics\n(SACK 10)","Understanding\n(SACK 11)"},g,pos},g=PathGraph[layers,DirectedEdges->True,VertexLabels->"Name"];pos=Thread[layers->Thread[{2 Range[Length[layers]],0}]];Graph[g,VertexCoordinates->pos,VertexStyle->LightBlue,EdgeStyle->Directive[Blue,Thick,Arrowheads[Medium]],ImageSize->280,PlotLabel->Style["Four Shannon-Like SACK Layers",12,Bold]]];bidirShannonGraph:=Module[{layers={"SACK 00","SACK 01","SACK 10","SACK 11"},aliceTx,aliceRx,bobTx,bobRx,edges,g,pos,n=4},aliceTx=("Alice TX "<>#1&)/@layers;aliceRx=("Alice RX "<>#1&)/@layers;bobTx=("Bob TX "<>#1&)/@layers;bobRx=("Bob RX "<>#1&)/@layers;edges=Join[DirectedEdge@@@Partition[aliceTx,2,1],DirectedEdge@@@Partition[aliceRx,2,1],DirectedEdge@@@Partition[bobTx,2,1],DirectedEdge@@@Partition[bobRx,2,1],Table[aliceTx[[i]]->bobRx[[i]],{i,n}],Table[bobTx[[i]]->aliceRx[[i]],{i,n}]];g=Graph[edges,DirectedEdges->True,VertexLabels->"Name"];pos=Join[Thread[aliceTx->Thread[{Range[n],3}]],Thread[aliceRx->Thread[{Range[n],2}]],Thread[bobTx->Thread[{Range[n],1}]],Thread[bobRx->Thread[{Range[n],0}]]];Graph[g,VertexCoordinates->pos,ImageSize->400,PlotLabel->Style["Full-Duplex Shannon Channels\n(slice-level feedback)",12,Bold]]];antBeeScouting:=Graphics[{}];tsvfLearning:=Module[{layers={"Input","Hidden 1","Hidden 2","Output"},fw,bw,g,pos},fw=DirectedEdge@@@Partition[layers,2,1];bw=Reverse/@fw;g=Graph[Join[fw,bw],VertexLabels->"Name"];pos=Thread[layers->Thread[{Range[Length[layers]],0}]];Graph[g,VertexCoordinates->pos,EdgeStyle->Join[(#1->{Blue,Thick}&)/@fw,(#1->{Red,Dashed,Thick}&)/@bw],VertexStyle->LightYellow,VertexSize->Large,ImageSize->300,PlotLabel->Style["TSVF \[Dash] forward (blue) / back-prop (red)",12,Bold]]];Grid[{{metcalfeGraph,sackLayers},{bidirShannonGraph,Spacer[30]},{tsvfLearning,Spacer[30]}},Spacings->{2,2}]]


Module[{backToBackShannonChannels,fullDuplexShannonMetcalfe,hybridLogicalClock},backToBackShannonChannels[]:=Module[{tx={"TX Slice 1","TX Slice 2","TX Slice 3-4","TX Slice 5-8"},rx={"RX Slice 1","RX Slice 2","RX Slice 3-4","RX Slice 5-8"},arrows,sack1,sack8},arrows=Table[{Blue,Arrowheads[0.03],Arrow[{{i,0.2},{i+0.7,0.2}}],Text[Style[tx[[i]],Blue,Bold],{i+0.35,0.35}],Red,Arrowheads[0.03],Arrow[{{i+0.7,-0.2},{i,-0.2}}],Text[Style[rx[[i]],Red,Bold],{i+0.35,-0.40}]},{i,Length[tx]}];sack1={Green,Thick,Arrow[{{1.35,0.40},{1.35,0.8}}],Arrow[{{1.35,0.8},{0.65,0.8}}],Arrow[{{0.65,0.8},{0.65,0.40}}],Text[Style["SACK1 Feedback",Darker[Green],Bold],{1,1}]};sack8={Green,Thick,Arrow[{{4.65,0.40},{4.65,0.8}}],Arrow[{{4.65,0.8},{3.35,0.8}}],Arrow[{{3.35,0.8},{3.35,0.40}}],Text[Style["SACK8 Feedback",Darker[Green],Bold],{4,1}]};Graphics[Join[Flatten[arrows],sack1,sack8],PlotRange->{{0,5.5},{-1,1.5}},ImageSize->Large,Background->LightGray,Frame->True,FrameTicks->None,Axes->False,PlotLabel->Style["Back-to-Back Shannon Channels with SACK Feedback",16,Bold]]];fullDuplexShannonMetcalfe[]:=Module[{tx={"TX Slice 1","TX Slice 2","TX Slice 3-4","TX Slice 5-8"},rx={"RX Slice 1","RX Slice 2","RX Slice 3-4","RX Slice 5-8"},txPos,rxPos,arrows,labels},txPos=Thread[tx->Table[{i,1},{i,Length[tx]}]];rxPos=Thread[rx->Table[{i,-1},{i,Length[rx]}]];arrows=Table[{Blue,Arrowheads[0.03],Arrow[{txPos[[i,2]],txPos[[i,2]]+{0.8,0}}],Red,Arrowheads[0.03],Arrow[{rxPos[[i,2]]+{0.8,0},rxPos[[i,2]]}]},{i,Length[tx]}];labels=Table[{Text[Style[tx[[i]],Blue,Bold],txPos[[i,2]]+{0.40,0.3}],Text[Style[rx[[i]],Red,Bold],rxPos[[i,2]]-{0.40,0.3}]},{i,Length[tx]}];Graphics[Join[Flatten[arrows],Flatten[labels]],PlotRange->{{0,5},{-2,2}},ImageSize->Large,Frame->True,Axes->False,PlotLabel->Style["Bidirectional Full-Duplex Shannon\[Dash]Metcalfe Channel",16,Bold]]];hybridLogicalClock[]:=Module[{events={"e\:2081","e\:2082","e\:2083","e\:2084","e\:2085"},pt={10,11,12,13,15},ctr={0,1,1,0,1}},ListLinePlot[{Thread[{Range[Length[events]],pt}],Thread[{Range[Length[events]],ctr}]},PlotMarkers->{"\[FilledCircle]","\[FilledSquare]"},PlotLegends->{"Physical Time  (pt)","Logical Counter (ctr)"},Frame->True,FrameLabel->{"Event Sequence",None},FrameTicks->{Thread[{Range[Length[events]],events}],Automatic},PlotRange->All,ImageSize->Large,PlotLabel->Style["Hybrid Logical Clock (HLC) \[Dash] Event Evolution",16,Bold]]];Column[{backToBackShannonChannels[],Spacer[20],fullDuplexShannonMetcalfe[],Spacer[20],hybridLogicalClock[]},Spacings->2]]


ClearAll[serDesDiagram,sackFeedback,layeredSackPlot,antClock,beeScout,compassClock,hlcDiagram,traphOverlay,tsvfDiagram];
serDesDiagram:=Graphics[{Text[Style["ETHERNET TX",14,Bold],{-2,5}],Text[Style["ETHERNET RX",14,Bold],{6,5}],Text["TX SERDES",{0,4}],Text["RX SERDES",{4,4}],Arrowheads[0.04],Arrow[{{-3.5,3},{-2,3}}],Arrow[{{4,3},{6,3}}],Table[{Text[Style["TX SLICE "<>ToString[i],10],{0,3-0.6 i}],Text[Style["RX SLICE "<>ToString[i],10],{4,3-0.6 i}]},{i,1,4}]},PlotRange->{{-4,7},{-1,5}},ImageSize->400,PlotLabel->Style["Bidirectional Shannon Channels",14,Bold]];
sackFeedback[slice_Integer,label_String]:=Graphics[{Arrowheads[0.04],Arrow[{{0,0},{2,0}}],Text[Style[label,12,Red],{2.7,0}]},PlotRange->{{-0.5,3.5},{-0.5,0.5}},ImageSize->200,PlotLabel->"Feedback on slice "<>ToString[slice]];
layeredSackPlot:=With[{layers={"Information","Knowledge","Semantics","Syntax"},colours={LightBlue,LightGreen,LightOrange,LightRed}},BarChart[ConstantArray[1,4],ChartLabels->(Style[#1,10]&)/@layers,BarOrigin->Left,ChartStyle->colours,PlotLabel->"Progressive Layered Semantics (SACK 00 \[RightArrow] SACK 11)",ImageSize->400]];
antClock:=HighlightGraph[GridGraph[{3,3}],PathGraph[{{2,2},{2,3},{3,3},{3,2},{2,2}}],GraphStyle->"NameLabeled",ImageSize->250,PlotLabel->"Race-Free ANT Clock (3\[Times]3)"];
beeScout:=Module[{g=GridGraph[{7,7}],c=25},HighlightGraph[g,PathGraph[{c,c+1,c+2,c+3,c+2,c+1,c}],GraphStyle->"NameLabeled",ImageSize->300,PlotLabel->"BEE Scout (radial) 7\[Times]7 mesh"]];
compassClock:=HighlightGraph[GridGraph[{3,3}],PathGraph[{{2,2},{2,3},{3,3},{3,2},{3,1},{2,1},{1,1},{1,2},{1,3},{2,3}}],GraphStyle->"NameLabeled",ImageSize->250,PlotLabel->"Compass-based One-Hop Clock"];
hlcDiagram:=Module[{\[CurlyEpsilon]=2,now=100,events},events=Table[{i,RandomInteger[{now-\[CurlyEpsilon],now+\[CurlyEpsilon]}]},{i,1,10}];Show[Graphics[{LightPink,Rectangle[{now-\[CurlyEpsilon],-1},{now+\[CurlyEpsilon],11}]}],ListPlot[events,PlotStyle->Red,PlotMarkers->Automatic],Frame->True,PlotRange->{{90,110},{0,11}},ImageSize->350,PlotLabel->"Hybrid Logical Clock window \[PlusMinus]\[CurlyEpsilon]"]];
traphOverlay:=Module[{g=RandomGraph[{15,25}]},HighlightGraph[g,FindSpanningTree[g],GraphStyle->"ThickEdge",ImageSize->300,PlotLabel->"TRAPH overlay on random mesh"]];
tsvfDiagram:=Graphics[{Arrowheads[0.06],Blue,Arrow[{{-3,0},{0,0}}],Text[Style["|\[Psi](t)\:27e9",Blue,12,Bold],{-3.3,0}],Red,Arrow[{{3,0},{0,0}}],Text[Style["\:27e8\[CurlyPhi](t)|",Red,12,Bold],{3.3,0}],Dashed,Line[{{0,-0.6},{0,0.6}}],Text["Layer \|01d4db",{0,0.8}],Darker[Green],Text[Style["update \:27e8\[CurlyPhi]| A |\[Psi]\:27e9",11],{0,1.4}]},PlotRange->{{-4,4},{-1.5,2}},ImageSize->300,PlotLabel->"Two-State Vector Formalism"];
Column[{Style["Chapter 6 \[LongDash] \[CapitalAE]thernet Architecture Visualisations",18,Bold],Spacer[8],Style["1. Bidirectional Shannon Channels",14,Bold],serDesDiagram,Style["2. Internal SACK Feedback",14,Bold],Row[{sackFeedback[1,"SACK 1"],Spacer[10],sackFeedback[8,"SACK 8"]}],Style["3. Four-layer Semantic Stack",14,Bold],layeredSackPlot,Style["4. Local ANT Clock (3\[Times]3)",14,Bold],antClock,Style["5. Long-range BEE Scout (7\[Times]7)",14,Bold],beeScout,Style["6. Compass-based One-Hop Clock",14,Bold],compassClock,Style["7. Hybrid Logical Clock View",14,Bold],hlcDiagram,Style["8. TRAPH Overlay",14,Bold],traphOverlay,Style["9. TSVF Bidirectional Update",14,Bold],tsvfDiagram},Spacings->2]


Module[{nSlices=8,sliceWidth=1,pipeHeight=0.6,txY=3,rxY=1,sackColors={LightBlue,LightGreen,LightOrange,LightRed},sackLabels={"00","01","10","11"},drawPipelineSlices,drawSACKFeedback,drawFourLayers,drawBidirectionalChannel,drawHybridLogicalClock,drawSlicesAtY,panel},drawSlicesAtY[y_,label_,highlights_:{}]:=Module[{rects,labels,colors},colors=Table[If[MemberQ[highlights,i],LightGreen,LightGray],{i,nSlices}];rects=Table[{EdgeForm[Black],FaceForm[colors[[i]]],Rectangle[{(i-1) sliceWidth,y},{i sliceWidth,y+pipeHeight}]},{i,nSlices}];labels=Table[Text[Style[ToString[i],Bold,14],{(i-0.5) sliceWidth,y+pipeHeight/2}],{i,nSlices}];{Text[Style[label,Bold,16],{-1.5,y+pipeHeight/2}],rects,labels}];drawPipelineSlices[]:=Graphics[{drawSlicesAtY[txY,"ETHERNET TX"],drawSlicesAtY[rxY,"ETHERNET RX"]},PlotRange->{{-2,nSlices+1},{0,txY+pipeHeight+1}},ImageSize->600,Background->Lighter[Gray,0.95],Axes->False];drawSACKFeedback[yTX_,yRX_,slices_List,label_]:=Module[{positions,arrows},positions=Table[{(i-0.5) sliceWidth,(yTX+yRX)/2},{i,slices}];arrows=Table[{Blue,Arrowheads[0.03],Arrow[{positions[[i]]+{0,0.4},positions[[i]]-{0,0.4}}],Text[Style[label,Bold,14,Blue],positions[[i]]+{0,0.7}]},{i,Length[slices]}];arrows];drawFourLayers[]:=Graphics[Table[{FaceForm[sackColors[[i]]],EdgeForm[Black],Rectangle[{0,i-1},{6,i}],Text[Style[sackLabels[[i]],Bold,20,White],{0.5,i-0.5}],Text[Style[Switch[i,1,"Information (Surprisal):\nValid Bits Received",2,"Knowledge (Captured Information):\nData Stored Correctly",3,"Semantics (Meaning):\nData Decoded & State Machine Activated",4,"Understanding (Syntax):\nComplete Frame Ready for Processing"],14,Black],{3.5,i-0.5},{Left,Center}]},{i,4}],PlotRange->{{0,6},{0,4}},ImageSize->500,Background->Lighter[Gray,0.9],Axes->False];drawBidirectionalChannel[]:=Graphics[{drawSlicesAtY[txY,"Alice TX",{1,2,3,4}],drawSlicesAtY[rxY,"Alice RX",{1,2,3,4}],GeometricTransformation[drawSlicesAtY[txY,"Bob TX",{5,6,7,8}],TranslationTransform[{10,0}]],GeometricTransformation[drawSlicesAtY[rxY,"Bob RX",{5,6,7,8}],TranslationTransform[{10,0}]],Blue,Arrowheads[0.025],Table[Arrow[{{(i-0.5) sliceWidth,txY+pipeHeight+0.1},{(i-0.5) sliceWidth,rxY-0.1}}],{i,nSlices}],Table[Arrow[{{10+(i-0.5) sliceWidth,txY+pipeHeight+0.1},{10+(i-0.5) sliceWidth,rxY-0.1}}],{i,nSlices}],Text[Style["Alice",Bold,18,Darker[Green]],{5,txY+pipeHeight+0.6}],Text[Style["Bob",Bold,18,Darker[Red]],{15,txY+pipeHeight+0.6}]},PlotRange->{{-2,22},{0,txY+pipeHeight+1}},ImageSize->900,Background->Lighter[Gray,0.95],Axes->False];drawHybridLogicalClock[]:=Graphics[{Style[Text["Hybrid Logical Clock (HLC)"],Bold,18,Black],Table[{LightBlue,Disk[{i 3,2},0.5],Black,Text[Style["Node "<>FromCharacterCode[64+i],Bold,14],{i 3,2}]},{i,3}],Arrowheads[0.03],Blue,Arrow[{{3,2},{6,2}}],Arrow[{{6,2},{3,1}}],Text[Style["Send Event: pt, ctr Update",12,Blue],{4.5,2.3}],Text[Style["Receive Event: max(pt, m.pt), ctr update",12,Blue],{4.5,1.3}]},PlotRange->{{0,10},{0,3}},ImageSize->600,Background->Lighter[Gray,0.95]];panel=Column[{Style["6.1 Back to Back Shannon Channels: Two Independent Metcalfe Channels",Bold,16],drawPipelineSlices[],Spacer[20],Style["6.1.2 & 6.1.3 Internal SACK Feedback Signals",Bold,16],Graphics[{drawSACKFeedback[txY,rxY,{8},"SACK8"]},ImageSize->600],Graphics[{drawSACKFeedback[txY,rxY,{1},"SACK1"]},ImageSize->600],Spacer[20],Style["6.2 Four Shannon-like Conceptual Layers",Bold,16],drawFourLayers[],Spacer[20],Style["6.3 Bidirectional Full-Duplex Shannon-Metcalfe Channel",Bold,16],drawBidirectionalChannel[],Spacer[20],Style["6.36 Hybrid Logical Clocks and Common Knowledge",Bold,16],drawHybridLogicalClock[],TextCell["Hybrid Logical Clocks combine physical time and logical counters to respect causality and maintain bounded skew \[CurlyEpsilon]. "<>"They enable \[CurlyEpsilon]-common knowledge, allowing consistent snapshots and linearizable commits with minimal coordination overhead.",FontSize->14,FontFamily->"Arial"]},Spacings->3];panel]


Module[{routerGraph,preferredPath,deflectedPath,pheromoneLevels,abpStates,abpPlot,forwardSignal,backwardSignal,tsfvPlot,hlcLocal,hlcMessage,hlcUpdate,hlcGrid},routerGraph=Graph[{1, 2, 3, 4, 5, 6, 7}, {UndirectedEdge[1, 2], UndirectedEdge[2, 3], UndirectedEdge[3, 4], UndirectedEdge[4, 5], UndirectedEdge[3, 6], UndirectedEdge[6, 7]}, {VertexLabels -> {"Name"}, VertexCoordinates -> {{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}, {2, -1}, {3, -1}}}];preferredPath={1,2,3,4,5};deflectedPath={1,2,3,6,7};pheromoneLevels=Association[1->0.5,2->0.7,3->0.9,4->0.3,5->0.1,6->0.6,7->0.8];Print[Graph[routerGraph,GraphHighlight->PathGraph[deflectedPath],GraphHighlightStyle->Directive[Red,Thick],PlotLabel->"Bufferless Deflection Routing with Forced Misrouting"]];abpStates=Mod[Range[0,20],2];abpPlot=ListLinePlot[abpStates,Filling->Bottom,PlotMarkers->Automatic,PlotRange->{0,1},AxesLabel->{"Time","ABP Bit State"},PlotLabel->"Alternating Bit Protocol State Evolution"];Print[abpPlot];forwardSignal=Accumulate[RandomReal[{0,1},20]];backwardSignal=Reverse[forwardSignal]+RandomReal[{-0.1,0.1},20];tsfvPlot=ListLinePlot[{forwardSignal,backwardSignal},PlotStyle->{Blue,Dashed},PlotLegends->{"|\[Psi](t)\:27e9 Forward Propagation","\:27e8\[Phi](t)| Backpropagation"},PlotLabel->"TSVF: Forward and Backward State Vectors",AxesLabel->{"Layer","Activation / Error"}];Print[tsfvPlot];hlcLocal={1000,3};hlcMessage={998,5};hlcUpdate=Module[{pt,ctr},pt=Max[hlcLocal[[1]],hlcMessage[[1]]];ctr=If[pt==hlcMessage[[1]],Max[hlcLocal[[2]],hlcMessage[[2]]]+1,0];{pt,ctr}];hlcGrid=Grid[{{"Local HLC",hlcLocal},{"Message HLC",hlcMessage},{"Updated HLC",hlcUpdate},{"Epistemic Note","Facts can become \[CurlyEpsilon]-common knowledge with bounded clock skew"}},Frame->All,ItemStyle->Directive[Bold,Medium]];Print[hlcGrid];]


Module[{n=6,k=5,rollbackAt=3,font=Directive[FontFamily->"Arial",FontSize->12],randInv,step,T,Tinv,v0,vStates,vRollback,reversiblePanel,braidGraphic,twoPhaseGraphic,composeGraphic,seqCircle,complexCounterPlot},randInv[d_]:=Module[{m},While[True,m=RandomInteger[{0,1},{d,d}];If[Mod[Det[m],2]==1,Return[m]]]];step[vec_,mat_]:=Mod[mat . vec,2];T=Table[randInv[n],{k}];Tinv=(Inverse[#1,Modulus->2]&)/@Reverse[T];v0=RandomInteger[{0,1},n];vStates=FoldList[step,v0,T];vRollback=Fold[step,vStates[[rollbackAt]],Take[Tinv,k-rollbackAt+1]];reversiblePanel=Grid[Prepend[Join[Table[{i-1,MatrixForm[vStates[[i]]]},{i,Length[vStates]}],{{"rollback",MatrixForm[vRollback]}}],{"Step","Vector State"}],Frame->All,ItemStyle->font];braidGraphic=Graphics[Join[Table[BezierCurve[{{i,0},{i+0.5,2},{i+1,0}}],{i,1,k}],Table[BezierCurve[{{k+i,0},{k+i-0.5,-2},{k+i-1,0}}],{i,1,k-rollbackAt+1}]],PlotRange->{{0,2 k},{-2.5,2.5}},ImageSize->Large];twoPhaseGraphic=Graphics[{EdgeForm[Black],FaceForm[Lighter[Green,0.6]],Rectangle[{0,0},{2,1}],Text["Phase 1:\nTentative",{1,0.5}],FaceForm[Lighter[Blue,0.6]],Rectangle[{2,0},{4,1}],Text["ACK \[RightArrow] Commit",{3,0.5}],FaceForm[Lighter[Red,0.6]],Rectangle[{4,0},{6,1}],Text["NACK \[RightArrow] Rollback",{5,0.5}]},ImageSize->400];composeGraphic=Graphics[{Text[Style["v\:2082 = T\:2082 T\:2081 v\:2080",font],{2,2}],Arrow[{{1,1},{3,1}}],Text[Style["Rollback:\nv\:2080 = T\:2081\:207b\.b9 T\:2082\:207b\.b9 v\:2082",font],{2,0.5}]},PlotRange->{{0,4},{0,2.5}},ImageSize->400];seqCircle=Graphics[{Circle[{0,0},1],Arrow[{{0.8,0.6},{-0.8,0.6}}],Text["T\:2081",{0,1.2}],Text["T\:2082",{-1.2,0}],Text["T\:2083",{0,-1.2}],Text["Cycle = I until Commit",{0,-1.5}]},PlotRange->{{-1.5,1.5},{-1.5,1.5}},ImageSize->250];complexCounterPlot=Graphics[Table[{Hue[i/10],Disk[{Cos[(2 \[Pi] i)/10],Sin[(2 \[Pi] i)/10]},0.1],Text[i,{1.2 Cos[(2 \[Pi] i)/10],1.2 Sin[(2 \[Pi] i)/10]}]},{i,0,9}],PlotRange->1.5,ImageSize->250];Column[{Style["5.21 Reversible Transactions over a Single Ethernet Link",Bold,18],Style["A. Linear Transform Pipeline over GF(2)",Bold,14],reversiblePanel,Style["B. Reversible Braid View",Bold,14],braidGraphic,Style["D. Two-Phase Commit Semantics",Bold,14],twoPhaseGraphic,Style["E. Composition and Inversion of Transactions",Bold,14],composeGraphic,Style["F. Homological Cycle Closure",Bold,14],seqCircle,Style["H. Sequence Number as Complex Modulo",Bold,14],complexCounterPlot}]]


Module[{sackLayersGraph,abpGraph},sackLayersGraph=With[{layers={"SACK 00\nInformation","SACK 01\nKnowledge","SACK 10\nSemantics","SACK 11\nUnderstanding"}},Graph[DirectedEdge@@@Partition[layers,2,1],VertexLabels->Placed["Name",Center],VertexSize->Medium,EdgeStyle->Directive[Darker[Green],Thick],PlotLabel->Style["Progressive SACK Layers",Bold,14],ImageSize->Large]];abpGraph=Module[{snake=Table[{Mod[i,8]+1,Quotient[i,8]+1},{i,0,23}]},Graph[DirectedEdge@@@Partition[snake,2,1],VertexSize->Small,EdgeStyle->Directive[Blue,Thick],PlotLabel->Style["Alternating-Bit Protocol \[Dash] snake path",Bold,14]]];GraphicsGrid[{{sackLayersGraph,abpGraph}},Spacings->{2,2}]]


Module[{fourLayersSACK,abpGraph},fourLayersSACK[]:=Module[{layers={{"Information  (SACK 00)",LightBlue},{"Knowledge    (SACK 01)",LightGreen},{"Semantics    (SACK 10)",LightOrange},{"Understanding(SACK 11)",Lighter[Red,.6]}},nSlices=8,h=1},Graphics[{Table[{EdgeForm[Black],FaceForm[layers[[i,2]]],Rectangle[{0.5,(i-1) h},{nSlices+0.5,i h}],Black,Text[Style[layers[[i,1]],Bold,14],{nSlices/2+0.5,(i-0.5) h}]},{i,Length[layers]}],Table[{Gray,Dashed,Line[{{x+0.5,0},{x+0.5,Length[layers] h}}],Black,Text[Style[x,11],{x,-.35}]},{x,nSlices}]},PlotRange->{{0,nSlices+1},{-.75,Length[layers] h+.4}},Frame->True,FrameTicks->None,ImageSize->Large,PlotLabel->Style["Four Shannon-like Layers with Partial-ACK (SACK) Boundaries",17,Bold]]];Column[{fourLayersSACK[]},Spacings->2]]


Module[{backToBackShannonChannels,fullDuplexShannonMetcalfe,datacenterTopologies,hybridLogicalClock,alternatingBitProtocol},backToBackShannonChannels[]:=Module[{txSlices={"TX Slice 1","TX Slice 2","TX Slice 3\[Dash]4","TX Slice 5\[Dash]8"},rxSlices={"RX Slice 1","RX Slice 2","RX Slice 3\[Dash]4","RX Slice 5\[Dash]8"},baseY=0,dx=1.5,n=4,arrows,feedbackSACK1,feedbackSACK8},arrows=Flatten[Table[{Blue,Arrowheads[0.04],Arrow[{{i dx,baseY+.3},{(i+.7) dx,baseY+.3}}],Text[Style[txSlices[[i]],Bold,14,Blue],{(i+.35) dx,baseY+.5}],Red,Arrowheads[0.04],Arrow[{{(i+.7) dx,baseY-.3},{i dx,baseY-.3}}],Text[Style[rxSlices[[i]],Bold,14,Red],{(i+.35) dx,baseY-.5}]},{i,n}]];feedbackSACK1={Darker[Green],Thick,Arrowheads[0.05],Arrow[{{1.35 dx,baseY+.6},{1.35 dx,baseY+1.2}}],Arrow[{{1.35 dx,baseY+1.2},{.65 dx,baseY+1.2}}],Arrow[{{.65 dx,baseY+1.2},{.65 dx,baseY+.6}}],Text[Style["SACK 1 Feedback",Bold,14,Darker[Green]],{1 dx,baseY+1.45}]};feedbackSACK8={Darker[Green],Thick,Arrowheads[0.05],Arrow[{{4.65 dx,baseY+.6},{4.65 dx,baseY+1.2}}],Arrow[{{4.65 dx,baseY+1.2},{3.35 dx,baseY+1.2}}],Arrow[{{3.35 dx,baseY+1.2},{3.35 dx,baseY+.6}}],Text[Style["SACK 8 Feedback",Bold,14,Darker[Green]],{4 dx,baseY+1.45}]};Graphics[{arrows,feedbackSACK1,feedbackSACK8,Black,Text[Style["ETHERNET TX",Bold,16],{0,baseY+.75}],Text[Style["ETHERNET RX",Bold,16],{0,baseY-.75}]},PlotRange->{{0,7 dx},{-1,2}},ImageSize->Large,Background->LightGray,Frame->True,FrameLabel->{"Channel Slices (Time Pipeline)",None},PlotLabel->Style["Back-to-Back Shannon Channels with SACK Feedback",18,Bold]]];fullDuplexShannonMetcalfe[]:=Module[{slices={"Slice 1","Slice 2","Slice 3-4","Slice 5-8"},n=4,dx=1.5,txPos,rxPos,arrows,texts},txPos=Table[{i dx,1},{i,n}];rxPos=Table[{i dx,-1},{i,n}];arrows=Flatten[Table[{Blue,Arrowheads[0.04],Arrow[{txPos[[i]],txPos[[i]]+{.7,0}}],Red,Arrowheads[0.04],Arrow[{rxPos[[i]]+{.7,0},rxPos[[i]]}]},{i,n}]];texts=Flatten[Table[{Text[Style["TX "<>slices[[i]],Bold,14,Blue],txPos[[i]]+{.35,.3}],Text[Style["RX "<>slices[[i]],Bold,14,Red],rxPos[[i]]-{.35,.3}]},{i,n}]];Graphics[{arrows,texts,Black,Text[Style["ETHERNET TX",Bold,16],{0,1.5}],Text[Style["ETHERNET RX",Bold,16],{0,-1.5}]},PlotRange->{{0,(n+1) dx},{-2,2}},ImageSize->Large,Background->LightGray,Frame->True,PlotLabel->Style["Bidirectional Full-Duplex Shannon\[Dash]Metcalfe Channel",18,Bold]]];datacenterTopologies[]:=Module[{centralized=StarGraph[7],decentralized=BlockRandom[RandomGraph[{12,18}]],distributed=BlockRandom[RandomGraph[{15,40}]],lab},lab[gr_,title_]:=Graph[gr,VertexLabels->Placed["Name",Center],GraphStyle->"NameLabeled",PlotLabel->Style[title,14,Bold],ImageSize->300];GraphicsGrid[{{lab[centralized,"Centralized Topology"],lab[decentralized,"Decentralized Topology"],lab[distributed,"Distributed Topology"]}},Spacings->{2,1}]];hybridLogicalClock[]:=Module[{events={"e1","e2","e3","e4","e5","e6"},pt={10,11,12,12,13,14},ctr={0,0,1,2,0,0},phys,logi},phys=Transpose[{Range[Length[events]],pt}];logi=Transpose[{Range[Length[events]],ctr}];ListLinePlot[{phys,logi},PlotMarkers->{"\[FilledCircle]","\[FilledSquare]"},PlotStyle->{Blue,Red},PlotLegends->{"Physical Time (pt)","Logical Counter (ctr)"},Frame->True,FrameLabel->{"Event Sequence","Value"},PlotLabel->Style["Hybrid Logical Clock \[LongDash] Event Evolution",18,Bold],ImageSize->Large]];alternatingBitProtocol[]:=Module[{graph},graph=Graph[{"0", "1"}, {DirectedEdge["0", "1"], DirectedEdge["1", "0"]}, {EdgeLabels -> {DirectedEdge["1", "0"] -> "Send 1", DirectedEdge["0", "1"] -> "Send 0"}, GraphStyle -> "NameLabeled", ImageSize -> Medium, PlotLabel -> Style["Alternating Bit Protocol (ABP) Simplified", 16, Bold], VertexLabels -> {"Name"}}];graph];Column[{backToBackShannonChannels[],Spacer[30],fullDuplexShannonMetcalfe[],Spacer[30],datacenterTopologies[],Spacer[30],hybridLogicalClock[],Spacer[30],alternatingBitProtocol[]}]]


Module[{deflectionGraph,deflectionPath,deflectionHighlight,abpStates,abpPlot,forwardSignal,backwardSignal,tsfvPlot,hlcLocal,hlcMessage,hlcUpdate,hlcGrid},deflectionGraph=Graph[{1, 2, 3, 4, 5, 6, 7}, {UndirectedEdge[1, 2], UndirectedEdge[2, 3], UndirectedEdge[3, 4], UndirectedEdge[4, 5], UndirectedEdge[3, 6], UndirectedEdge[6, 7]}, {GraphStyle -> "NameLabeled", VertexCoordinates -> {{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}, {2, -1}, {3, -1}}, VertexLabels -> {"Name"}}];deflectionPath={1,2,3,6,7};deflectionHighlight=HighlightGraph[deflectionGraph,PathGraph[deflectionPath],GraphHighlightStyle->Directive[Red,Thick]];abpStates=Table[Mod[i,2],{i,0,10}];abpPlot=ListLinePlot[abpStates,Filling->Axis,PlotMarkers->Automatic,PlotRange->{0,1},AxesLabel->{"Time (steps)","Alternating Bit"},PlotLabel->Style["Alternating Bit Protocol (ABP) State Evolution",Bold,14]];forwardSignal=Accumulate[RandomReal[{0,1},10]];backwardSignal=Reverse[forwardSignal]+RandomReal[{-0.1,0.1},10];tsfvPlot=ListLinePlot[{forwardSignal,backwardSignal},PlotStyle->{{Blue,Dashed},{Red}},PlotLegends->{"|\[Psi](t)\[RightAngleBracket]  Forward Propagation","\[LeftAngleBracket]\[Phi](t)|  Backpropagation"},AxesLabel->{"Layer","Activation / Error"},PlotLabel->Style["TSVF: Forward and Backward State Vectors",Bold,14]];hlcLocal={1000,3};hlcMessage={998,5};hlcUpdate=Module[{pt,ctr},pt=Max[hlcLocal[[1]],hlcMessage[[1]]];ctr=If[pt==hlcMessage[[1]],Max[hlcLocal[[2]],hlcMessage[[2]]]+1,0];{pt,ctr}];hlcGrid=Grid[{{"Local HLC",hlcLocal},{"Message HLC",hlcMessage},{"Updated HLC",hlcUpdate},{"\[CurlyEpsilon]-bound","Bounded clock skew ensures |pt\:2097\:2092c\:2090\:2097 \[Minus] pt\:2098\:2091\:209b\:209b| \[LessEqual] \[CurlyEpsilon]"}},Frame->All,ItemStyle->Directive[Bold,Medium]];Column[{Style["\[CapitalAE]thernet Chapter 6 Visualizations",20,Bold,Blue],Spacer[8],Style["6.10  Bufferless Deflection Routing",16,Bold],deflectionHighlight,Spacer[15],Style["6.11\[Dash]6.20  Alternating Bit Protocol (ABP)",16,Bold],abpPlot,Spacer[15],Style["6.21\[Dash]6.28  TSVF Forward / Backward Propagation",16,Bold],tsfvPlot,Spacer[15],Style["6.36  Hybrid Logical Clock (HLC) Update",16,Bold],hlcGrid},Spacings->2]]


Module[{nSlices=8,sliceLabels,txSlices,rxSlices,sackColors,sackLabels,layerColors,layerLabels,pipeGraph,sackGraph,topologyGraphs,antPath,beePath,hlcTimeline,drawPipeSlices,drawSackFeedback,drawFourLayers,drawBidirectionalChannels,drawANTBeeScouting,drawDatacenterTopologies,drawHybridLogicalClock},sliceLabels=Table["Slice "<>ToString[i],{i,nSlices}];sackColors={RGBColor[0.9,0.9,0.9],RGBColor[0.6,0.8,1],RGBColor[0.4,0.6,1],RGBColor[0.2,0.3,0.8]};sackLabels={"SACK 00 (Information)","SACK 01 (Knowledge)","SACK 10 (Semantics)","SACK 11 (Syntax)"};layerColors=sackColors;layerLabels=sackLabels;drawPipeSlices[]:=Module[{txPositions,rxPositions,txLines,rxLines,labels,pipelinePlot},txPositions=Table[{i,2},{i,nSlices}];rxPositions=Table[{i,0},{i,nSlices}];txLines=Line/@Partition[txPositions,2,1];rxLines=Line/@Partition[rxPositions,2,1];labels={Text[Style["ETHERNET TX",Bold,14],{nSlices+1,2}],Text[Style["ETHERNET RX",Bold,14],{nSlices+1,0}]};pipelinePlot=Graphics[{Blue,Thick,txLines,Red,Thick,rxLines,Black,Table[Text[Style["TX "<>sliceLabels[[i]],Blue,12,Italic],txPositions[[i]]+{0,0.2}],{i,nSlices}],Table[Text[Style["RX "<>sliceLabels[[i]],Red,12,Italic],rxPositions[[i]]-{0,0.3}],{i,nSlices}],labels},PlotRange->{{0,nSlices+2},{-1,3}},ImageSize->600,Axes->False];pipelinePlot];drawSackFeedback[pos_]:=Module[{txPos,rxPos,arrows,sackLabel,feedbackArrow},txPos={pos,2};rxPos={pos,0};sackLabel=If[pos==1,"SACK 1 (Feedback on Slice 1)","SACK 8 (Feedback on Slice 8)"];feedbackArrow=Style[Arrow[{rxPos,txPos}],Thick,Green];Graphics[{Blue,Disk[txPos,0.15],Text[Style["TX Slice "<>ToString[pos],Blue,12],txPos+{0,0.3}],Red,Disk[rxPos,0.15],Text[Style["RX Slice "<>ToString[pos],Red,12],rxPos-{0,0.4}],feedbackArrow,Black,Text[Style[sackLabel,Bold,14],{pos,2.5}]},PlotRange->{{pos-1,pos+1},{-1,3}},ImageSize->300,Axes->False]];drawFourLayers[]:=Module[{layerBoxes,yBase=0,nLayers=4,width=6,height=1.2,graphicsObjects={}},layerBoxes=Table[{layerColors[[i]],Rectangle[{0,yBase+(i-1) height},{width,yBase+i height}],Black,Text[Style[layerLabels[[i]],Bold,14],{width/2,yBase+(i-0.5) height}]},{i,nLayers}];Graphics[layerBoxes,PlotRange->{{-1,width+1},{yBase-1,yBase+nLayers height+1}},ImageSize->500,Axes->False]];drawBidirectionalChannels[]:=Module[{txY=3,rxY=0,sliceXPositions=Range[1,nSlices],sackPositions={1,3,5,7},graphicsObjects={},arrows={},labels={}},graphicsObjects=Join[Table[{Blue,Rectangle[{x-0.4,txY-0.4},{x+0.4,txY+0.4}],Black,Text[Style["TX "<>ToString[x],White,12],{x,txY}]},{x,nSlices}],Table[{Red,Rectangle[{x-0.4,rxY-0.4},{x+0.4,rxY+0.4}],Black,Text[Style["RX "<>ToString[x],White,12],{x,rxY}]},{x,nSlices}],Table[{Green,Arrow[{{x,txY-0.4},{x,rxY+0.4}}],Black,Text[Style["SACK "<>IntegerString[Floor[(x+1)/2],2,2],Bold,12],{x,(txY+rxY)/2}]},{x,sackPositions}]];Graphics[graphicsObjects,PlotRange->{{0,nSlices+1},{-1,txY+1}},ImageSize->700,Axes->False]];drawANTBeeScouting[]:=Module[{gridSize=7,gridPoints,antPathPoints,beePathPoints,antPathGraphics,beePathGraphics,antColor=Orange,beeColor=Purple},gridPoints=Flatten[Table[{x,y},{x,1,gridSize},{y,1,gridSize}],1];antPathPoints={{4,4},{5,4},{5,5},{6,5},{6,6}};beePathPoints={{1,1},{1,2},{1,3},{1,4},{1,5},{1,6},{1,7}};antPathGraphics={antColor,Thick,Arrow[antPathPoints]};beePathGraphics={beeColor,Thick,Arrow[beePathPoints]};Graphics[{LightGray,PointSize[Large],Point[gridPoints],antPathGraphics,beePathGraphics,Black,Text[Style["ANT Scout Path",antColor,Bold],{5,6.5}],Text[Style["BEE Scout Path",beeColor,Bold],{1,7.5}]},PlotRange->{{0,gridSize+1},{0,gridSize+2}},Frame->True,ImageSize->400]];drawDatacenterTopologies[]:=Module[{centralized,decentralized,distributed,g1,g2,g3,styleCentralized,styleDecentralized,styleDistributed},g1=Graph[StarGraph[10],VertexLabels->"Name",GraphStyle->"NameLabeled",ImageSize->250];g2=Graph[{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, {UndirectedEdge[1, 2], UndirectedEdge[1, 3], UndirectedEdge[1, 4], UndirectedEdge[5, 6], UndirectedEdge[5, 7], UndirectedEdge[8, 9], UndirectedEdge[8, 10], UndirectedEdge[1, 5], UndirectedEdge[5, 8]}, {ImageSize -> 300, VertexLabels -> {"Name"}}];g3=GridGraph[{4,4},VertexLabels->"Name",ImageSize->350];Grid[{{Style["Centralized Topology (Single Hub)",Bold,14],Style["Decentralized Topology (Multiple Hubs)",Bold,14],Style["Distributed Topology (Mesh)",Bold,14]},{g1,g2,g3}},Spacings->{3,2}]];drawHybridLogicalClock[]:=Module[{events={{1,0,"e1 (local event)"},{2,0,"e2 (local event)"},{3,1,"e3 (message receive)"},{4,0,"e4 (local event)"}},hlcGraphics},hlcGraphics=Graphics[{Blue,PointSize[Large],(Point[{#1[[1]],#1[[2]]}]&)/@events,Black,Table[Text[Style[events[[i,3]],Italic,12],events[[i,{1,2}]]+{0,0.3}],{i,Length[events]}],Red,Arrow[{{1,0},{2,0}}],Arrow[{{2,0},{3,1}}],Arrow[{{3,1},{4,0}}]},PlotRange->{{0,5},{-0.5,2}},Axes->True,AxesLabel->{"Physical Time (pt)","Counter (ctr)"},ImageSize->400];hlcGraphics];Grid[{{Style["1. Two Independent Metcalfe Channels",Bold,16]},{drawPipeSlices[]},{Style["2. SACK Feedback on First and Last Slice",Bold,16]},{Row[{drawSackFeedback[1],Spacer[50],drawSackFeedback[8]}]},{Style["3. Four Shannon-like Layers",Bold,16]},{drawFourLayers[]},{Style["4. Bidirectional Full-Duplex Shannon-Metcalfe Channel",Bold,16]},{drawBidirectionalChannels[]},{Style["5. ANT and BEE Scout Routing on 2D Grid",Bold,16]},{drawANTBeeScouting[]},{Style["6. Datacenter Topologies",Bold,16]},{drawDatacenterTopologies[]},{Style["7. Hybrid Logical Clock (HLC) Timeline",Bold,16]},{drawHybridLogicalClock[]}},Spacings->{0,3},Alignment->Center]]


Module[{fullDuplexShannonMetcalfe,antBeeScouting,datacenterTopologies,hybridLogicalClockTimeline},fullDuplexShannonMetcalfe[]:=Module[{nSlices=4,dx=1.5,txY=1,rxY=-1,txLabels={"TX Slice 1","TX Slice 2","TX Slice 3-4","TX Slice 5-8"},rxLabels={"RX Slice 1","RX Slice 2","RX Slice 3-4","RX Slice 5-8"},arrows={},texts={}},arrows=Flatten[Table[{Blue,Arrowheads[0.04],Arrow[{{(i-1) dx,txY},{(i-1) dx+0.9 dx,txY}}],Red,Arrowheads[0.04],Arrow[{{(i-1) dx+0.9 dx,rxY},{(i-1) dx,rxY}}]},{i,nSlices}]];texts=Flatten[Table[{Text[Style[txLabels[[i]],Blue,Bold,14],{(i-0.5) dx,txY+0.3}],Text[Style[rxLabels[[i]],Red,Bold,14],{(i-0.5) dx,rxY-0.3}]},{i,nSlices}]];Graphics[{arrows,texts,Black,Text[Style["ETHERNET TX",Bold,16],{-0.5,txY}],Text[Style["ETHERNET RX",Bold,16],{-0.5,rxY}]},PlotRange->{{-1,nSlices dx},{rxY-1,txY+1}},ImageSize->700,Background->LightGray,Frame->True,PlotLabel->Style["Bidirectional Full-Duplex Shannon-Metcalfe Channel",18,Bold]]];antBeeScouting[]:=Module[{g=GridGraph[{5,5}],coords,antPath,beePath,antColor=Blue,beeColor=Red,arrowsStyle=Directive[Thick,Arrowheads[0.04]]},coords=AssociationThread[VertexList[g],Table[{Mod[i-1,5]+1,Quotient[i-1,5]+1},{i,VertexCount[g]}]];antPath={{3,3},{3,4},{4,4},{4,3},{4,2},{3,2},{2,2},{2,3},{2,4}};beePath=Table[{i,1},{i,1,5}];Show[Graph[g,VertexCoordinates->coords,VertexSize->Medium,VertexLabels->None,ImageSize->500],Graphics[{antColor,arrowsStyle,Arrow[antPath],beeColor,arrowsStyle,Arrow[beePath]}],PlotLabel->Style["ANT (Blue) and BEE (Red) Scouting Paths on 5x5 Grid",18,Bold]]];datacenterTopologies[]:=Module[{centralized=StarGraph[7],decentralized=RandomGraph[{12,18},DirectedEdges->False],distributed=RandomGraph[{15,40},DirectedEdges->False],labelFunc,graphGrid},labelFunc[g_]:=Thread[VertexList[g]->Table["N"<>ToString[i],{i,VertexCount[g]}]];graphGrid=GraphicsGrid[{{Graph[centralized,VertexLabels->labelFunc[centralized],GraphStyle->"NameLabeled",PlotLabel->Style["Centralized Topology",14,Bold],ImageSize->300],Graph[decentralized,VertexLabels->labelFunc[decentralized],GraphStyle->"NameLabeled",PlotLabel->Style["Decentralized Topology",14,Bold],ImageSize->300],Graph[distributed,VertexLabels->labelFunc[distributed],GraphStyle->"NameLabeled",PlotLabel->Style["Distributed Topology",14,Bold],ImageSize->300]}},Spacings->{3,2}];graphGrid];hybridLogicalClockTimeline[]:=Module[{events={"e1","e2","e3","e4","e5","e6"},pt={10,11,12,12,13,14},ctr={0,0,1,2,0,0},physData,logicData},physData=Transpose[{Range[Length[events]],pt}];logicData=Transpose[{Range[Length[events]],ctr}];ListLinePlot[{physData,logicData},PlotMarkers->{Graphics[{Blue,Disk[]}],Graphics[{Red,Rectangle[]}],None},PlotStyle->{Blue,Red},PlotLegends->Placed[{"Physical Time (pt)","Logical Counter (ctr)"},Above],Frame->True,FrameLabel->{"Event Index","Value"},PlotLabel->Style["Hybrid Logical Clock Event Evolution",18,Bold],ImageSize->700]];Column[{fullDuplexShannonMetcalfe[],Spacer[30],antBeeScouting[],Spacer[30],datacenterTopologies[],Spacer[30],hybridLogicalClockTimeline[]}]]


Module[{slices=Range[8],txColor=RGBColor[0.2,0.4,0.8],rxColor=RGBColor[0.1,0.7,0.3],sackColors={RGBColor[0.3,0.5,0.9],RGBColor[0.3,0.7,0.4],RGBColor[0.9,0.5,0.2],RGBColor[0.9,0.3,0.3]},sackLabels={"00","01","10","11"},sackMeaning={"Information","Knowledge","Semantics","Syntax"},antPathCW,antPathCCW,beeOutbound,beeReturn,centralGraph,decentralGraph,distributedGraph,hlcEvents,hlcPlot},metcalfePlot=Graphics[{Table[{txColor,Rectangle[{i,3},{i+0.8,4}],Black,Text["TX Slice "<>ToString[i],{i+0.4,3.5}]},{i,slices}],Table[{rxColor,Rectangle[{i,1},{i+0.8,2}],Black,Text["RX Slice "<>ToString[i],{i+0.4,1.5}]},{i,slices}],Style[Text["6.1.1 Two Independent Metcalfe Channels (Max Flow, No Interaction)",{4.5,4.5}],Bold,14]},PlotRange->{{0.5,9},{0.5,4.5}},ImageSize->600];sackFeedbackPlot[n_]:=Graphics[{Table[{txColor,Rectangle[{i,3},{i+0.8,4}],Black,Text["TX Slice "<>ToString[i],{i+0.4,3.5}]},{i,slices}],Table[{rxColor,Rectangle[{i,1},{i+0.8,2}],Black,Text["RX Slice "<>ToString[i],{i+0.4,1.5}]},{i,slices}],{Red,Thick,Arrow[{{n+0.4,4.2},{n+0.4,4.8}}]},{Red,Style[Text["SACK"<>ToString[n],{n+0.4,5}],Bold,14]},Style[Text["6.1.2/6.1.3 Internal (SACK) Feedback on slice "<>ToString[n],{4.5,5.5}],Bold,14]},PlotRange->{{0.5,9},{0.5,6}},ImageSize->600];fourLevelsPlot=Graphics[{Table[{sackColors[[i]],Rectangle[{0,i-1},{4,i}],Black,Style[Text[sackMeaning[[i]]<>" (SACK "<>sackLabels[[i]]<>")",{2,i-0.5}],Bold,14]},{i,4}],Style[Text["6.2 Architectural Framework: Four Shannon-like Levels",{2,4.5}],Bold,14]},PlotRange->{{0,4},{0,4}},ImageSize->400,Axes->False];fullDuplexPlot=Graphics[{Table[{txColor,Rectangle[{i,4},{i+0.8,5}],Black,Text["TX Slice "<>ToString[i],{i+0.4,4.5}]},{i,slices}],Table[{rxColor,Rectangle[{i,1},{i+0.8,2}],Black,Text["RX Slice "<>ToString[i],{i+0.4,1.5}]},{i,slices}],Table[{Purple,Arrowheads[0.03],Arrow[{{i+0.4,4},{i+0.4,2}}]},{i,slices}],Table[Style[Text["SACK "<>sackLabels[[i]],{i 2-0.6,If[i<=2,5.4,0.8]}],Bold,12],{i,4}],Style[Text["6.3 Full-Duplex Bi-Pipelined Shannon-Metcalfe Channel",{4.5,6}],Bold,14]},PlotRange->{{0.5,8.5},{0.5,6}},ImageSize->700];antGridSize=3;antPoints=Flatten[Table[{x,y},{x,1,antGridSize},{y,1,antGridSize}],1];antEdgesCW={{1,2},{2,3},{3,6},{6,9},{9,8},{8,7},{7,4},{4,1}};antEdgesCCW=Reverse[antEdgesCW];antClockwise=Graph[UndirectedEdge@@@antEdgesCW,VertexCoordinates->antPoints,VertexSize->Medium,EdgeStyle->Blue,GraphStyle->"NameLabeled"];antCounterClockwise=Graph[UndirectedEdge@@@antEdgesCCW,VertexCoordinates->antPoints,VertexSize->Medium,EdgeStyle->Red,GraphStyle->"NameLabeled"];beeLength=6;beeOutboundPath=Table[{i,1},{i,1,beeLength}];beeReturnPath=Reverse[beeOutboundPath];beePlot=Graphics[{Blue,Thick,Arrow[beeOutboundPath],Red,Thick,Arrow[beeReturnPath],Black,PointSize[Large],Point/@beeOutboundPath,Style[Text["Outbound",{beeLength+0.5,1}],Blue,Bold],Style[Text["Return",{0.5,1}],Red,Bold],Style[Text["6.9 BEE Scouts: Radial Exploration & Return",{beeLength/2,1.5}],Bold,14]},PlotRange->{{0,beeLength+1},{0.5,1.8}},ImageSize->600];centralGraph=Graph[Table[i->0,{i,1,46}],VertexLabels->"Name",GraphLayout->"StarEmbedding",PlotLabel->"6.31 Centralized Topology"];decentralGraph=RandomGraph[{47,60},GraphLayout->"SpringElectricalEmbedding",PlotLabel->"6.31 Decentralized Topology"];distributedGraph=RandomGraph[{47,98},GraphLayout->"SpringElectricalEmbedding",PlotLabel->"6.31 Distributed Topology"];SeedRandom[1234];hlcEvents=Table[{i,RandomReal[{i 5,i 5+2}],RandomInteger[{0,2}]},{i,1,20}];hlcPlot=ListPlot[hlcEvents[[All,{1,2}]],PlotStyle->PointSize[Medium],AxesLabel->{"Event Index","HLC Physical Time"},PlotLabel->"6.36 Hybrid Logical Clock: Event Timestamps",ImageSize->600];Column[{metcalfePlot,sackFeedbackPlot[8],sackFeedbackPlot[1],fourLevelsPlot,fullDuplexPlot,GraphicsGrid[{{antClockwise,antCounterClockwise}},ImageSize->600,Spacings->{2,2}],beePlot,GraphicsRow[{centralGraph,decentralGraph,distributedGraph},ImageSize->800],hlcPlot},Spacings->3]]


Module[{nSlices=8,sliceSize=8,sackBits={"00","01","10","11"},sackColors,layers,pipeHeight=1.2,pipeWidth=10,arrowOpts={Arrowheads[0.03],Thick},txY=3,rxY=1,centralGraph,decentralGraph,distribGraph,centralPlot,decentralPlot,distribPlot,now=AbsoluteTime[],epsilon=0.05,hlcPt,hlcCtr,hlcEventGraphics,snakeLen=16,snakePts,tsvfGrid,infoColor,knowledgeColor,semanticsColor,syntaxColor},sackColors=ColorData[97,"ColorList"][[{1,3,5,7}]];{infoColor,knowledgeColor,semanticsColor,syntaxColor}=sackColors;layers={"Layer 1: Information (Surprisal)","Layer 2: Knowledge (Captured Information)","Layer 3: Semantics (Meaning)","Layer 4: Understanding (Syntax)"};Print[Module[{gridSize=7,nodeCoords,ants,bees,antColor,beeColor},nodeCoords=Flatten[Table[{x,y},{x,1,gridSize},{y,1,gridSize}],1];antColor=RGBColor[0.1,0.7,0.1];beeColor=RGBColor[0.8,0.5,0];ants=Table[{antColor,Circle[nodeCoords[[i]],0.15],Arrowheads[0.03],Arrow[{nodeCoords[[i]],nodeCoords[[i]]+{0.5,0.5}}]},{i,1,5}];bees=Table[{beeColor,Circle[nodeCoords[[i+10]],0.15],Arrowheads[0.03],Arrow[{nodeCoords[[i+10]],nodeCoords[[i+10]]+{1,0}}]},{i,1,5}];Graphics[{Table[({LightGray,PointSize[0.015],Point[#1]}&)/@nodeCoords],ants,bees,Style[Text["ANT Scouts (Local Exploration)"],{1,gridSize+1},Bold,14,antColor],Style[Text["BEE Scouts (Long-Range Radial)"],{gridSize-2,gridSize+1},Bold,14,beeColor]},PlotRange->{{0,gridSize+2},{0,gridSize+2}},ImageSize->500,Axes->True]]];snakePts=Table[{i,Sin[(\[Pi] i)/2]},{i,0,snakeLen}];Print[Graphics[{Thick,Blue,Line[snakePts],Red,PointSize[Large],Point[snakePts[[1;;All;;2]]],Black,Table[Text[Style[If[EvenQ[i],"0","1"],Bold,14],snakePts[[i+1]]+{0,0.2}],{i,0,snakeLen}],Style[Text["Alternating Bit Protocol Snake"],{snakeLen/2,1.2},Bold,16]},ImageSize->600,PlotRange->{{0,snakeLen},{-1.5,1.5}}]];tsvfGrid=Grid[{{"Concept","Neural Network","TSVF Quantum Mechanics"},{"Initial Input",Style["x",Blue],Style["|\[Psi](t\:2080)\:27e9",Purple]},{"Forward Process",Style["a^{(l+1)} = f(W^{(l)} a^{(l)} + b^{(l)})",Blue],Style["|\[Psi](t)\:27e9 = U(t, t\:2080)|\[Psi](t\:2080)\:27e9",Purple]},{"Target Supervision",Style["Loss function",Blue],Style["Post-selection \:27e8\[Phi](t\:2081)|",Purple]},{"Backward Signal",Style["\[Delta]^{(l)}",Blue],Style["\:27e8\[Phi](t)|",Purple]},{"Weight Update",Style["\[CapitalDelta]W^{(l)} \[Proportional] \[Delta]^{(l)}(a^{(l-1)})^T",Blue],Style["\:27e8\[Phi]|A|\[Psi]\:27e9",Purple]}},Frame->All,Background->{None,{Lighter[Blue,0.85],Lighter[Purple,0.85]}},Alignment->Center];Print[Style["6.21 TSVF and Learning Comparison Table",Bold,16]];Print[tsvfGrid];centralGraph=Graph[StarGraph[7],VertexLabels->"Name",GraphStyle->"NameLabeled"];decentralGraph=Graph[GraphUnion[CycleGraph[5],PathGraph[{6,7}]],VertexLabels->"Name",GraphStyle->"NameLabeled"];distribGraph=RandomGraph[{10,15},VertexLabels->"Name"];centralPlot=GraphPlot[centralGraph,VertexLabeling->True,PlotLabel->"Centralized Topology"];decentralPlot=GraphPlot[decentralGraph,VertexLabeling->True,PlotLabel->"Decentralized Topology"];distribPlot=GraphPlot[distribGraph,VertexLabeling->True,PlotLabel->"Distributed Topology"];Print[GraphicsRow[{GraphPlot[centralGraph,VertexLabels->"Name",PlotLabel->"Centralized Topology"],GraphPlot[decentralGraph,VertexLabels->"Name",PlotLabel->"Decentralized Topology"],GraphPlot[distribGraph,VertexLabels->"Name",PlotLabel->"Distributed Topology"]},ImageSize->Large]];hlcPt=now;hlcCtr=0;hlcEventGraphics=Graphics[{Style[Text["Hybrid Logical Clock",{0,1}],Bold,16],Style[Text[StringForm["HLC = (pt = ``, ctr = ``)", DateString[hlcPt, {"Hour", ":", "Minute", ":", "Second"}], hlcCtr],{0,0.5}],14],Blue,Disk[{0,0},0.1],Red,Disk[{epsilon,0},0.1],Black,Arrow[{{0,0},{epsilon,0}}],Style[Text["\[CurlyEpsilon] (skew bound)",{epsilon/2,-0.2}],Italic,12]},PlotRange->{{-0.5,1.5},{-0.5,1.5}},ImageSize->400];Print[hlcEventGraphics];Print[Style["Chapter 6: \[CapitalAE]thernet Architecture - Mathematica Visualizations",Bold,20,Blue]];]


Module[{nSlices=8,txY=3,rxY=1,sliceWidth=0.9,sliceHeight=0.8,sackColors,layers,antColor,beeColor,gridSize=7,centralGraph,decentralGraph,distribGraph,now=AbsoluteTime[],epsilon=0.05,hlcPt,hlcCtr,tsvfTable},sackColors=(ColorData["DarkRainbow"][#1]&)/@{0.15,0.4,0.7,0.9};layers={"Layer 1: Information (Surprisal)","Layer 2: Knowledge (Captured Information)","Layer 3: Semantics (Meaning)","Layer 4: Understanding (Syntax)"};antColor=RGBColor[0.1,0.7,0.1];beeColor=RGBColor[0.8,0.5,0.1];Module[{nodeCoords,ants,bees},nodeCoords=Flatten[Table[{x,y},{x,1,gridSize},{y,1,gridSize}],1];ants=Table[{antColor,Circle[nodeCoords[[i]],0.15],Arrowheads[0.03],Arrow[{nodeCoords[[i]],nodeCoords[[i]]+{0.6,0.6}}]},{i,1,5}];bees=Table[{beeColor,Circle[nodeCoords[[i+10]],0.15],Arrowheads[0.03],Arrow[{nodeCoords[[i+10]],nodeCoords[[i+10]]+{1.2,0}}]},{i,1,5}];Print[Graphics[{Table[({LightGray,PointSize[0.015],Point[#1]}&)/@nodeCoords],ants,bees,Style[Text["ANT Scouts (Local Exploration)"],{1,gridSize+1},Bold,14,antColor],Style[Text["BEE Scouts (Long-Range Radial)"],{gridSize-2,gridSize+1},Bold,14,beeColor]},PlotRange->{{0,gridSize+3},{0,gridSize+3}},ImageSize->600,Axes->True,AxesOrigin->{0,0}]];];Module[{snakeLen=16,snakePts},snakePts=Table[{i,Sin[(\[Pi] i)/2]},{i,0,snakeLen}];Print[Graphics[{Thick,Blue,Line[snakePts],Red,PointSize[Large],Point[snakePts[[1;;All;;2]]],Black,Table[Text[Style[If[EvenQ[i],"0","1"],Bold,14],snakePts[[i+1]]+{0,0.3}],{i,0,snakeLen}],Style[Text["Alternating Bit Protocol Snake"],{snakeLen/2,1.4},Bold,16]},ImageSize->600,PlotRange->{{0,snakeLen},{-1.5,1.5}}]];];tsvfTable=Grid[{{"Concept","Neural Network","TSVF Quantum Mechanics"},{"Initial Input",Style["x",Blue],Style["|\[Psi](t\:2080)\:27e9",Purple]},{"Forward Process",Style["a^{(l+1)} = f(W^{(l)} a^{(l)} + b^{(l)})",Blue],Style["|\[Psi](t)\:27e9 = U(t, t\:2080)|\[Psi](t\:2080)\:27e9",Purple]},{"Target Supervision",Style["Loss function",Blue],Style["Post-selection \:27e8\[Phi](t\:2081)|",Purple]},{"Backward Signal",Style["\[Delta]^{(l)}",Blue],Style["\:27e8\[Phi](t)|",Purple]},{"Weight Update",Style["\[CapitalDelta]W^{(l)} \[Proportional] \[Delta]^{(l)}(a^{(l-1)})^T",Blue],Style["\:27e8\[Phi]|A|\[Psi]\:27e9",Purple]}},Frame->All,Background->{None,{Lighter[Blue,0.85],Lighter[Purple,0.85]}},Alignment->Center];Print[Style["6.21 TSVF and Learning Comparison Table",Bold,16]];Print[tsvfTable];centralGraph=StarGraph[7];decentralGraph=Graph[UndirectedEdge@@@{{1,2},{2,3},{3,4},{4,5},{2,6},{2,7}},VertexLabels->"Name"];distribGraph=RandomGraph[{10,15},VertexLabels->"Name"];Print[GraphicsRow[{Graph[centralGraph,VertexLabels->"Name",PlotLabel->"Centralized Topology"],(Graph[#1,VertexLabels->"Name",PlotLabel->"Decentralized Topology"]&)[decentralGraph],(Graph[#1,VertexLabels->"Name",PlotLabel->"Distributed Topology"]&)[distribGraph]},ImageSize->Large]];hlcPt=now;hlcCtr=0;Print[Graphics[{Style[Text["Hybrid Logical Clock (HLC) Representation",{0,1}],Bold,16],Style[Text[StringForm["HLC = (pt = ``, ctr = ``)", DateString[hlcPt, {"Hour", ":", "Minute", ":", "Second"}], hlcCtr],{0,0.5}],14],Blue,Disk[{0,0},0.1],Red,Disk[{epsilon,0},0.1],Black,Arrow[{{0,0},{epsilon,0}}],Style[Text["\[CurlyEpsilon] (max clock skew)",{epsilon/2,-0.3}],Italic,12]},PlotRange->{{-0.5,1.5},{-0.5,1.5}},ImageSize->400]];Print[Style["Chapter 6: \[CapitalAE]thernet Architecture - Mathematica Visualizations Complete",Bold,20,Darker[Green]]];]


Module[{slices=Range[8],txColor=Lighter[Blue,0.3],rxColor=Lighter[Green,0.3],sackColor=Orange,sackLevels={{"Information (SACK 00)",Blue},{"Knowledge (SACK 01)",Green},{"Semantics (SACK 10)",Purple},{"Syntax (SACK 11)",Red}},fullDuplexSlices=Range[8],antGridSize=3,antEdgesCW,antEdgesCCW,beeLength=6,centralGraph,decentralGraph,distributedGraph,hlcEvents,ternaryStates={-1,0,1},abpStates,forwardState,backwardState,layerCount=5,i},metcalfePlot=Graphics[{Style[Text["6.1 Two Independent Metcalfe Channels",{4.5,5}],Bold,16],Table[{txColor,Rectangle[{i,3.5},{i+0.8,4.5}],Black,Text[Style["TX Slice "<>ToString[i],Bold,12],{i+0.4,4}]},{i,slices}],Table[{rxColor,Rectangle[{i,1.5},{i+0.8,2.5}],Black,Text[Style["RX Slice "<>ToString[i],Bold,12],{i+0.4,2}]},{i,slices}],Style[Text["Transmit Pipeline",{0.5,4.8}],Italic,14,Blue],Style[Text["Receive Pipeline",{0.5,2.8}],Italic,14,Green]},PlotRange->{{0.5,8.5},{1,5}},ImageSize->600,Axes->False];sackFeedbackPlot[n_]:=Graphics[{Style[Text["6.1 Internal (SACK) Feedback on Slice "<>ToString[n],{4.5,5}],Bold,16],Table[{txColor,Rectangle[{i,3.5},{i+0.8,4.5}],Black,Text["TX Slice "<>ToString[i],{i+0.4,4}]},{i,slices}],Table[{rxColor,Rectangle[{i,1.5},{i+0.8,2.5}],Black,Text["RX Slice "<>ToString[i],{i+0.4,2}]},{i,slices}],{Red,Thick,Arrowheads[0.03],Arrow[{{n+0.4,4.5},{n+0.4,5.5}}]},{Red,Style[Text["SACK"<>ToString[n],{n+0.4,6}],Bold,16]}},PlotRange->{{0.5,8.5},{1,6.5}},ImageSize->600,Axes->False];fourLevelsPlot=Graphics[{Style[Text["6.2 Architectural Framework: Four Shannon-like Levels",{2.5,5}],Bold,16],Table[{sackLevels[[i,2]],Rectangle[{0,i-1},{5,i}],Black,Text[Style[sackLevels[[i,1]],Bold,14],{2.5,i-0.5}]},{i,Length[sackLevels]}]},PlotRange->{{0,5},{0,4}},ImageSize->400,Axes->False];fullDuplexPlot=Graphics[{Style[Text["6.3 Full-Duplex Bi-pipelined Shannon-Metcalfe Channel",{4.5,6}],Bold,16],Table[{txColor,Rectangle[{i,4},{i+0.8,5}],Black,Text["TX Slice "<>ToString[i],{i+0.4,4.5}]},{i,fullDuplexSlices}],Table[{rxColor,Rectangle[{i,1},{i+0.8,2}],Black,Text["RX Slice "<>ToString[i],{i+0.4,1.5}]},{i,fullDuplexSlices}],Table[{Purple,Arrowheads[0.03],Arrow[{{i+0.4,4},{i+0.4,2}}]},{i,fullDuplexSlices}],Style[Text["SACK 00",{1.2,5.4}],Bold,12],Style[Text["SACK 01",{3.6,5.4}],Bold,12],Style[Text["SACK 10",{5.4,5.4}],Bold,12],Style[Text["SACK 11",{7.6,5.4}],Bold,12],Style[Text["SACK 11",{7.6,0.6}],Bold,12],Style[Text["SACK 10",{5.4,0.6}],Bold,12],Style[Text["SACK 01",{3.6,0.6}],Bold,12],Style[Text["SACK 00",{1.2,0.6}],Bold,12]},PlotRange->{{0.5,8.5},{0.5,6}},ImageSize->700,Axes->False];antGridPoints=Flatten[Table[{x,y},{x,1,antGridSize},{y,1,antGridSize}],1];antEdgesCW=UndirectedEdge@@@{{1,2},{2,3},{3,6},{6,9},{9,8},{8,7},{7,4},{4,1}};antEdgesCCW=Reverse[antEdgesCW];antClockwiseGraph=Graph[antEdgesCW,VertexCoordinates->antGridPoints,VertexLabels->"Name",EdgeStyle->Blue,GraphStyle->"NameLabeled",PlotLabel->"ANT Clockwise Packet Clock"];antCounterClockwiseGraph=Graph[antEdgesCCW,VertexCoordinates->antGridPoints,VertexLabels->"Name",EdgeStyle->Red,GraphStyle->"NameLabeled",PlotLabel->"ANT Counterclockwise Packet Clock"];beeOutboundPath=Table[{i,1},{i,1,beeLength}];beeReturnPath=Reverse[beeOutboundPath];beePlot=Graphics[{Blue,Thick,Arrow[beeOutboundPath],Red,Thick,Arrow[beeReturnPath],Black,PointSize[Large],Point/@beeOutboundPath,Style[Text["Outbound",{beeLength+0.5,1}],Blue,Bold],Style[Text["Return",{0.5,1}],Red,Bold],Style[Text["6.9 BEE Scouts: Radial Exploration and Return",{beeLength/2,1.5}],Bold,14]},PlotRange->{{0,beeLength+1},{0.5,1.8}},ImageSize->600];centralGraph=Graph[Table[i->0,{i,1,46}],VertexLabels->"Name",GraphLayout->"StarEmbedding",PlotLabel->"Centralized Topology"];decentralGraph=RandomGraph[{47,60},GraphLayout->"SpringElectricalEmbedding",PlotLabel->"Decentralized Topology"];distributedGraph=RandomGraph[{47,98},GraphLayout->"SpringElectricalEmbedding",PlotLabel->"Distributed Topology"];SeedRandom[1234];hlcEvents=Table[{i,RandomReal[{i 5,i 5+2}],RandomInteger[{0,2}]},{i,1,20}];hlcPlot=ListPlot[hlcEvents[[All,{1,2}]],PlotStyle->{PointSize[Medium],Blue},AxesLabel->{"Event Index","HLC Physical Time"},PlotLabel->"6.36 Hybrid Logical Clock: Event Timestamps",ImageSize->600];abpStates={Style["00",Blue],Style["01",Green],Style["11",Red],Style["10",Purple]};abpGraph=Graph[DirectedEdge@@@{{1,2},{2,3},{3,4},{4,3}},VertexLabels->{1->abpStates[[1]],2->abpStates[[2]],3->abpStates[[3]],4->abpStates[[4]]},GraphStyle->"NameLabeled",PlotLabel->"Alternating Bit Protocol (ABP) State Transitions",VertexSize->Large];Column[{metcalfePlot,sackFeedbackPlot[8],sackFeedbackPlot[1],fourLevelsPlot,fullDuplexPlot,GraphicsGrid[{{antClockwiseGraph,antCounterClockwiseGraph}}],beePlot,GraphicsRow[{centralGraph,decentralGraph,distributedGraph},ImageSize->800],hlcPlot,abpGraph},Spacings->3]]


ClearAll[LabeledDigraph];
Options[LabeledDigraph]={VertexPositions->{},VertexSize->Medium,EdgeStyle->Black,PlotLabel->None};
LabeledDigraph[edges_,labels_,opts:OptionsPattern[]]:=Module[{pos=OptionValue[VertexPositions],vs=OptionValue[VertexSize],es=OptionValue[EdgeStyle],pl=OptionValue[PlotLabel],verts},verts=VertexList[Graph[edges]];Graph[edges,VertexLabels->Thread[verts->Placed[labels,Center]],VertexCoordinates->pos,VertexSize->vs,EdgeStyle->es,DirectedEdges->True,PlotLabel->pl,ImagePadding->20]];
metcalfeSlices={"SLICE 1","SLICE 2","SLICE 3-4","SLICE 5-8"};
metcalfeTX=("TX "<>#1&)/@metcalfeSlices;
metcalfeRX=("RX "<>#1&)/@metcalfeSlices;
edgesTX=DirectedEdge@@@Partition[metcalfeTX,2,1];
edgesRX=DirectedEdge@@@Partition[metcalfeRX,2,1];
edgesMetcalfe=Join[edgesTX,edgesRX];
positionsMetcalfe=AssociationThread[Join[metcalfeTX,metcalfeRX],Join[Table[{i,2},{i,Length[metcalfeTX]}],Table[{i,1},{i,Length[metcalfeRX]}]]];
metcalfeGraph=LabeledDigraph[edgesMetcalfe,Join[metcalfeTX,metcalfeRX],VertexPositions->positionsMetcalfe,VertexSize->Large,EdgeStyle->Directive[Thick,Blue],PlotLabel->Style["6.1.1 Two Independent Metcalfe Channels (TX & RX Pipelines)",Bold,14]];
edgesSACK8=Append[edgesMetcalfe,"RX SLICE 5-8"\[DirectedEdge]"TX SLICE 5-8"];
sack8Graph=LabeledDigraph[edgesSACK8,Join[metcalfeTX,metcalfeRX],VertexPositions->positionsMetcalfe,VertexSize->Large,EdgeStyle->{Blue,Red},PlotLabel->Style["6.1.2 Internal SACK Feedback on Last Slice (SACK8)",Bold,14]];
edgesSACK1=Append[edgesMetcalfe,"RX SLICE 1"\[DirectedEdge]"TX SLICE 1"];
sack1Graph=LabeledDigraph[edgesSACK1,Join[metcalfeTX,metcalfeRX],VertexPositions->positionsMetcalfe,VertexSize->Large,EdgeStyle->{Blue,Red},PlotLabel->Style["6.1.3 Internal SACK Feedback on First Slice (SACK1)",Bold,14]];
sackLayers={"SACK 00\nInformation\n(Surprisal)","SACK 01\nKnowledge\n(Captured)","SACK 10\nSemantics\n(Meaning)","SACK 11\nUnderstanding\n(Syntax)"};
edgesSackLayers=DirectedEdge@@@Partition[sackLayers,2,1];
positionsSackLayers=AssociationThread[sackLayers,Table[{i,0},{i,Length[sackLayers]}]];
sackLayersGraph=LabeledDigraph[edgesSackLayers,sackLayers,VertexPositions->positionsSackLayers,VertexSize->Medium,EdgeStyle->Directive[Thick,Darker[Green]],PlotLabel->Style["6.2 Four Shannon-like SACK Layers",Bold,14]];
shannonSlices={"SACK 00","SACK 01","SACK 10","SACK 11"};
aliceTX=("Alice TX "<>#1&)/@shannonSlices;
aliceRX=("Alice RX "<>#1&)/@shannonSlices;
bobTX=("Bob TX "<>#1&)/@shannonSlices;
bobRX=("Bob RX "<>#1&)/@shannonSlices;
edgesAliceTX=DirectedEdge@@@Partition[aliceTX,2,1];
edgesAliceRX=DirectedEdge@@@Partition[aliceRX,2,1];
edgesBobTX=DirectedEdge@@@Partition[bobTX,2,1];
edgesBobRX=DirectedEdge@@@Partition[bobRX,2,1];
crossEdges=Join[Table[aliceTX[[i]]\[DirectedEdge]bobRX[[i]],{i,Length[shannonSlices]}],Table[bobTX[[i]]\[DirectedEdge]aliceRX[[i]],{i,Length[shannonSlices]}]];
edgesFullDuplex=Join[edgesAliceTX,edgesAliceRX,edgesBobTX,edgesBobRX,crossEdges];
verticesFullDuplex=Join[aliceTX,aliceRX,bobTX,bobRX];
positionsFullDuplex=AssociationThread[verticesFullDuplex,Join[Table[{i,4},{i,Length[aliceTX]}],Table[{i,3},{i,Length[aliceRX]}],Table[{i,2},{i,Length[bobTX]}],Table[{i,1},{i,Length[bobRX]}]]];
metcalfeGraph
sack8Graph
sack1Graph
sackLayersGraph


Module[{drawAntBeeScouting,drawDatacenterTopologies,drawHybridLogicalClock,blue=RGBColor[0.1,0.3,0.7],red=RGBColor[0.7,0.1,0.1],green=RGBColor[0.1,0.6,0.1],orange=RGBColor[0.9,0.5,0.1]},drawAntBeeScouting[]:=Module[{g=GridGraph[{5,5}],coords,antPath,beePath,antColor=Blue,beeColor=Red,arrowOpts={Thick,Arrowheads[0.05]}},coords=AssociationThread[VertexList[g],Table[{Mod[i-1,5]+1,Quotient[i-1,5]+1},{i,VertexCount[g]}]];antPath={{3,3},{3,4},{4,4},{4,3},{4,2},{3,2},{2,2},{2,3},{2,4}};beePath=Table[{i,1},{i,1,5}];Show[Graph[g,VertexCoordinates->coords,VertexSize->Medium,VertexLabels->None,ImageSize->500],Graphics[{antColor,arrowOpts,Arrow[antPath],beeColor,arrowOpts,Arrow[beePath]}],PlotLabel->Style["6.4 ANT (Blue) and BEE (Red) Scouting Paths on 5x5 Grid",18,Bold]]];drawDatacenterTopologies[]:=Module[{centralized,decentralized,graphGrid},centralized=StarGraph[10];decentralized=Graph[Join[Table[i->11,{i,1,7}],Table[11->j,{j,12,20}]],VertexLabels->"Name",GraphStyle->"NameLabeled"];graphGrid=GraphicsGrid[{{Graph[centralized,VertexLabels->"Name",PlotLabel->Style["Centralized Topology",14,Bold],ImageSize->300],Graph[decentralized,VertexLabels->"Name",PlotLabel->Style["Decentralized Topology",14,Bold],ImageSize->300]}},Spacings->{3,2}];graphGrid];drawHybridLogicalClock[]:=Module[{events=Range[6],pt={10,11,12,12,13,14},ctr={0,0,1,2,0,0},physData,logicData},physData=Transpose[{events,pt}];logicData=Transpose[{events,ctr}];ListLinePlot[{physData,logicData},PlotMarkers->{Style["\[FilledCircle]",20,blue],Style["\[FilledSquare]",20,red]},PlotStyle->{blue,red},PlotLegends->Placed[{"Physical Time (pt)","Logical Counter (ctr)"},Above],Frame->True,FrameLabel->{"Event Index","Value"},PlotLabel->Style["6.36 Hybrid Logical Clock Event Evolution",18,Bold],ImageSize->700]];Column[{drawAntBeeScouting[],Spacer[30],drawDatacenterTopologies[],Spacer[30],drawHybridLogicalClock[]},Spacings->3]]


Module[{nSlices=8,dx=1.2,baseY=0,sackColors,layers,sackBits,txSlices,rxSlices,arrows,feedbackSACK1,feedbackSACK8,fourLayersRects,fourLayersLabels,fullDuplexTxY=1.5,fullDuplexRxY=-1.5,fullDuplexTxSlices,fullDuplexRxSlices,fullDuplexTxToRxArrows,fullDuplexRxToTxArrows,antBeeGridSize=5,antColor=Blue,beeColor=Red,antPath,beePath,nodeCoords,hlcEvents={"e1","e2","e3","e4","e5","e6"},physTimes={10,11,12,12,13,14},logicalCtrs={0,0,1,2,0,0},epsilon=0.3},sackColors=ColorData[97,"ColorList"][[{1,3,5,7}]];sackBits={"00","01","10","11"};layers={"Information (SACK 00)","Knowledge (SACK 01)","Semantics (SACK 10)","Understanding (SACK 11)"};txSlices=Table[Rectangle[{(i-1) dx,baseY+0.2},{i dx-0.2,baseY+0.8}],{i,nSlices}];rxSlices=Table[Rectangle[{(i-1) dx,baseY-0.8},{i dx-0.2,baseY-0.2}],{i,nSlices}];arrows=Flatten[Table[{Blue,Arrowheads[0.04],Arrow[{{(i-1) dx+0.4,baseY+0.8},{i dx-0.4,baseY+0.8}}],Red,Arrowheads[0.04],Arrow[{{i dx-0.4,baseY-0.8},{(i-1) dx+0.4,baseY-0.8}}]},{i,nSlices}]];feedbackSACK1={Darker[Green],Thick,Arrowheads[0.05],Arrow[{{0.5 dx,baseY+1.3},{0.5 dx,baseY+0.9}}],Arrow[{{0.5 dx,baseY+1.3},{3.5 dx,baseY+1.3}}],Text[Style["SACK 1 Feedback",Darker[Green],Bold,14],{2 dx,baseY+1.5}]};feedbackSACK8={Darker[Green],Thick,Arrowheads[0.05],Arrow[{{3.5 dx,baseY+1.3},{3.5 dx,baseY+0.9}}],Arrow[{{3.5 dx,baseY+1.3},{0.5 dx,baseY+1.3}}],Text[Style["SACK 8 Feedback",Darker[Green],Bold,14],{2 dx,baseY+1.5}]};Print[Graphics[{Gray,Opacity[0.3],txSlices,rxSlices,Black,arrows,feedbackSACK1,feedbackSACK8,Text[Style["ETHERNET TX",Bold,16],{-0.3,baseY+0.5}],Text[Style["ETHERNET RX",Bold,16],{-0.3,baseY-0.5}]},PlotRange->{{-0.5,nSlices dx+0.5},{baseY-1.5,baseY+2}},ImageSize->700,Background->LightGray,Frame->True,FrameLabel->{"Slices (Time Pipeline)",None},PlotLabel->Style["6.1 Back-to-Back Shannon Channels with SACK Feedback",18,Bold]]];fourLayersRects=Table[{EdgeForm[Black],FaceForm[sackColors[[i]]],Rectangle[{0,i-1},{nSlices,i}]},{i,4}];fourLayersLabels=Table[Text[Style[layers[[i]],Bold,14,White],{nSlices/2,i-0.5}],{i,4}];Print[Graphics[{fourLayersRects,Black,fourLayersLabels,Table[{Gray,Dashed,Line[{{i,0},{i,4}}]},{i,1,nSlices-1}],Table[Text[Style[ToString[i],12,Black],{i-0.5,-0.3}],{i,1,nSlices}]},PlotRange->{{0,nSlices},{-0.5,4}},ImageSize->700,Frame->True,FrameTicks->None,PlotLabel->Style["6.2 Four Shannon-like Layers with Partial ACK (SACK) Boundaries",18,Bold]]];fullDuplexTxSlices=Table[{sackColors[[Mod[i-1,4]+1]],Rectangle[{(i-1) dx,fullDuplexTxY},{i dx-0.2,fullDuplexTxY+0.6}]},{i,nSlices}];fullDuplexRxSlices=Table[{sackColors[[Mod[i-1,4]+1]],Rectangle[{(i-1) dx,fullDuplexRxY},{i dx-0.2,fullDuplexRxY+0.6}]},{i,nSlices}];fullDuplexTxToRxArrows=Table[Arrow[{{(i-1) dx+0.4,fullDuplexTxY},{(i-1) dx+0.4,fullDuplexRxY+0.6}}],{i,nSlices}];fullDuplexRxToTxArrows=Table[Arrow[{{(i-1) dx+0.4,fullDuplexRxY+0.6},{(i-1) dx+0.4,fullDuplexTxY}}],{i,nSlices}];Print[Graphics[{fullDuplexTxSlices,fullDuplexRxSlices,Black,fullDuplexTxToRxArrows,fullDuplexRxToTxArrows,Style[Text["6.3 Bidirectional Full-Duplex Shannon-Metcalfe Channel"],{(nSlices dx)/2,fullDuplexTxY+1},Bold,14],Table[Style[Text["SACK "<>sackBits[[Mod[i-1,4]+1]],{(i-1) dx+0.4,fullDuplexTxY+0.3}],Bold,FontColor->Darker[Gray,0.7]],{i,4}],Table[Style[Text["SACK "<>sackBits[[Mod[i-1,4]+1]],{(i-1) dx+0.4,fullDuplexRxY+0.3}],Bold,FontColor->Darker[Gray,0.7]],{i,4}]},PlotRange->{{-0.5,nSlices dx+0.5},{fullDuplexRxY-0.5,fullDuplexTxY+1.5}},ImageSize->700,Background->LightGray,Frame->True,FrameTicks->None]];nodeCoords=AssociationThread[Range[antBeeGridSize^2],Flatten[Table[{i,j},{i,1,antBeeGridSize},{j,1,antBeeGridSize}],1]];antPath={{3,3},{3,4},{4,4},{4,3},{4,2},{3,2},{2,2},{2,3},{2,4}};beePath=Table[{i,1},{i,1,antBeeGridSize}];Print[Graphics[{LightGray,PointSize[0.015],Point/@Values[nodeCoords],Blue,Thick,Arrowheads[0.04],Arrow[antPath],Red,Thick,Arrowheads[0.04],Arrow[beePath],Style[Text["ANT Scouts (Blue)"],{1,antBeeGridSize+0.5},Blue,Bold,14],Style[Text["BEE Scouts (Red)"],{antBeeGridSize-1,antBeeGridSize+0.5},Red,Bold,14]},PlotRange->{{0,antBeeGridSize+1},{0,antBeeGridSize+1}},ImageSize->500,Axes->True]];Print[ListLinePlot[{Transpose[{Range[Length[hlcEvents]],physTimes}],Transpose[{Range[Length[hlcEvents]],logicalCtrs}]},PlotMarkers->{Graphics[{Blue,Disk[]}],Graphics[{Red,Rectangle[]}]},PlotStyle->{Blue,Red},PlotLegends->Placed[{"Physical Time (pt)","Logical Counter (ctr)"},Above],Frame->True,FrameLabel->{"Event Index","Value"},PlotLabel->Style["6.36 Hybrid Logical Clock Event Evolution",18,Bold],ImageSize->700]];Print[Style["Chapter 6: \[CapitalAE]thernet Architecture - Mathematica Visualizations",Bold,20,Blue]];]


Module[{slices=Range[8],txColor=Lighter[Blue,0.3],rxColor=Lighter[Green,0.3],sackLevels={{"Information (SACK 00)",Blue},{"Knowledge (SACK 01)",Green},{"Semantics (SACK 10)",Purple},{"Syntax (SACK 11)",Red}},fullDuplexSlices=Range[8],antGridSize=3,antEdgesCW,antEdgesCCW,beeLength=6,centralGraph,decentralGraph,distributedGraph,hlcEvents,abpStates},metcalfePlot=Graphics[{Style[Text["6.1 Two Independent Metcalfe Channels",{4.5,5}],Bold,16],Table[{txColor,Rectangle[{i,3.5},{i+0.8,4.5}],Black,Text[Style["TX Slice "<>ToString[i],Bold,12],{i+0.4,4}]},{i,slices}],Table[{rxColor,Rectangle[{i,1.5},{i+0.8,2.5}],Black,Text[Style["RX Slice "<>ToString[i],Bold,12],{i+0.4,2}]},{i,slices}],Style[Text["Transmit Pipeline",{0.5,4.8}],Italic,14,Blue],Style[Text["Receive Pipeline",{0.5,2.8}],Italic,14,Green]},PlotRange->{{0.5,8.5},{1,5}},ImageSize->600,Axes->False];sackFeedbackPlot[n_]:=Graphics[{Style[Text["6.1 Internal (SACK) Feedback on Slice "<>ToString[n],{4.5,5}],Bold,16],Table[{txColor,Rectangle[{i,3.5},{i+0.8,4.5}],Black,Text["TX Slice "<>ToString[i],{i+0.4,4}]},{i,slices}],Table[{rxColor,Rectangle[{i,1.5},{i+0.8,2.5}],Black,Text["RX Slice "<>ToString[i],{i+0.4,2}]},{i,slices}],{Red,Thick,Arrowheads[0.03],Arrow[{{n+0.4,4.5},{n+0.4,5.5}}]},{Red,Style[Text["SACK"<>ToString[n],{n+0.4,6}],Bold,16]}},PlotRange->{{0.5,8.5},{1,6.5}},ImageSize->600,Axes->False];fourLevelsPlot=Graphics[{Style[Text["6.2 Architectural Framework: Four Shannon-like Levels",{2.5,5}],Bold,16],Table[{sackLevels[[i,2]],Rectangle[{0,i-1},{5,i}],Black,Text[Style[sackLevels[[i,1]],Bold,14],{2.5,i-0.5}]},{i,Length[sackLevels]}]},PlotRange->{{0,5},{0,4}},ImageSize->400,Axes->False];fullDuplexPlot=Graphics[{Style[Text["6.3 Full-Duplex Bi-pipelined Shannon-Metcalfe Channel",{4.5,6}],Bold,16],Table[{txColor,Rectangle[{i,4},{i+0.8,5}],Black,Text["TX Slice "<>ToString[i],{i+0.4,4.5}]},{i,fullDuplexSlices}],Table[{rxColor,Rectangle[{i,1},{i+0.8,2}],Black,Text["RX Slice "<>ToString[i],{i+0.4,1.5}]},{i,fullDuplexSlices}],Table[{Purple,Arrowheads[0.03],Arrow[{{i+0.4,4},{i+0.4,2}}]},{i,fullDuplexSlices}],Style[Text["SACK 00",{1.2,5.4}],Bold,12],Style[Text["SACK 01",{3.6,5.4}],Bold,12],Style[Text["SACK 10",{5.4,5.4}],Bold,12],Style[Text["SACK 11",{7.6,5.4}],Bold,12],Style[Text["SACK 11",{7.6,0.6}],Bold,12],Style[Text["SACK 10",{5.4,0.6}],Bold,12],Style[Text["SACK 01",{3.6,0.6}],Bold,12],Style[Text["SACK 00",{1.2,0.6}],Bold,12]},PlotRange->{{0.5,8.5},{0.5,6}},ImageSize->700,Axes->False];antGridPoints=Flatten[Table[{x,y},{x,1,antGridSize},{y,1,antGridSize}],1];antEdgesCW=UndirectedEdge@@@{{1,2},{2,3},{3,6},{6,9},{9,8},{8,7},{7,4},{4,1}};antEdgesCCW=Reverse[antEdgesCW];antClockwiseGraph=Graph[antEdgesCW,VertexCoordinates->antGridPoints,VertexLabels->"Name",EdgeStyle->Blue,GraphStyle->"NameLabeled",PlotLabel->"ANT Clockwise Packet Clock"];antCounterClockwiseGraph=Graph[antEdgesCCW,VertexCoordinates->antGridPoints,VertexLabels->"Name",EdgeStyle->Red,GraphStyle->"NameLabeled",PlotLabel->"ANT Counterclockwise Packet Clock"];beeOutboundPath=Table[{i,1},{i,1,beeLength}];beeReturnPath=Reverse[beeOutboundPath];beePlot=Graphics[{Blue,Thick,Arrow[beeOutboundPath],Red,Thick,Arrow[beeReturnPath],Black,PointSize[Large],Point/@beeOutboundPath,Style[Text["Outbound",{beeLength+0.5,1}],Blue,Bold],Style[Text["Return",{0.5,1}],Red,Bold],Style[Text["6.9 BEE Scouts: Radial Exploration and Return",{beeLength/2,1.5}],Bold,14]},PlotRange->{{0,beeLength+1},{0.5,1.8}},ImageSize->600];centralGraph=Graph[Table[i->0,{i,1,46}],VertexLabels->"Name",GraphLayout->"StarEmbedding",PlotLabel->"Centralized Topology"];decentralGraph=RandomGraph[{47,60},GraphLayout->"SpringElectricalEmbedding",PlotLabel->"Decentralized Topology"];distributedGraph=RandomGraph[{47,98},GraphLayout->"SpringElectricalEmbedding",PlotLabel->"Distributed Topology"];SeedRandom[1234];hlcEvents=Table[{i,RandomReal[{i 5,i 5+2}],RandomInteger[{0,2}]},{i,1,20}];hlcPlot=ListPlot[hlcEvents[[All,{1,2}]],PlotStyle->{PointSize[Medium],Blue},AxesLabel->{"Event Index","HLC Physical Time"},PlotLabel->"6.36 Hybrid Logical Clock: Event Timestamps",ImageSize->600];abpStates={Style["00",Blue],Style["01",Green],Style["11",Red],Style["10",Purple]};abpGraph=Graph[DirectedEdge@@@{{1,2},{2,3},{3,4},{4,3}},VertexLabels->{1->abpStates[[1]],2->abpStates[[2]],3->abpStates[[3]],4->abpStates[[4]]},GraphStyle->"NameLabeled",PlotLabel->"Alternating Bit Protocol (ABP) State Transitions",VertexSize->Large];Column[{metcalfePlot,sackFeedbackPlot[8],sackFeedbackPlot[1],fourLevelsPlot,fullDuplexPlot,GraphicsGrid[{{antClockwiseGraph,antCounterClockwiseGraph}}],beePlot,GraphicsRow[{centralGraph,decentralGraph,distributedGraph},ImageSize->800],hlcPlot,abpGraph},Spacings->3]]


ClearAll[LabeledDigraph];
Options[LabeledDigraph]={VertexPositions->{},VertexSize->Medium,EdgeStyle->Black,PlotLabel->None};
LabeledDigraph[edges_,labels_,opts:OptionsPattern[]]:=Module[{pos=OptionValue[VertexPositions],vs=OptionValue[VertexSize],es=OptionValue[EdgeStyle],pl=OptionValue[PlotLabel],verts},verts=VertexList[Graph[edges]];Graph[edges,VertexLabels->Thread[verts->Placed[labels,Center]],VertexCoordinates->pos,VertexSize->vs,EdgeStyle->es,DirectedEdges->True,PlotLabel->pl,ImagePadding->20,PlotRangePadding->Scaled[0.1]]];
metcalfeSlices={"SLICE 1","SLICE 2","SLICE 3-4","SLICE 5-8"};
metcalfeTX=("TX "<>#1&)/@metcalfeSlices;
metcalfeRX=("RX "<>#1&)/@metcalfeSlices;
edgesTX=DirectedEdge@@@Partition[metcalfeTX,2,1];
edgesRX=DirectedEdge@@@Partition[metcalfeRX,2,1];
edgesMetcalfe=Join[edgesTX,edgesRX];
positionsMetcalfe=AssociationThread[Join[metcalfeTX,metcalfeRX],Join[Table[{i,2},{i,Length[metcalfeTX]}],Table[{i,1},{i,Length[metcalfeRX]}]]];
metcalfeGraph=LabeledDigraph[edgesMetcalfe,Join[metcalfeTX,metcalfeRX],VertexPositions->positionsMetcalfe,VertexSize->Large,EdgeStyle->Directive[Thick,Blue],PlotLabel->Style["6.1.1 Two Independent Metcalfe Channels (TX & RX Pipelines)",Bold,14]];
edgesSACK8=Append[edgesMetcalfe,"RX SLICE 5-8"\[DirectedEdge]"TX SLICE 5-8"];
sack8Graph=LabeledDigraph[edgesSACK8,Join[metcalfeTX,metcalfeRX],VertexPositions->positionsMetcalfe,VertexSize->Large,EdgeStyle->{Blue,Red},PlotLabel->Style["6.1.2 Internal SACK Feedback on Last Slice (SACK8)",Bold,14]];
edgesSACK1=Append[edgesMetcalfe,"RX SLICE 1"\[DirectedEdge]"TX SLICE 1"];
sack1Graph=LabeledDigraph[edgesSACK1,Join[metcalfeTX,metcalfeRX],VertexPositions->positionsMetcalfe,VertexSize->Large,EdgeStyle->{Blue,Red},PlotLabel->Style["6.1.3 Internal SACK Feedback on First Slice (SACK1)",Bold,14]];
sackLayers={"SACK 00\nInformation\n(Surprisal)","SACK 01\nKnowledge\n(Captured)","SACK 10\nSemantics\n(Meaning)","SACK 11\nUnderstanding\n(Syntax)"};
edgesSackLayers=DirectedEdge@@@Partition[sackLayers,2,1];
positionsSackLayers=AssociationThread[sackLayers,Table[{i,0},{i,Length[sackLayers]}]];
sackLayersGraph=LabeledDigraph[edgesSackLayers,sackLayers,VertexPositions->positionsSackLayers,VertexSize->Medium,EdgeStyle->Directive[Thick,Darker[Green]],PlotLabel->Style["6.2 Four Shannon-like SACK Layers",Bold,14]];
shannonSlices={"SACK 00","SACK 01","SACK 10","SACK 11"};
aliceTX=("Alice TX "<>#1&)/@shannonSlices;
aliceRX=("Alice RX "<>#1&)/@shannonSlices;
bobTX=("Bob TX "<>#1&)/@shannonSlices;
bobRX=("Bob RX "<>#1&)/@shannonSlices;
edgesAliceTX=DirectedEdge@@@Partition[aliceTX,2,1];
edgesAliceRX=DirectedEdge@@@Partition[aliceRX,2,1];
edgesBobTX=DirectedEdge@@@Partition[bobTX,2,1];
edgesBobRX=DirectedEdge@@@Partition[bobRX,2,1];
crossEdges=Join[Table[aliceTX[[i]]\[DirectedEdge]bobRX[[i]],{i,Length[shannonSlices]}],Table[bobTX[[i]]\[DirectedEdge]aliceRX[[i]],{i,Length[shannonSlices]}]];
edgesFullDuplex=Join[edgesAliceTX,edgesAliceRX,edgesBobTX,edgesBobRX,crossEdges];
verticesFullDuplex=Join[aliceTX,aliceRX,bobTX,bobRX];
positionsFullDuplex=AssociationThread[verticesFullDuplex,Join[Table[{i,4},{i,Length[aliceTX]}],Table[{i,3},{i,Length[aliceRX]}],Table[{i,2},{i,Length[bobTX]}],Table[{i,1},{i,Length[bobRX]}]]];
fullDuplexGraph=LabeledDigraph[edgesFullDuplex,verticesFullDuplex,VertexPositions->positionsFullDuplex,VertexSize->Small,EdgeStyle->Directive[Thick,Purple],PlotLabel->Style["6.3 Bidirectional Full-Duplex Shannon-Metcalfe Channel",Bold,14]];
abpPath=Table[{Mod[i,8]+1,Quotient[i,8]+1},{i,0,23}];
abpEdges=DirectedEdge@@@Partition[abpPath,2,1];
abpGraph=Graph[abpEdges,VertexCoordinates->AssociationThread[abpPath->abpPath],VertexSize->Medium,VertexLabels->None,EdgeStyle->Directive[Blue,Thick],PlotLabel->Style["6.11 Alternating Bit Protocol (ABP) Snake",Bold,14]];
tsvfLayers={"Input","Hidden 1","Hidden 2","Output"};
forwardEdges=DirectedEdge@@@Partition[tsvfLayers,2,1];
backwardEdges=DirectedEdge@@@Reverse/@Partition[tsvfLayers,2,1];
tsvfPositions=AssociationThread[tsvfLayers,Table[{i,0},{i,Length[tsvfLayers]}]];
tsvfForwardGraph=Graph[forwardEdges,VertexCoordinates->tsvfPositions,EdgeStyle->Directive[Blue,Thick],VertexSize->Large,VertexLabels->Placed[tsvfLayers,Center]];
tsvfBackwardGraph=Graph[backwardEdges,VertexCoordinates->tsvfPositions,EdgeStyle->Directive[Red,Dashed,Thick],VertexSize->Large,VertexLabels->None];
tsvfCombinedGraph=Show[tsvfForwardGraph,tsvfBackwardGraph,PlotLabel->Style["6.21-6.28 TSVF: Forward (Blue) and Backward (Red Dashed) Propagation",Bold,14]];
Column[{metcalfeGraph,sack8Graph,sack1Graph,sackLayersGraph,fullDuplexGraph,abpGraph,tsvfCombinedGraph},Spacings->3]


Module[{nSlices=8,dx=1.2,baseY=0,sackColors,sackBits,layers,txSlices,rxSlices,arrows,feedbackSACK1,feedbackSACK8,fourLayersRects,fourLayersLabels,fullDuplexTxY=1.5,fullDuplexRxY=-1.5,fullDuplexTxSlices,fullDuplexRxSlices,fullDuplexTxToRxArrows,fullDuplexRxToTxArrows,antBeeGridSize=5,antColor=Blue,beeColor=Red,antPath,beePath,nodeCoords,hlcEvents={"e1","e2","e3","e4","e5","e6"},physTimes={10,11,12,12,13,14},logicalCtrs={0,0,1,2,0,0}},sackColors=ColorData[97,"ColorList"][[{1,3,5,7}]];sackBits={"00","01","10","11"};layers={"Information (SACK 00)","Knowledge (SACK 01)","Semantics (SACK 10)","Understanding (SACK 11)"};txSlices=Table[Rectangle[{(i-1) dx,baseY+0.2},{i dx-0.2,baseY+0.8}],{i,nSlices}];rxSlices=Table[Rectangle[{(i-1) dx,baseY-0.8},{i dx-0.2,baseY-0.2}],{i,nSlices}];arrows=Flatten[Table[{Blue,Arrowheads[0.04],Arrow[{{(i-1) dx+0.4,baseY+0.8},{i dx-0.4,baseY+0.8}}],Red,Arrowheads[0.04],Arrow[{{i dx-0.4,baseY-0.8},{(i-1) dx+0.4,baseY-0.8}}]},{i,nSlices}]];feedbackSACK1={Darker[Green],Thick,Arrowheads[0.05],Arrow[{{0.5 dx,baseY+1.3},{0.5 dx,baseY+0.9}}],Arrow[{{0.5 dx,baseY+1.3},{3.5 dx,baseY+1.3}}],Text[Style["SACK 1 Feedback",Darker[Green],Bold,14],{2 dx,baseY+1.5}]};feedbackSACK8={Darker[Green],Thick,Arrowheads[0.05],Arrow[{{3.5 dx,baseY+1.3},{3.5 dx,baseY+0.9}}],Arrow[{{3.5 dx,baseY+1.3},{0.5 dx,baseY+1.3}}],Text[Style["SACK 8 Feedback",Darker[Green],Bold,14],{2 dx,baseY+1.5}]};Print[Graphics[{Gray,Opacity[0.3],txSlices,rxSlices,Black,arrows,feedbackSACK1,feedbackSACK8,Text[Style["ETHERNET TX",Bold,16],{-0.3,baseY+0.5}],Text[Style["ETHERNET RX",Bold,16],{-0.3,baseY-0.5}]},PlotRange->{{-0.5,nSlices dx+0.5},{baseY-1.5,baseY+2}},ImageSize->700,Background->LightGray,Frame->True,FrameLabel->{"Slices (Time Pipeline)",None},PlotLabel->Style["6.1 Back-to-Back Shannon Channels with SACK Feedback",18,Bold]]];fourLayersRects=Table[{EdgeForm[Black],FaceForm[sackColors[[i]]],Rectangle[{0,i-1},{nSlices,i}]},{i,4}];fourLayersLabels=Table[Text[Style[layers[[i]],Bold,14,White],{nSlices/2,i-0.5}],{i,4}];Print[Graphics[{fourLayersRects,Black,fourLayersLabels,Table[{Gray,Dashed,Line[{{i,0},{i,4}}]},{i,1,nSlices-1}],Table[Text[Style[ToString[i],12,Black],{i-0.5,-0.3}],{i,1,nSlices}]},PlotRange->{{0,nSlices},{-0.5,4}},ImageSize->700,Frame->True,FrameTicks->None,PlotLabel->Style["6.2 Four Shannon-like Layers with Partial ACK (SACK) Boundaries",18,Bold]]];fullDuplexTxSlices=Table[{sackColors[[Mod[i-1,4]+1]],Rectangle[{(i-1) dx,fullDuplexTxY},{i dx-0.2,fullDuplexTxY+0.6}]},{i,nSlices}];fullDuplexRxSlices=Table[{sackColors[[Mod[i-1,4]+1]],Rectangle[{(i-1) dx,fullDuplexRxY},{i dx-0.2,fullDuplexRxY+0.6}]},{i,nSlices}];fullDuplexTxToRxArrows=Table[Arrow[{{(i-1) dx+0.4,fullDuplexTxY},{(i-1) dx+0.4,fullDuplexRxY+0.6}}],{i,nSlices}];fullDuplexRxToTxArrows=Table[Arrow[{{(i-1) dx+0.4,fullDuplexRxY+0.6},{(i-1) dx+0.4,fullDuplexTxY}}],{i,nSlices}];Print[Graphics[{fullDuplexTxSlices,fullDuplexRxSlices,Black,fullDuplexTxToRxArrows,fullDuplexRxToTxArrows,Style[Text["6.3 Bidirectional Full-Duplex Shannon-Metcalfe Channel"],{(nSlices dx)/2,fullDuplexTxY+1},Bold,14],Table[Style[Text["SACK "<>sackBits[[Mod[i-1,4]+1]],{(i-1) dx+0.4,fullDuplexTxY+0.3}],Bold,FontColor->Darker[Gray,0.7]],{i,4}],Table[Style[Text["SACK "<>sackBits[[Mod[i-1,4]+1]],{(i-1) dx+0.4,fullDuplexRxY+0.3}],Bold,FontColor->Darker[Gray,0.7]],{i,4}]},PlotRange->{{-0.5,nSlices dx+0.5},{fullDuplexRxY-0.5,fullDuplexTxY+1.5}},ImageSize->700,Background->LightGray,Frame->True,FrameTicks->None]];nodeCoords=AssociationThread[Range[antBeeGridSize^2],Flatten[Table[{i,j},{i,1,antBeeGridSize},{j,1,antBeeGridSize}],1]];antPath={{3,3},{3,4},{4,4},{4,3},{4,2},{3,2},{2,2},{2,3},{2,4}};beePath=Table[{i,1},{i,1,antBeeGridSize}];Print[Graphics[{LightGray,PointSize[0.015],Point/@Values[nodeCoords],Blue,Thick,Arrowheads[0.04],Arrow[antPath],Red,Thick,Arrowheads[0.04],Arrow[beePath],Style[Text["ANT Scouts (Blue)"],{1,antBeeGridSize+0.5},Blue,Bold,14],Style[Text["BEE Scouts (Red)"],{antBeeGridSize-1,antBeeGridSize+0.5},Red,Bold,14]},PlotRange->{{0,antBeeGridSize+1},{0,antBeeGridSize+1}},ImageSize->500,Axes->True]];Print[ListLinePlot[{Transpose[{Range[Length[hlcEvents]],physTimes}],Transpose[{Range[Length[hlcEvents]],logicalCtrs}]},PlotMarkers->{Graphics[{Blue,Disk[]}],Graphics[{Red,Rectangle[]}]},PlotStyle->{Blue,Red},PlotLegends->Placed[{"Physical Time (pt)","Logical Counter (ctr)"},Above],Frame->True,FrameLabel->{"Event Index","Value"},PlotLabel->Style["6.36 Hybrid Logical Clock Event Evolution",18,Bold],ImageSize->700]];Print[Style["Chapter 6: \[CapitalAE]thernet Architecture - Mathematica Visualizations",Bold,20,Blue]];]


Graph[{"Alice", "Bob", "Carol"}, {UndirectedEdge["Alice", "Bob"], UndirectedEdge["Bob", "Carol"], UndirectedEdge["Carol", "Alice"]}, {GraphStyle -> "NameLabeled", ImageSize -> 400, VertexLabels -> {"Name"}}]


GridGraph[{3,3},VertexLabels->"Name",GraphStyle->"NameLabeled",ImageSize->400]


clos=Graph[Flatten[Join[Table[i\[UndirectedEdge]100+Ceiling[i/10],{i,1,200}],Table[100+i\[UndirectedEdge]200+j,{i,1,20},{j,1,4}]]],VertexLabels->Placed["Name",Center],ImageSize->500,GraphLayout->"LayeredDigraphEmbedding"];
mesh=RandomGraph[{200,800},VertexLabels->None,ImageSize->500];
GraphicsRow[{clos,mesh}]


Graphics[{Style[Text["Ethernet Segment #1",{1,2}],Bold,14,Blue],Style[Text["Ethernet Segment #2",{5,2}],Bold,14,Blue],Thick,Blue,Line[{{0,1},{3,1}}],Style[Text["Coax Cable",{1.5,1.3}],Italic,12],Thick,Blue,Line[{{3.5,1},{7,1}}],Style[Text["Coax Cable",{5,1.3}],Italic,12],Red,Disk[{0,1},0.1],Style[Text["Terminator",{-0.5,1}],Bold,Red,12],Black,Rectangle[{3,0.8},{3.5,1.2}],Style[Text["TAP",{3.25,1.5}],Bold,Black,12],Orange,Rectangle[{3.75,0.8},{4.25,1.2}],Style[Text["Repeater",{4,1.5}],Bold,Orange,12],Style[Text["Station 1",{1,0.5}],Bold,Darker[Green]],Style[Text["Station 2",{6,0.5}],Bold,Darker[Green]]},PlotRange->{{-1,8},{0,3}},ImageSize->500,Axes->False]


nodes={"Alice","Bob","Charlie"};
edges={"Alice"\[UndirectedEdge]"Bob","Bob"\[UndirectedEdge]"Charlie","Charlie"\[UndirectedEdge]"Alice"};
Graph[nodes,edges,VertexLabels->"Name",GraphLayout->"CircularEmbedding",VertexSize->Small,PlotLabel->"7.6 Minimum Triangle: Fault-Tolerant Chiplet XPU Links"]


centralized=Graph[Join[Table[i->0,{i,1,15}]],VertexLabels->"Name",GraphLayout->"StarEmbedding",PlotLabel->"Centralized Topology"];
decentralized=RandomGraph[{16,25},GraphLayout->"SpringElectricalEmbedding",PlotLabel->"Decentralized Topology"];
GraphicsRow[{centralized,decentralized},ImageSize->600]


Graph[{"Station 1", "Transceiver 1", "Repeater", "Transceiver 2", "Station 2", "TAP"}, {UndirectedEdge["Station 1", "Transceiver 1"], UndirectedEdge["Transceiver 1", "Repeater"], UndirectedEdge["Repeater", "Transceiver 2"], UndirectedEdge["Transceiver 2", "Station 2"], UndirectedEdge["Repeater", "TAP"]}, {GraphLayout -> "LayeredDigraphEmbedding", ImageSize -> Small, PlotLabel -> "Two-segment Ethernet Model", VertexLabels -> {"Name"}}]


nodesHDX={"TX Station A","RX Station A","TX Station B","RX Station B"};
edgesHDX={"TX Station A"->"RX Station B","TX Station B"->"RX Station A"};
Graph[edgesHDX,VertexLabels->"Name",ImageSize->Small,GraphStyle->"NameLabeled",PlotLabel->"Bipartite Half-Duplex \[CapitalAE]thernet",EdgeStyle->Directive[Blue,Thick],DirectedEdges->True]


triangleNodes={"Alice","Bob","Carol"};
triangleEdges={"Alice"->"Bob","Bob"->"Carol","Carol"->"Alice","Bob"->"Alice","Carol"->"Bob","Alice"->"Carol"};
Graph[triangleEdges,ImageSize->Small,VertexLabels->"Name",GraphLayout->"CircularEmbedding",PlotLabel->"Minimal Triangle Network Topology",EdgeStyle->Directive[Green,Thick],DirectedEdges->True]


dagEdges={"Lock Table"->"Row","Row"->"Field"};
Graph[dagEdges,ImageSize->Small,VertexLabels->"Name",GraphLayout->"LayeredDigraphEmbedding",DirectedEdges->True,PlotLabel->"Lock Hierarchy DAG"]


treeEdges={"Root"->"Home","Home"->"Documents","Home"->"Downloads","Root"->"etc","Root"->"var"};
Graph[treeEdges,VertexLabels->"Name",GraphLayout->"LayeredDigraphEmbedding",DirectedEdges->True,ImageSize->Small,PlotLabel->"Namespace Hierarchy Tree"]


Module[{nodes,edges,g,coords},nodes={"TAP1","Repeater","Station1","Station2","Terminator"};edges={"TAP1"->"Repeater","Repeater"->"Station1","Repeater"->"Station2","Station2"->"Terminator"};g=Graph[edges,VertexLabels->"Name"];coords=Association["TAP1"->{0,0},"Repeater"->{2,0},"Station1"->{4,1},"Station2"->{4,-1},"Terminator"->{6,-1}];Graph[g,VertexCoordinates->coords,VertexSize->Large,ImageSize->400,PlotLabel->Style["Two-Segment Ethernet Concept",Bold,16]]]


Module[{nodes,edges,g,coords,labels},nodes={"Transceiver1","Transceiver2","Transceiver3","Cable"};edges=UndirectedEdge@@@{{"Transceiver1","Cable"},{"Transceiver2","Cable"},{"Transceiver3","Cable"}};g=Graph[edges,VertexLabels->"Name"];coords=Association["Transceiver1"->{0,1},"Transceiver2"->{0,0},"Transceiver3"->{0,-1},"Cable"->{3,0}];Graph[g,VertexCoordinates->coords,VertexSize->Large,ImageSize->400,PlotLabel->Style["Half-Duplex Ethernet Bus with Transceivers",Bold,16]]]


Module[{nodes,edges,g,coords,edgeStyles},nodes={"Alice","Bob","Carol"};edges={"Alice"\[UndirectedEdge]"Bob","Bob"\[UndirectedEdge]"Carol","Carol"\[UndirectedEdge]"Alice"};coords=Association["Alice"->{0,0},"Bob"->{2,0},"Carol"->{1,1.7}];edgeStyles={Style["Alice"\[UndirectedEdge]"Bob",Blue,Thick],Style["Bob"\[UndirectedEdge]"Carol",Red,Thick],Style["Carol"\[UndirectedEdge]"Alice",Green,Thick]};Graph[edges,VertexCoordinates->coords,EdgeStyle->{Blue,Red,Green},VertexLabels->"Name",VertexSize->Large,ImageSize->350,PlotLabel->Style["Minimal 3-Node \[CapitalAE]thernet Chiplet Triangle",Bold,16]]]


Module[{g=GridGraph[{3,3}],coords},coords=AssociationThread[VertexList[g],Table[{Mod[i-1,3]+1,Quotient[i-1,3]+1},{i,VertexCount[g]}]];Graph[g,VertexCoordinates->coords,VertexLabels->Placed["Name",Center],VertexSize->Medium,ImageSize->400,PlotLabel->Style["3\[Times]3 Tile Mesh of XPUs",Bold,16]]]


Graphics[{Blue,Thick,Line[{{1,3},{5,3}}],Table[Text[Style["Station "<>ToString[i],12],{i,3.3}],{i,1,5}],Table[Disk[{i,3},0.1],{i,1,5}],Blue,Thick,Line[{{7,3},{11,3}}],Table[Text[Style["Station "<>ToString[i],12],{i+6,3.3}],{i,1,5}],Table[Disk[{i+6,3},0.1],{i,1,5}],Red,Rectangle[{5.5,2.7},{6.5,3.3}],Text[Style["Repeater",Red,Bold,14],{6,2.5}]},ImageSize->600,PlotRange->{{0,12},{2,4}},Axes->False]


Graphics[{Blue,Disk[{2,2},0.3],Text[Style["Node A",Bold,14],{2,1.6}],Green,Disk[{6,2},0.3],Text[Style["Node B",Bold,14],{6,1.6}],Black,Thick,Line[{{2.3,2},{5.7,2}}],Red,Arrowheads[0.04],Arrow[{{2.3,2.2},{5.7,2.2}}],Blue,Arrowheads[0.04],Arrow[{{5.7,1.8},{2.3,1.8}}]},ImageSize->400,PlotRange->{{1,7},{1.5,2.5}},Axes->False]


n=3;
spacing=2;
positions=Flatten[Table[{i,j},{i,1,n},{j,1,n}],1];
Graphics[{Blue,Table[Disk[spacing pos,0.3],{pos,positions}],Black,Flatten[Table[If[MemberQ[positions,{x+1,y}],Line[{spacing {x,y},spacing {x+1,y}}],{}],{x,1,n},{y,1,n}]],Black,Flatten[Table[If[MemberQ[positions,{x,y+1}],Line[{spacing {x,y},spacing {x,y+1}}],{}],{x,1,n},{y,1,n}]],Flatten[Table[Text[Style[ToString[i],Bold,12],spacing pos+{0,-0.4}],{i,Length[positions]},{pos=positions[[i]]}]]},ImageSize->400,PlotRange->{{0,spacing (n+1)},{0,spacing (n+1)}},Axes->False]


Graphics[{Blue,Disk[{0,0},0.3],Text["Alice",{-0.4,-0.5}],Green,Disk[{2,0},0.3],Text["Bob",{2,-0.5}],Red,Disk[{1,1.732},0.3],Text["Carol",{1,2}],{Green,Thick,Line[{{0,0},{2,0}}]},{Blue,Thick,Line[{{0,0},{1,1.732}}]},{Red,Thick,Line[{{2,0},{1,1.732}}]}},ImageSize->400,PlotRange->{{-1,3},{-1,3}},Axes->False]


triangleGraph=Graph[{1, 2, 3}, {UndirectedEdge[1, 2], UndirectedEdge[2, 3], UndirectedEdge[3, 1]}, {GraphStyle -> "NameLabeled", ImageSize -> 300, VertexLabels -> {"Name"}, VertexSize -> {Large}}];
triangleGraph


dag=Graph[{1, 2, 3, 4}, {DirectedEdge[1, 2], DirectedEdge[1, 3], DirectedEdge[2, 4], DirectedEdge[3, 4]}, {GraphLayout -> "LayeredDigraphEmbedding", ImageSize -> 300, VertexLabels -> {"Name"}}];
dag


tree=Graph[{1, 2, 3, 4, 5, 6}, {DirectedEdge[1, 2], DirectedEdge[1, 3], DirectedEdge[2, 4], DirectedEdge[2, 5], DirectedEdge[3, 6]}, {GraphLayout -> "LayeredDigraphEmbedding", ImageSize -> 300, VertexLabels -> {"Name"}}];
tree


rdmaGraph=Graph[{1, 2, 3, 4}, {UndirectedEdge[1, 2], UndirectedEdge[2, 3], UndirectedEdge[3, 4], UndirectedEdge[1, 4]}, {EdgeStyle -> {UndirectedEdge[1, 4] -> Directive[Thick, Red]}, ImageSize -> 300, VertexLabels -> {"Name"}}];
rdmaGraph


Module[{ethernetGraphics,triangleGraph,tileGraph,closGraph,meshGraph,sampleGraph,A,D,L,eigvals,lambda2,edges,lambda2Values},ethernetGraphics=Graphics[{Style[Text["Ethernet Segment #1",{1,2}],Bold,14,Blue],Style[Text["Ethernet Segment #2",{5,2}],Bold,14,Blue],Thick,Blue,Line[{{0,1},{3,1}}],Style[Text["Coax Cable",{1.5,1.3}],Italic,12],Line[{{3.5,1},{7,1}}],Style[Text["Coax Cable",{5,1.3}],Italic,12],Red,Disk[{0,1},0.1],Style[Text["Terminator",{-0.5,1}],Bold,Red,12],Black,Rectangle[{3,0.8},{3.5,1.2}],Style[Text["TAP",{3.25,1.5}],Bold,Black,12],Orange,Rectangle[{3.75,0.8},{4.25,1.2}],Style[Text["Repeater",{4,1.5}],Bold,Orange,12],Style[Text["Station 1",{1,0.5}],Bold,Darker[Green]],Style[Text["Station 2",{6,0.5}],Bold,Darker[Green]]},PlotRange->{{-1,8},{0,3}},ImageSize->500,Axes->False];triangleGraph=Graph[{"Alice", "Bob", "Charlie"}, {UndirectedEdge["Alice", "Bob"], UndirectedEdge["Bob", "Charlie"], UndirectedEdge["Charlie", "Alice"]}, {GraphLayout -> "CircularEmbedding", PlotLabel -> "Minimum Triangle: Fault-Tolerant Chiplet XPU Links", VertexLabels -> {"Name"}, VertexSize -> {Large}}];tileGraph=Graph[Flatten[Table[i+3 (j-1),{i,3},{j,3}]],UndirectedEdge@@@Select[Subsets[Range[9],{2}],(Abs[#1[[1]]-#1[[2]]]==1&&Quotient[#1[[1]]-1,3]==Quotient[#1[[2]]-1,3])||Abs[#1[[1]]-#1[[2]]]==3&],VertexLabels->"Name",GraphLayout->"GridEmbedding",PlotLabel->"3\[Times]3 Logical Tile",VertexSize->Medium];sampleGraph=RandomGraph[{10,15}];edges=EdgeList[sampleGraph];lambda2Values=Table[Module[{subg,conn},subg=EdgeDelete[sampleGraph,Take[edges,k]];conn=If[VertexCount[subg]>1&&EdgeCount[subg]>0,Sort[Eigenvalues[N[LaplacianMatrix[subg]]]],{0}];SelectFirst[conn,#1>1/1000000000&,0]],{k,0,Length[edges]}];closGraph=Graph[Join[Table["Server"<>ToString[i]->"ToR"<>ToString[Ceiling[i/10]],{i,1,20}],Flatten[Table["ToR"<>ToString[i]->"Spine"<>ToString[j],{i,1,2},{j,1,4}],1]],GraphLayout->"SpringElectricalEmbedding",PlotLabel->"Simplified Clos Topology",ImageSize->Large];meshGraph=Graph[RegularGraph[8,40],PlotLabel->"Simplified 8-Regular Mesh Topology",ImageSize->Large];Column[{ethernetGraphics,triangleGraph,tileGraph,ListLinePlot[lambda2Values,PlotRange->All,AxesLabel->{"Number of Removed Edges","Algebraic Connectivity \[Lambda]\:2082"},PlotLabel->"Resilience Metric R(k): \[Lambda]\:2082 vs. Edge Removal",ImageSize->500],closGraph},Spacings->2]]


Module[{aliceStates={"Alice: Ready to Send","Alice: Awaiting ACK"},bobStates={"Bob: Ready to Receive","Bob: Processing"},positions,tokenState="Alice: Ready to Send",tokenColor=Darker[Green],stateNodes,tokenGraphic,linkEdges},positions=Association["Alice: Ready to Send"->{0,1},"Alice: Awaiting ACK"->{2,1},"Bob: Ready to Receive"->{0,-1},"Bob: Processing"->{2,-1}];stateNodes={FaceForm[Lighter[Gray,0.5]],EdgeForm[Black],(Disk[positions[#1],0.4]&)/@Keys[positions],Black,(Text[#1,positions[#1],Background->White]&)/@Keys[positions]};tokenGraphic={tokenColor,EdgeForm[White],Disk[positions[tokenState],0.15]};linkEdges={Arrowheads[0.03],Thick,Arrow[{positions["Alice: Ready to Send"],positions["Bob: Processing"]}],Arrow[{positions["Bob: Processing"],positions["Alice: Awaiting ACK"]}],Dashed,Arrow[{positions["Alice: Awaiting ACK"],positions["Bob: Ready to Receive"]}],Arrow[{positions["Bob: Ready to Receive"],positions["Alice: Ready to Send"]}]};Graphics[{stateNodes,linkEdges,tokenGraphic},PlotLabel->Style["State of a Reversible LINK via Token Position",Bold,14],ImageSize->Large]]


Module[{asyncGraph,fifoGraph,coGraph,rscGraph,fabrics={"NVLink v3","UALink (proj.)","Scale-Up ETH","InfiniBand HDR","Ethernet + IP + TCP"},headers={16,20,12,64,76},blockSizes={64,128,256,512,1024},overheadData,compFeatures,compValuesEthernet,compValuesInfiniBand},asyncGraph=Graph[DirectedEdge@@@{{"SendA","RecvB"},{"SendC","RecvD"},{"SendB","RecvC"}},VertexLabels->"Name",GraphStyle->"NameLabeled",ImageSize->300,PlotLabel->"Asynchronous (A) - No ordering constraints"];fifoGraph=Graph[DirectedEdge@@@{{"Send1","Recv1"},{"Send2","Recv2"},{"Send1","Send2"},{"Recv1","Recv2"}},VertexLabels->"Name",GraphStyle->"NameLabeled",ImageSize->300,PlotLabel->"FIFO: Per-channel ordering (send order \[DoubleRightArrow] receive order)"];coGraph=Graph[DirectedEdge@@@{{"Send1","Recv1"},{"Send2","Recv2"},{"Send1","Send2"},{"Recv1","Recv2"},{"Send1","Recv2"}},VertexLabels->"Name",GraphStyle->"NameLabeled",ImageSize->300,PlotLabel->"Causally Ordered (CO): causal ordering globally enforced"];rscGraph=Graph[DirectedEdge@@@{{"Send1","Recv1"},{"Send2","Recv2"},{"Send1","Recv1"},{"Send2","Recv2"}},VertexLabels->"Name",GraphStyle->"NameLabeled",ImageSize->300,PlotLabel->"RSC: Rendezvous (send immediately followed by receive)"];Print[Grid[{{asyncGraph,fifoGraph},{coGraph,rscGraph}},Spacings->{2,2}]];overheadData={{0.25,0.125,0.0625,0.03125,0.015625},{0.313,0.156,0.078,0.039,0.02},{0.125,0.063,0.031,0.016,0.008},{1,0.5,0.25,0.125,0.063},{1.438,0.578,0.289,0.145,0.071}};Print[BarChart[Transpose[overheadData],ChartLabels->Placed[ToString/@blockSizes,"Below"],ChartLegends->fabrics,PlotLabel->"8.2 Header Overhead vs Block Size",Frame->True,FrameLabel->{"Block Size (Bytes)","Header Overhead Ratio"},ImageSize->Large,PlotRange->{0,1.6}]];compFeatures={"Reliability","Latency","Jitter","Congestion Control","Packet Loss","RDMA Support","CPU Overhead","Primary Use"};compValuesEthernet={"Best-effort (via TCP)","Milliseconds typical","High","Optional (DCB/PFC)","Possible","RoCE (complex)","High (software stack)","General networking"};compValuesInfiniBand={"Hardware-enforced","Microseconds scale","Very low","Built-in","Avoided by design","Native","Low (hardware offload)","HPC, AI, low-latency clusters"};Print[Grid[Prepend[Transpose[{compFeatures,compValuesEthernet,compValuesInfiniBand}],{"Feature","Ethernet (traditional)","InfiniBand"}],Frame->All,Background->{None,{LightGray,White}},Spacings->{3,1},ItemStyle->Directive[FontFamily->"Arial",FontSize->12]]];]


orderingNodes={"RSC","CO","FIFO","A"};
orderingEdges={"RSC"->"CO","CO"->"FIFO","FIFO"->"A"};
positionsOrdering=Association["RSC"->{1,1},"CO"->{2,1},"FIFO"->{3,1},"A"->{4,1}];
orderingGraph=Graph[orderingEdges,VertexLabels->Placed["Name",Center],VertexCoordinates->positionsOrdering,DirectedEdges->True,EdgeStyle->Arrowheads[0.03],VertexSize->Large,GraphStyle->"NameLabeled",PlotLabel->Style["8.1 Communication Ordering Hierarchy: RSC \[Subset] CO \[Subset] FIFO \[Subset] A",Bold,14]];
blockSizes={64,128,256,512,1024};
headerSizes=Association["NVLink v3"->16,"UALink (proj.)"->20,"Scale-Up Ethernet"->12,"InfiniBand HDR"->64,"Ethernet + IP + TCP"->84];
computeOverhead[header_,size_]:=(header 100)/size;
headerOverheadData=Table[{fabric,computeOverhead[headerSizes[fabric],size]},{fabric,Keys[headerSizes]},{size,blockSizes}];
headerOverheadPlotData=AssociationMap[Function[fabric,Thread[blockSizes->(computeOverhead[headerSizes[fabric],#1]&)/@blockSizes]],Keys[headerSizes]];
headerOverheadPlot=ListLogLinearPlot[Values[headerOverheadPlotData],PlotLegends->Keys[headerOverheadPlotData],PlotMarkers->Automatic,Frame->True,FrameLabel->{"Block Size (Bytes)","Header Overhead (%)"},PlotLabel->Style["8.2 Header Overhead vs Block Size for Link Fabrics",Bold,14],GridLines->Automatic,ImageSize->Large];
features={"Reliability","Latency","Jitter","Congestion Control","Packet Loss","RDMA Support","CPU Overhead","Use Case"};
ethernetVals={"Best-effort (via TCP)","Millisecond-scale (typical)","High","Optional (DCB/PFC)","Possible","RoCE (complex)","High (software stack)","General networking"};
infinibandVals={"Hardware-enforced","Microsecond-scale","Very low","Built-in","Avoided by design","Native","Low (hardware offload)","HPC, AI, low-latency clusters"};
featureComparisonTable=Grid[Prepend[MapThread[{#1,#2,#3}&,{features,ethernetVals,infinibandVals}],{"Feature","Ethernet (traditional)","InfiniBand"}],Frame->All,Background->{None,{LightGray,{White}}},Spacings->{2,1},ItemStyle->Directive[FontFamily->"Arial",FontSize->12],Alignment->Left,Dividers->All,BaseStyle->Directive[Bold]];
uecNodes={"Endpoints","Switches","Memory Pools","Fabric"};
uecEdges={"Endpoints"->"Switches","Switches"->"Fabric","Fabric"->"Memory Pools","Endpoints"->"Fabric"};
positionsUEC=Association["Endpoints"->{1,3},"Switches"->{3,3},"Fabric"->{3,1},"Memory Pools"->{1,1}];
uecGraph=Graph[uecEdges,VertexLabels->"Name",VertexCoordinates->positionsUEC,DirectedEdges->True,EdgeStyle->Directive[Thick,Blue],VertexSize->Small,PlotLabel->Style["8.3 Ultra Ethernet Consortium Architecture (Simplified)",Bold,14]];
Column[{orderingGraph,headerOverheadPlot,Style["8.5 Ethernet vs InfiniBand Feature Comparison",Bold,14],featureComparisonTable,uecGraph},Spacings->3]


Module[{events=Join[Table[{"s",i},{i,0,4}],Table[{"r",i},{i,0,4}]],edges,g,crownPath,layout,labels},edges=Join[Table[{"s",i}\[DirectedEdge]{"r",i},{i,0,4}],Table[{"r",i}\[DirectedEdge]{"s",i+1},{i,0,3}],Table[{"s",i}\[DirectedEdge]{"s",i+1},{i,0,3}]];g=Graph[edges,VertexLabels->Placed[ToString[#1]&,Center],DirectedEdges->True,GraphStyle->"NameLabeled",EdgeStyle->Directive[Blue,Thick],ImageSize->Large,PlotLabel->Style["Crown Dependency Cycle in Communication Ordering",Bold,16]];crownPath=Join[Table[{"s",i},{i,0,4}],Table[{"r",i},{i,0,4}]];Show[g,GraphHighlightStyle->Red,GraphHighlight->crownPath]];
Module[{blockSizes={64,128,256,512,1024},fabrics={"NVLink"->{25.0,12.5,6.3,3.1,1.6},"UALink"->{31.3,15.6,7.8,3.9,2.0},"Scale-Up ETH"->{12.5,6.3,3.1,1.6,0.8},"InfiniBand HDR"->{100,50,25,12.5,6.3},"Ethernet+IP+TCP"->{143.8,57.8,28.9,14.5,7.1}},plotData,colors=ColorData[97,"ColorList"]},plotData=Table[ListLinePlot[Transpose[{blockSizes,fabrics[[i,2]]}],PlotMarkers->Automatic,PlotRange->All,Frame->True,FrameLabel->{"Block Size (Bytes)","Header Overhead (%)"},PlotLabel->"Link Fabric Header Overhead vs Block Size",GridLines->Automatic,Joined->True,PlotStyle->{colors[[i]],Thick},PlotLegends->None,ScalingFunctions->{"Log10",None}],{i,Length[fabrics]}];Show[plotData,PlotRange->All,PlotLabel->Style["Link Fabric Header Overhead vs Block Size (Log Scale on X)",Bold,14],ImageSize->Large,Frame->True,FrameTicks->{LogTicks[10,{1,2,5}],Automatic},FrameLabel->{"Block Size (Bytes, log scale)","Header Overhead (%)"},PlotLegends->Placed[SwatchLegend[colors,fabrics[[All,1]]],Below]]];
Module[{features={"Reliability","Latency","Jitter","Congestion Control","Packet Loss","RDMA Support","CPU Overhead","Use Case"},ethernetVals={"Best-effort (via TCP)","Millisecond-scale (typical)","High","Optional (DCB/PFC)","Possible","RoCE (complex)","High (software stack)","General networking"},infinibandVals={"Hardware-enforced","Microsecond-scale","Very low","Built-in","Avoided by design","Native","Low (hardware offload)","HPC, AI, low-latency clusters"}},Grid[Prepend[Transpose[{features,ethernetVals,infinibandVals}],Style[{"Feature","Ethernet (traditional)","InfiniBand"},Bold,14]],Frame->All,ItemStyle->Directive[FontFamily->"Arial",FontSize->12],Spacings->{2,1.5},Alignment->Left,Background->{None,{{LightGray,None}}}]];
Module[{nodes={"NIC1","NIC2","NIC3","NIC4","SwitchA","SwitchB"},edges={"NIC1"<->"SwitchA","NIC2"<->"SwitchA","NIC3"<->"SwitchB","NIC4"<->"SwitchB","SwitchA"<->"SwitchB"},g,pos},pos=Association["NIC1"->{0,1},"NIC2"->{0,0},"NIC3"->{3,1},"NIC4"->{3,0},"SwitchA"->{1.5,0.5},"SwitchB"->{2.5,0.5}];g=Graph[edges,VertexLabels->"Name",VertexSize->Medium];Print[Graph[g,VertexCoordinates->pos,PlotLabel->Style["Basic Fabric Topology with NICs and Switches",Bold,16],ImageSize->Large]];GraphicsRow[{Graphics[{Text[Style["Zero-copy RDMA: Direct memory access\nbetween NICs without CPU overhead",12,Blue],{1.5,-0.5}],Arrow[{{0.3,0.5},{1.2,0.5}}]},PlotRange->{{-1,4},{-1,2}},ImageSize->300],Graphics[{Text[Style["Congestion-aware packet spraying\nand adaptive retransmissions",12,DarkGreen],{2.5,-0.5}],Arrow[{{2.8,0.5},{2.0,0.5}}]},PlotRange->{{-1,4},{-1,2}},ImageSize->300]}]];


commModelHierarchy:=Module[{models={"A (Asynchronous)","FIFO","CO (Causal Order)","RSC (Rendezvous/Synchronous)"},pos,edges,labels},pos=Association["A (Asynchronous)"->{0,0},"FIFO"->{1,1},"CO (Causal Order)"->{2,2},"RSC (Rendezvous/Synchronous)"->{3,3}];edges={"RSC (Rendezvous/Synchronous)"->"CO (Causal Order)","CO (Causal Order)"->"FIFO","FIFO"->"A (Asynchronous)"};Graph[models,DirectedEdge@@@List@@@edges,VertexCoordinates->Values[pos],VertexLabels->"Name",GraphStyle->"NameLabeled",EdgeStyle->Arrowheads[0.02],ImageSize->400,PlotLabel->Style["Communication Model Inclusion Hierarchy\nRSC \[Subset] CO \[Subset] FIFO \[Subset] A",Bold,14]]];
headerOverheadData={{"NVLink v3",16,{0.25,0.125,0.0625,0.03125,0.015625}},{"UALink (proj.)",20,{0.313,0.156,0.078,0.039,0.02}},{"Scale-Up Ethernet",8,{0.125,0.063,0.031,0.016,0.008}},{"InfiniBand HDR",64,{1,0.5,0.25,0.125,0.063}},{"Ethernet + IP + TCP",84,{1.438,0.578,0.289,0.145,0.071}}};
blockSizes={64,128,256,512,1024};
headerOverheadChart:=BarChart[Transpose[headerOverheadData[[All,3]]],ChartLabels->Placed[blockSizes,"Below"],ChartLegends->Placed[headerOverheadData[[All,1]],"Right"],BarSpacing->0.5,PlotRange->{0,1.5},Frame->True,FrameLabel->{"Block Size (Bytes)","Header Overhead (Fraction)"},PlotLabel->Style["Header Overhead vs. Block Size for Link Fabrics",Bold,14],ImageSize->600];
featureComparisonData={{"Reliability",{"Best-effort (TCP)","Hardware-enforced"}},{"Latency",{"Milli-second typical","Micro-second typical"}},{"Jitter",{"High","Very low"}},{"Congestion Control",{"Optional (DCB/PFC)","Built-in"}},{"Packet Loss",{"Possible","Avoided by design"}},{"RDMA Support",{"RoCE (complex)","Native"}},{"CPU Overhead",{"High (software stack)","Low (hardware offload)"}},{"Use Case",{"General networking","HPC, AI clusters"}}};
featureComparisonChart:=Grid[Prepend[({#1[[1]],Style[#1[[2,1]],Red],Style[#1[[2,2]],Blue]}&)/@featureComparisonData,{Style["Feature",Bold,14],Style["Ethernet",Bold,14,Red],Style["InfiniBand",Bold,14,Blue]}],Frame->All,Background->{None,{LightYellow,LightCyan}},Spacings->{3,2},Alignment->Left];
Column[{Style["1. Communication Model Hierarchy",Bold,16],commModelHierarchy,Style["2. Header Overhead vs. Block Size",Bold,16],headerOverheadChart,Style["3. Feature Comparison: Ethernet vs InfiniBand",Bold,16],featureComparisonChart},Spacings->3]


Module[{slices=Range[8],txColor=Lighter[Blue,0.3],rxColor=Lighter[Green,0.3],sackColor=Orange,sackLevels={{"Information (SACK 00)",Blue},{"Knowledge (SACK 01)",Green},{"Semantics (SACK 10)",Purple},{"Syntax (SACK 11)",Red}},fullDuplexSlices=Range[8],antGridSize=3,antEdgesCW,antEdgesCCW,beeLength=6,centralGraph,decentralGraph,distributedGraph,hlcEvents,abpStates,forwardState,backwardState,layerCount=5,i},metcalfePlot=Graphics[{Style[Text["6.1 Two Independent Metcalfe Channels",{4.5,5}],Bold,16],Table[{txColor,Rectangle[{i,3.5},{i+0.8,4.5}],Black,Text[Style["TX Slice "<>ToString[i],Bold,12],{i+0.4,4}]},{i,slices}],Table[{rxColor,Rectangle[{i,1.5},{i+0.8,2.5}],Black,Text[Style["RX Slice "<>ToString[i],Bold,12],{i+0.4,2}]},{i,slices}],Style[Text["Transmit Pipeline",{0.5,4.8}],Italic,14,Blue],Style[Text["Receive Pipeline",{0.5,2.8}],Italic,14,Green]},PlotRange->{{0.5,8.5},{1,5}},ImageSize->600,Axes->False];sackFeedbackPlot[n_]:=Graphics[{Style[Text["6.1 Internal (SACK) Feedback on Slice "<>ToString[n],{4.5,5}],Bold,16],Table[{txColor,Rectangle[{i,3.5},{i+0.8,4.5}],Black,Text["TX Slice "<>ToString[i],{i+0.4,4}]},{i,slices}],Table[{rxColor,Rectangle[{i,1.5},{i+0.8,2.5}],Black,Text["RX Slice "<>ToString[i],{i+0.4,2}]},{i,slices}],{Red,Thick,Arrowheads[0.03],Arrow[{{n+0.4,4.5},{n+0.4,5.5}}]},{Red,Style[Text["SACK"<>ToString[n],{n+0.4,6}],Bold,16]}},PlotRange->{{0.5,8.5},{1,6.5}},ImageSize->600,Axes->False];fourLevelsPlot=Graphics[{Style[Text["6.2 Architectural Framework: Four Shannon-like Levels",{2.5,5}],Bold,16],Table[{sackLevels[[i,2]],Rectangle[{0,i-1},{5,i}],Black,Text[Style[sackLevels[[i,1]],Bold,14],{2.5,i-0.5}]},{i,Length[sackLevels]}]},PlotRange->{{0,5},{0,4}},ImageSize->400,Axes->False];fullDuplexPlot=Graphics[{Style[Text["6.3 Full-Duplex Bi-pipelined Shannon-Metcalfe Channel",{4.5,6}],Bold,16],Table[{txColor,Rectangle[{i,4},{i+0.8,5}],Black,Text["TX Slice "<>ToString[i],{i+0.4,4.5}]},{i,fullDuplexSlices}],Table[{rxColor,Rectangle[{i,1},{i+0.8,2}],Black,Text["RX Slice "<>ToString[i],{i+0.4,1.5}]},{i,fullDuplexSlices}],Table[{Purple,Arrowheads[0.03],Arrow[{{i+0.4,4},{i+0.4,2}}]},{i,fullDuplexSlices}],Table[Style[Text["SACK "<>ToString[IntegerString[i,2,2]],{1.2+2.4 (i-1),5.4}],Bold,12],{i,1,4}],Table[Style[Text["SACK "<>ToString[IntegerString[5-i,2,2]],{1.2+2.4 (i-1),0.6}],Bold,12],{i,1,4}]},PlotRange->{{0.5,8.5},{0.5,6}},ImageSize->700,Axes->False];antGridPoints=Flatten[Table[{x,y},{x,1,antGridSize},{y,1,antGridSize}],1];antEdgesCW=UndirectedEdge@@@{{1,2},{2,3},{3,6},{6,9},{9,8},{8,7},{7,4},{4,1}};antEdgesCCW=Reverse[antEdgesCW];antClockwiseGraph=Graph[antEdgesCW,VertexCoordinates->antGridPoints,VertexLabels->"Name",EdgeStyle->Blue,PlotLabel->"ANT Clockwise Packet Clock"];antCounterClockwiseGraph=Graph[antEdgesCCW,VertexCoordinates->antGridPoints,VertexLabels->"Name",EdgeStyle->Red,PlotLabel->"ANT Counterclockwise Packet Clock"];beeOutboundPath=Table[{i,1},{i,1,beeLength}];beeReturnPath=Reverse[beeOutboundPath];beePlot=Graphics[{Blue,Thick,Arrow[beeOutboundPath],Red,Thick,Arrow[beeReturnPath],Black,PointSize[Large],Point/@beeOutboundPath,Style[Text["Outbound",{beeLength+0.5,1}],Blue,Bold],Style[Text["Return",{0.5,1}],Red,Bold],Style[Text["6.9 BEE Scouts: Radial Exploration and Return",{beeLength/2,1.5}],Bold,14]},PlotRange->{{0,beeLength+1},{0.5,1.8}},ImageSize->600];centralGraph=Graph[Table[i->0,{i,1,46}],VertexLabels->"Name",GraphLayout->"StarEmbedding",PlotLabel->"Centralized Topology"];decentralGraph=RandomGraph[{47,60},GraphLayout->"SpringElectricalEmbedding",PlotLabel->"Decentralized Topology"];distributedGraph=RandomGraph[{47,98},GraphLayout->"SpringElectricalEmbedding",PlotLabel->"Distributed Topology"];SeedRandom[1234];hlcEvents=Table[{i,RandomReal[{i 5,i 5+2}],RandomInteger[{0,2}]},{i,1,20}];hlcPlot=ListPlot[hlcEvents[[All,{1,2}]],PlotStyle->{PointSize[Medium],Blue},AxesLabel->{"Event Index","HLC Physical Time"},PlotLabel->"6.36 Hybrid Logical Clock: Event Timestamps",ImageSize->600];abpStates={Style["00",Blue],Style["01",Green],Style["11",Red],Style["10",Purple]};abpGraph=Graph[DirectedEdge@@@{{1,2},{2,3},{3,4},{4,3}},VertexLabels->{1->abpStates[[1]],2->abpStates[[2]],3->abpStates[[3]],4->abpStates[[4]]},PlotLabel->"Alternating Bit Protocol (ABP) State Transitions",VertexSize->Large];Column[{metcalfePlot,sackFeedbackPlot[8],sackFeedbackPlot[1],fourLevelsPlot,fullDuplexPlot,GraphicsGrid[{{antClockwiseGraph,antCounterClockwiseGraph}}],beePlot,GraphicsRow[{centralGraph,decentralGraph,distributedGraph},ImageSize->800],hlcPlot,abpGraph},Spacings->3]]


Module[{asyncGraph,fifoGraph,coGraph,rscGraph,fabrics={"NVLink v3","UALink (proj.)","Scale-Up ETH","InfiniBand HDR","Ethernet + IP + TCP"},blockSizes={64,128,256,512,1024},overheadData,compFeatures,compValuesEthernet,compValuesInfiniBand},asyncGraph=Graph[DirectedEdge@@@{{"SendA","RecvB"},{"SendC","RecvD"},{"SendB","RecvC"}},VertexLabels->"Name",GraphStyle->"NameLabeled",ImageSize->300,PlotLabel->"Asynchronous (A) - No Ordering Guarantees"];fifoGraph=Graph[DirectedEdge@@@{{"Send1","Recv1"},{"Send2","Recv2"},{"Send1","Send2"},{"Recv1","Recv2"}},VertexLabels->"Name",GraphStyle->"NameLabeled",ImageSize->300,PlotLabel->"FIFO: Per-Channel Ordering"];coGraph=Graph[DirectedEdge@@@{{"Send1","Recv1"},{"Send2","Recv2"},{"Send1","Send2"},{"Recv1","Recv2"},{"Send1","Recv2"}},VertexLabels->"Name",GraphStyle->"NameLabeled",ImageSize->300,PlotLabel->"Causally Ordered (CO): Global FIFO + Causality"];rscGraph=Graph[DirectedEdge@@@{{"Send1","Recv1"},{"Send2","Recv2"},{"Send1","Recv1"},{"Send2","Recv2"}},VertexLabels->"Name",GraphStyle->"NameLabeled",ImageSize->300,PlotLabel->"RSC: Rendezvous Synchronous Communication"];Print[Style["8.1 Communication Models Hierarchy: RSC \[Subset] CO \[Subset] FIFO \[Subset] A",Bold,16],Grid[{{asyncGraph,fifoGraph},{coGraph,rscGraph}},Spacings->{2,2}]];overheadData={{0.25,0.125,0.0625,0.03125,0.015625},{0.313,0.156,0.078,0.039,0.02},{0.125,0.063,0.031,0.016,0.008},{1.0,0.5,0.25,0.125,0.063},{1.438,0.578,0.289,0.145,0.071}};Print[Style["8.2 Header Overhead vs Block Size",Bold,16],BarChart[Transpose[overheadData],ChartLabels->Placed[ToString/@blockSizes,Below],ChartLegends->fabrics,Frame->True,FrameLabel->{"Block Size (Bytes)","Header Overhead Ratio"},PlotRange->{0,1.6},ImageSize->Large]];compFeatures={"Reliability","Latency","Jitter","Congestion Control","Packet Loss","RDMA Support","CPU Overhead","Primary Use"};compValuesEthernet={"Best-effort (via TCP)","Milliseconds typical","High","Optional (DCB/PFC)","Possible","RoCE (complex)","High (software stack)","General networking"};compValuesInfiniBand={"Hardware-enforced","Microseconds scale","Very low","Built-in","Avoided by design","Native","Low (hardware offload)","HPC, AI, low-latency clusters"};Print[Style["8.5 Ethernet vs InfiniBand Comparison",Bold,16],Grid[Prepend[Transpose[{compFeatures,compValuesEthernet,compValuesInfiniBand}],{"Feature","Ethernet (traditional)","InfiniBand"}],Frame->All,Background->{None,{LightGray,White}},Spacings->{3,1},ItemStyle->Directive[FontFamily->"Arial",FontSize->12]]];]


Module[{hierarchyLabels={"RSC","CO","FIFO","A"},hierarchyColors={Lighter[Blue,0.3],Lighter[Green,0.3],Lighter[Orange,0.3],Lighter[Gray,0.3]},hierarchyPositions,crownCycleGraph,crownCycleEdges,features={"Reliability","Latency","Jitter","Congestion Control","Packet Loss","RDMA Support","CPU Overhead","Primary Use"},ethernetVals={"Best-effort (via TCP)","Millisecond-scale (typical)","High","Optional (DCB/PFC)","Possible","RoCE (complex)","High (software stack)","General networking"},infinibandVals={"Hardware-enforced","Microsecond-scale","Very low","Built-in","Avoided by design","Native","Low (offload)","HPC, AI, low-latency clusters"},ethernetVsIBTable},hierarchyPositions=Table[{i,0},{i,Length[hierarchyLabels]}];hierarchyPlot=Graphics[{Table[{hierarchyColors[[i]],EdgeForm[Black],Rectangle[hierarchyPositions[[i]]-{0.4,0.3},hierarchyPositions[[i]]+{0.4,0.3}],Black,Text[Style[hierarchyLabels[[i]],Bold,14],hierarchyPositions[[i]]]},{i,Length[hierarchyLabels]}],Table[Arrow[{{hierarchyPositions[[i,1]]+0.4,0},{hierarchyPositions[[i+1,1]]-0.4,0}}],{i,Length[hierarchyLabels]-1}]},PlotRange->{{0,Length[hierarchyLabels]+1},{-1,1}},ImageSize->600,Background->White];crownCycleEdges={"s0"->"r0","r0"->"s1","s1"->"r1","r1"->"s2","s2"->"r2","r2"->"s0"};crownCycleGraph=Graph[DirectedEdge@@@List@@@crownCycleEdges,VertexLabels->Placed["Name",Center],GraphStyle->"NameLabeled",EdgeStyle->{Red,Thick},PlotLabel->Style["Crown Dependency Cycle: Blocks Synchronous Realisation",Bold,16],ImageSize->400];ethernetVsIBTable=Grid[Prepend[Table[{Style[features[[i]],Bold],ethernetVals[[i]],infinibandVals[[i]]},{i,Length[features]}],{"Feature","Ethernet (Traditional)","InfiniBand"}],Frame->All,Background->{None,{LightYellow,{None}}},Spacings->{3,2},ItemStyle->Directive[FontFamily->"Arial",FontSize->12]];Column[{hierarchyPlot,crownCycleGraph,Style["8.5 Ethernet vs InfiniBand Feature Comparison",Bold,16],ethernetVsIBTable},Spacings->3]]


Module[{vertices,edges,g,crownCycleVertices,crownCycleEdges},vertices=Flatten[Table[{"s"<>ToString[i],"r"<>ToString[i]},{i,0,3}]];edges=Flatten[Table[{"s"<>ToString[i]\[DirectedEdge]"r"<>ToString[i],"r"<>ToString[i]\[DirectedEdge]"s"<>ToString[Mod[i+1,4]]},{i,0,3}]];crownCycleVertices=vertices;crownCycleEdges=edges;g=Graph[edges,VertexLabels->Placed["Name",Center],DirectedEdges->True,VertexSize->Medium,GraphStyle->"NameLabeled",PlotLabel->Style["Crown Criterion: Alternating Send/Receive Dependency Cycle",Bold,14],ImageSize->600];Show[g,GraphHighlight->crownCycleVertices,GraphHighlightStyle->{Red,Thick}]]
Module[{blockSizes={64,128,256,512,1024},fabrics={"NVLink v3"->{25.0,12.5,6.3,3.1,1.6},"UALink (proj.)"->{31.3,15.6,7.8,3.9,2.0},"Scale-Up ETH"->{12.5,6.3,3.1,1.6,0.8},"InfiniBand HDR"->{100,50,25,12.5,6.3},"Ethernet + IP + TCP"->{143.8,57.8,28.9,14.5,7.1}},colors,plots},colors=ColorData[97,"ColorList"];plots=Table[ListLinePlot[Transpose[{blockSizes,fabrics[[i,2]]}],PlotMarkers->Automatic,Joined->True,PlotStyle->{colors[[i]],Thick},PlotRange->All,AxesLabel->{"Block Size (Bytes)","Header Overhead (%)"},ScalingFunctions->{"Log10",None},PlotLegends->None],{i,Length[fabrics]}];Show[plots,PlotRange->All,Frame->True,FrameLabel->{"Block Size (Bytes, log scale)","Header Overhead (%)"},GridLines->Automatic,PlotLabel->Style["Header Overhead vs Block Size for Various Link Fabrics",Bold,14],ImageSize->Large,PlotLegends->Placed[SwatchLegend[colors,fabrics[[All,1]]],Below]]]
Module[{nodes={"NIC_Alice","NIC_Bob","Switch1","Switch2"},edges={"NIC_Alice"<->"Switch1","NIC_Bob"<->"Switch2","Switch1"<->"Switch2"},pos,graph},pos=Association["NIC_Alice"->{0,1},"NIC_Bob"->{3,1},"Switch1"->{1,0},"Switch2"->{2,0}];graph=Graph[edges,VertexLabels->"Name",VertexSize->Medium,DirectedEdges->False,GraphStyle->"NameLabeled"];Show[Graph[graph,VertexCoordinates->pos,PlotLabel->Style["RoCE Deployment: NICs and Switches in Lossless Fabric",Bold,14],ImageSize->Large],Graphics[{Red,Thick,Dashed,Arrow[{{0.5,0.6},{1,0.2}}],Text[Style["PFC / Lossless Fabric Required",Red,Italic,12],{0.5,0.75}]}],Graphics[{Blue,Thick,Arrowheads[0.03],Arrow[{{1.5,0.1},{2,0.1}}],Text[Style["Congestion Control & Flow Control",Blue,Italic,12],{1.75,0.3}]}]]]


commModelHierarchy:=Module[{models={"A (Asynchronous)","FIFO","CO (Causal Order)","RSC (Rendezvous/Synchronous)"},pos,edges},pos=Association["A (Asynchronous)"->{0,0},"FIFO"->{1,1},"CO (Causal Order)"->{2,2},"RSC (Rendezvous/Synchronous)"->{3,3}];edges={"RSC (Rendezvous/Synchronous)"->"CO (Causal Order)","CO (Causal Order)"->"FIFO","FIFO"->"A (Asynchronous)"};Graph[models,DirectedEdge@@@List@@@edges,VertexCoordinates->Values[pos],VertexLabels->Placed["Name",Center],GraphStyle->"NameLabeled",EdgeStyle->Arrowheads[0.03],ImageSize->400,PlotLabel->Style["Communication Model Strict Inclusion Hierarchy\nRSC \[Subset] CO \[Subset] FIFO \[Subset] A",Bold,14]]];
crownCycle:=Module[{n=4,pts,edges,labels,seq},pts=Table[If[EvenQ[i],{Cos[(\[Pi] i)/n],Sin[(\[Pi] i)/n]},{1.2 Cos[(\[Pi] i)/n],1.2 Sin[(\[Pi] i)/n]}],{i,0,2 n-1}];seq=Flatten[Table[{2 i+1,2 i+2},{i,0,n-1}]];edges=Table[Mod[2 i+1,2 n,1]\[DirectedEdge]Mod[2 i+2,2 n,1],{i,0,n-1}];Graphics[{Thick,Blue,Table[Arrow[{pts[[Mod[2 i+1,2 n,1]]],pts[[Mod[2 i+2,2 n,1]]]}],{i,0,n-1}],Red,Table[Text[Style[If[EvenQ[i],"s"<>ToString[i/2],"r"<>ToString[(i-1)/2]],Bold,14],1.1 pts[[i+1]]],{i,0,2 n-1}],Black,Dashed,Arrow[{{0,0},pts[[1]]}],Text[Style["Crown Cycle: Alternating s_i, r_i sequence forming a dependency cycle preventing synchronous realization",Italic,12],{0,-1.6}]},PlotRange->1.5,ImageSize->400,Axes->False]];
headerOverheadData={{"NVLink v3",{0.25,0.125,0.0625,0.03125,0.015625}},{"UALink (proj.)",{0.313,0.156,0.078,0.039,0.02}},{"Scale-Up Ethernet",{0.125,0.063,0.031,0.016,0.008}},{"InfiniBand HDR",{1,0.5,0.25,0.125,0.063}},{"Ethernet + IP + TCP",{1.438,0.578,0.289,0.145,0.071}}};
blockSizes={64,128,256,512,1024};
headerOverheadChart:=BarChart[Transpose[headerOverheadData[[All,2]]],ChartLabels->Placed[blockSizes,"Below"],ChartLegends->Placed[headerOverheadData[[All,1]],"Right"],BarSpacing->0.5,PlotRange->{0,1.5},Frame->True,FrameLabel->{"Block Size (Bytes)","Header Overhead (Fraction)"},PlotLabel->Style["Header Overhead vs. Block Size for Link Fabrics",Bold,14],ImageSize->600];
featureComparisonData={{"Reliability",{"Best-effort (TCP)","Hardware-enforced"}},{"Latency",{"Milli-second typical","Micro-second typical"}},{"Jitter",{"High","Very low"}},{"Congestion Control",{"Optional (DCB/PFC)","Built-in"}},{"Packet Loss",{"Possible","Avoided by design"}},{"RDMA Support",{"RoCE (complex)","Native"}},{"CPU Overhead",{"High (software stack)","Low (hardware offload)"}},{"Use Case",{"General networking","HPC, AI clusters"}}};
featureComparisonChart:=Grid[Prepend[({#1[[1]],Style[#1[[2,1]],Red],Style[#1[[2,2]],Blue]}&)/@featureComparisonData,{Style["Feature",Bold,14],Style["Ethernet",Bold,14,Red],Style["InfiniBand",Bold,14,Blue]}],Frame->All,Background->{None,{LightYellow,LightCyan}},Spacings->{3,2},Alignment->Left];
implGuidanceFITO:=Grid[{{Style["Model",Bold],Style["Implementation Guidance (1992 vintage)",Bold],Style["FITO Perspective",Bold]},{"FIFO","Per-link sequence numbers plus buffering","Progress driven by timeouts and retries (Forward-In-Time-Only thinking)"},{"CO","Vector (or matrix) clocks, handshake I/O buffers forbidding indirect overtakes","Removes physical-time dependence, admits limited reversibility of buffering"},{"RSC","FIFO + per-message ack blocking sender (classic rendezvous)","Collapses send/receive into a single spacetime point, no alternative orders"}},Frame->All,Background->{None,{LightGray,None,LightGray}},Alignment->Left,ItemSize->All];
Column[{Style["1. Communication Model Hierarchy",Bold,16],commModelHierarchy[],Style["2. Crown Dependency Cycle",Bold,16],crownCycle[],Style["3. Header Overhead vs. Block Size",Bold,16],headerOverheadChart[],Style["4. Feature Comparison: Ethernet vs. InfiniBand",Bold,16],featureComparisonChart[],Style["5. Implementation Guidance and FITO Perspective",Bold,16],implGuidanceFITO},Spacings->3,Alignment->Center]


Module[{crownGraph,fabrics={"NVLink","UALink","Scale-Up ETH","InfiniBand","Ethernet"},blockSizes={64,128,256,512,1024},overheadData={{25.0,12.5,6.3,3.1,1.6},{31.3,15.6,7.8,3.9,2.0},{12.5,6.3,3.1,1.6,0.8},{100,50,25,12.5,6.3},{143.8,57.8,28.9,14.5,7.1}},overheadPlot,etInfTable},crownGraph=Graph[{"s0", "r0", "s1", "r1", "s2", "r2"}, {DirectedEdge["s0", "r0"], DirectedEdge["r0", "s1"], DirectedEdge["s1", "r1"], DirectedEdge["r1", "s2"], DirectedEdge["s2", "r2"], DirectedEdge["r2", "s0"]}, {GraphLayout -> "CircularEmbedding", GraphStyle -> "NameLabeled", ImageSize -> 300, PlotLabel -> "Crown Pattern (Dependency Cycle) Prevents Synchrony", VertexLabels -> {"Name"}}];overheadPlot=ListLinePlot[Table[Transpose[{blockSizes,overheadData[[i]]}],{i,Length[fabrics]}],PlotLegends->Placed[fabrics,Above],Frame->True,FrameLabel->{"Block Size (Bytes)","Header Overhead (%)"},PlotRange->All,GridLines->Automatic,PlotMarkers->Automatic,ImageSize->600,PlotLabel->"Header Overhead vs Block Size for Link Fabrics",ScalingFunctions->{"Log10",None}];etInfTable=Grid[Prepend[{{"Reliability","Best-effort (TCP)","Hardware-enforced"},{"Latency","Millisecond-scale","Microsecond-scale"},{"Jitter","High","Very low"},{"Congestion Control","Optional (DCB/PFC)","Built-in"},{"Packet Loss","Possible","Avoided by design"},{"RDMA Support","RoCE (complex)","Native"},{"CPU Overhead","High (software stack)","Low (hardware offload)"},{"Use Case","General networking","HPC / AI clusters"}},{"Feature","Ethernet","InfiniBand"}],Frame->All,Background->{None,{LightGray,White}},ItemStyle->Directive[FontFamily->"Arial",FontSize->12],Spacings->{3,1},Alignment->Left];Column[{Style["Crown Pattern Example (Dependency Cycle)",Bold,14],crownGraph,Style["Header Overhead (%) vs Block Size",Bold,14],overheadPlot,Style["Ethernet vs InfiniBand: Feature Comparison",Bold,14],etInfTable},Spacings->2]]


Module[{alohaDuration=10,alohaPacketWidth=1.5,alohaNodes=3,alohaSlots=5,slottedSlots=5,slottedPacketWidth=1,slottedPackets,slottedCollisions,atmNodes=5,atmEdges,atmGraph,hopByHopPaths,rateBasedPaths,arrowOpts={Arrowheads[0.03],Thick},C=100 10^9,P=64 8,sliceSize=8 8,TpPacket,TpSlice,Troundtrip=10/10^9,Msingle,Msliced,throughputChart},slottedPackets=Table[{i-1,Mod[i,slottedSlots]+1},{i,1,alohaNodes 2}];slottedCollisions=Select[Tuples[Range[Length[slottedPackets]],2],#1[[1]]<#1[[2]]&&slottedPackets[[#1[[1]],1]]==slottedPackets[[#1[[2]],1]]&];Print[Graphics[{Style[Text["Slotted ALOHA",{(slottedSlots-1)/2,alohaNodes+1}],Bold,14],Table[{LightGreen,Rectangle[{slottedPackets[[i,1]],slottedPackets[[i,2]]-0.3},{slottedPackets[[i,1]]+slottedPacketWidth,slottedPackets[[i,2]]+0.3}],Black,Text[ToString["Node "<>ToString[i]],{slottedPackets[[i,1]]+slottedPacketWidth/2,slottedPackets[[i,2]]}]},{i,1,Length[slottedPackets]}],Red,Table[Rectangle[{slottedPackets[[c[[1]],1]],slottedPackets[[c[[1]],2]]-0.3},{slottedPackets[[c[[1]],1]]+slottedPacketWidth,slottedPackets[[c[[1]],2]]+0.3}],{c,slottedCollisions}],Black,Line[{{0,0},{slottedSlots,0}}],Table[{Dashed,Line[{{t,0},{t,alohaNodes+0.5}}]},{t,0,slottedSlots,1}],Table[Text[ToString[t],{t,-0.3}],{t,0,slottedSlots,1}]},ImageSize->500,PlotRange->{{-1,slottedSlots+1},{0,alohaNodes+2}},Axes->False]];atmEdges={1<->2,2<->3,3<->4,4<->5,5<->1};atmGraph=Graph[atmEdges,VertexLabels->"Name",GraphStyle->"NameLabeled",ImageSize->300];hopByHopPaths=Table[Style[Arrow[{{i,i},{Mod[i,atmNodes]+1,Mod[i,atmNodes]+1}}],arrowOpts],{i,atmNodes}];rateBasedPaths=Table[Style[Arrow[{{i,atmNodes+1},{Mod[i,atmNodes]+1,atmNodes+1}}],{Blue,Thick}],{i,atmNodes}];Print[GraphicsRow[{Show[atmGraph,Graphics[{Red,Thick,hopByHopPaths,Text[Style["Hop-by-Hop Flow Control",Bold,14,Red],{atmNodes/2,atmNodes+0.8}]}],PlotRange->{{0,atmNodes+1},{0,atmNodes+2}},ImageSize->400],Show[atmGraph,Graphics[{Blue,Thick,rateBasedPaths,Text[Style["Rate-Based Flow Control",Bold,14,Blue],{atmNodes/2,atmNodes+0.8}]}],PlotRange->{{0,atmNodes+1},{0,atmNodes+2}},ImageSize->400]}]];TpPacket=P/C;TpSlice=sliceSize/C;Msingle=1/(1+Troundtrip/TpPacket);Msliced=1/(1+Troundtrip/(8 TpSlice));throughputChart=BarChart[{Msingle,Msliced},ChartLabels->{"Single Packet (64B stop-and-wait)","Sliced Packets (8B sub-ACK)"},PlotLabel->"Multiplexing Factor (Effective Link Utilization)",Frame->True,FrameLabel->{"Protocol Type","Utilization"},ImageSize->Large,PlotRange->{0,1}];Print[throughputChart];]


hopByHopGraph=Graph[{"Switch 1", "Switch 2", "Switch 3", "Switch 4"}, {UndirectedEdge["Switch 1", "Switch 2"], UndirectedEdge["Switch 2", "Switch 3"], UndirectedEdge["Switch 3", "Switch 4"]}, {EdgeStyle -> {Red}, GraphStyle -> "NameLabeled", ImageSize -> Medium, PlotLabel -> Style["ATM Hop-by-Hop Flow Control\n(Local Backpressure)", Bold, 14], VertexLabels -> {"Name"}}];
rateBasedGraph=Graph[{"Source", "Switch 1", "Switch 2", "Switch 3", "Destination"}, {DirectedEdge["Source", "Switch 1"], DirectedEdge["Switch 1", "Switch 2"], DirectedEdge["Switch 2", "Switch 3"], DirectedEdge["Switch 3", "Destination"], DirectedEdge["Destination", "Source"]}, {EdgeStyle -> {Blue}, GraphStyle -> "NameLabeled", ImageSize -> Medium, PlotLabel -> Style["ATM Rate-Based Flow Control\n(End-to-End Feedback)", Bold, 14], VertexLabels -> {"Name"}}];
channelCapacity=100 10^9;
packetSizeBytes=64;
packetSizeBits=packetSizeBytes 8;
ackSizeBytes=8;
ackSizeBits=ackSizeBytes 8;
distance_m=1.6;
propagationSpeed=3 10^8;
oneWayDelay_s=distance_m/propagationSpeed;
roundTripDelay_s=2 oneWayDelay_s;
tp=packetSizeBits/channelCapacity;
T=roundTripDelay_s+ackSizeBits/channelCapacity;
multiplexFactor=1/(1+T/tp);
throughputText=Grid[{{"Packet size (bits):",packetSizeBits},{"Channel capacity (bps):",channelCapacity},{"One-way delay (s):",NumberForm[oneWayDelay_s,{4,10}]},{"Round-trip delay (s):",NumberForm[roundTripDelay_s,{4,10}]},{"Packet transmit time (s):",NumberForm[tp,{4,10}]},{"Timeout T (s):",NumberForm[T,{4,10}]},{"Multiplexing factor M:",NumberForm[multiplexFactor,{3,3}]},{"Effective throughput:",NumberForm[(multiplexFactor channelCapacity)/10^9,{3,3}],"Gb/s"}},Frame->All,ItemStyle->Directive[Bold,12]];
sliceSizeBits=64;
sliceTransmitTime=sliceSizeBits/channelCapacity;
slicesPerPacket=packetSizeBits/sliceSizeBits;
sliceTimes=Table[sliceTransmitTime i,{i,0,slicesPerPacket-1}];
ackLatency=2/10^9;
pipelinePlot=Graphics[{Style[LightGreen,Opacity[0.6]],Table[Rectangle[{sliceTimes[[i]],1},{sliceTimes[[i]]+sliceTransmitTime,2}],{i,slicesPerPacket}],Style[Red,PointSize[Large]],Table[Point[{sliceTimes[[i]]+ackLatency,1.5}],{i,slicesPerPacket}],Text["Packet sliced into 8-byte slices",{0,2.5}],Text["Each slice has sub-ACK arriving shortly after",{0,0.5}]},PlotRange->{{0,Max[sliceTimes]+5 sliceTransmitTime},{0,3}},Axes->True,AxesLabel->{"Time (s)",""},ImageSize->Large];
features={"Reliability","Latency","Jitter","Congestion Control","Packet Loss","RDMA Support","CPU Overhead","Primary Use Case"};
ethernetVals={"Best-effort (via TCP)","Millisecond-scale (typical)","High","Optional (DCB/PFC)","Possible","RoCE (complex)","High (software stack)","General networking"};
infinibandVals={"Hardware-enforced","Microsecond-scale","Very low","Built-in","Avoided by design","Native","Low (hardware offload)","HPC, AI, low-latency clusters"};
featureComparisonTable=Grid[Prepend[MapThread[{#1,#2,#3}&,{features,ethernetVals,infinibandVals}],{"Feature","Ethernet (traditional)","InfiniBand"}],Frame->All,Background->{None,{LightGray,White}},Spacings->{2,1},ItemStyle->Directive[FontFamily->"Arial",FontSize->12],Alignment->Left,Dividers->All,BaseStyle->Directive[Bold]];
Column[{Style["9.2 ATM Flow Control Models",Bold,16],Row[{hopByHopGraph,Spacer[20],rateBasedGraph}],Style["9.3 Metcalfe Throughput Model Example",Bold,16],throughputText,Style["9.4 Packet Subdivision into 8-byte Slices & Sub-ACK Pipelining",Bold,16],pipelinePlot,Style["9.5 Ethernet vs InfiniBand Feature Comparison",Bold,16],featureComparisonTable},Spacings->3,Alignment->Center]


Module[{atmNodes,atmEdges,atmGraph,ethernetLossProb=0.05,infinibandLossProb=0.001,ethernetPacketCount=100,infinibandPacketCount=100,ethernetDrops,infinibandDrops,throughputMetcalfe,P=512,C=100 10^9,A=64,d=4/10^9,tTx,Tvals,Mvals,effCapacityVals,sliceSize=64,Tslice,slicePipelineUtilization},atmNodes={"Source","Switch1","Switch2","Destination"};atmEdges=DirectedEdge@@@{{"Source","Switch1"},{"Switch1","Switch2"},{"Switch2","Destination"}};atmGraph=Graph[atmEdges,VertexLabels->"Name",GraphStyle->"NameLabeled",EdgeStyle->Arrowheads[Medium],ImageSize->Large,PlotLabel->Style["ATM Flow Control: Hop-by-Hop (local backpressure) vs Rate-Based (end-to-end feedback)",Bold,14]];ethernetDrops=RandomChoice[{1-ethernetLossProb,ethernetLossProb}->{False,True},ethernetPacketCount];infinibandDrops=RandomChoice[{1-infinibandLossProb,infinibandLossProb}->{False,True},infinibandPacketCount];ethernetLossGraphic=BarChart[{Count[ethernetDrops,True],Count[ethernetDrops,False]},ChartLabels->{"Dropped","Delivered"},ChartStyle->{Red,Green},PlotLabel->Style["Ethernet Packet Loss (Simulated)",Bold,14],ImageSize->Medium];infinibandLossGraphic=BarChart[{Count[infinibandDrops,True],Count[infinibandDrops,False]},ChartLabels->{"Dropped","Delivered"},ChartStyle->{Red,Green},PlotLabel->Style["InfiniBand Packet Loss (Simulated)",Bold,14],ImageSize->Medium];tTx=P/C;Tvals=Range[0.1/10^8,3/10^8,0.1/10^9];Mvals=1/(1+Tvals/tTx);effCapacityVals=Mvals (1-0.01) C;throughputMetcalfe=ListLinePlot[Transpose[{Tvals 10^9,effCapacityVals/10^9}],PlotRange->All,Frame->True,FrameLabel->{"Timeout + RTT (ns)","Effective Capacity (Gbps)"},PlotLabel->Style["Metcalfe Throughput Model: Effect of Timeout/RTT on Capacity",Bold,14],ImageSize->Large];Tslice=sliceSize/C;slicePipelineUtilization=Table[1/(1+Tvals[[i]]/(Tslice window)),{i,Length[Tvals]},{window,{1,4,8}}];slicePlot=ListLinePlot[Table[Transpose[{Tvals 10^9,(slicePipelineUtilization[[All,w]] C)/10^9}],{w,1,3}],PlotLegends->{"1 slice (stop-and-wait)","4 slices","8 slices"},Frame->True,FrameLabel->{"Timeout + RTT (ns)","Effective Capacity (Gbps)"},PlotLabel->Style["Throughput Improvement with Packet Slicing and Sub-ACKs",Bold,14],ImageSize->Large];Column[{atmGraph,Grid[{{ethernetLossGraphic,infinibandLossGraphic}}],throughputMetcalfe,slicePlot},Spacings->3]]


alohaComparisonData={{"Feature","ALOHA","Slotted ALOHA"},{"Time structure","Any time","Slot-aligned"},{"Collision probability","High","Lower"},{"Efficiency (max)","\[Tilde]18% (1/2e)","\[Tilde]37% (1/e)"},{"Implementation complexity","Simple","Needs synchronization"},{"Analogy","Random shouting","Timed shouting"}};
alohaComparisonTable:=Grid[Map[If[#1===alohaComparisonData[[1]],Style[#1,Bold,14],#1]&,alohaComparisonData,{2}],Frame->All,Background->{None,{LightYellow,LightCyan}},Alignment->Center,Spacings->{3,2}];
alohaVisual:=Module[{alohaPackets,slottedPackets,drawPacket},drawPacket[{start_,dur_},y_,col_]:=Rectangle[{start,y-0.4},{start+dur,y+0.4},RoundingRadius->0.1];alohaPackets={{0.1,0.8},{0.7,0.9},{1.4,0.6},{1.8,0.7},{2.2,0.9}};slottedPackets={{0,1},{1,1},{2,1},{3,1},{4,1}};GraphicsGrid[{{Graphics[{LightBlue,EdgeForm[Black],Table[drawPacket[p,1.5,LightBlue],{p,alohaPackets}],Red,Style[Text["Collisions (overlaps)",1.5 {1,0.8}],Bold,14],Black,Style[Text["ALOHA: Uncoordinated Transmission",1.5 {1.5,2.5}],Bold,16]},PlotRange->{{0,3},{0,3}},ImageSize->400],Graphics[{LightGreen,EdgeForm[Black],Table[drawPacket[p,1.5,LightGreen],{p,slottedPackets}],Black,Style[Text["Slotted ALOHA: Slot-aligned Transmissions",1.5 {2,2.5}],Bold,16]},PlotRange->{{0,5},{0,3}},ImageSize->400]}},Spacings->{3,2}]];
throughputFormula:=Grid[{{Style["Throughput Formula Components",Bold,14,Blue]},{"Effective Capacity (E):",Row[{Style["S/P \[Times] 1/(1 + C T / P) \[Times] (1 - L) \[Times] C",Italic]," where: ",Style["C",Bold]," = channel capacity (bits/s), ",Style["P",Bold]," = packet length (bits), ",Style["S",Bold]," = payload bits, ",Style["L",Bold]," = packet loss probability, ",Style["T",Bold]," = transmitter timeout (RTT + ACK time)"}]},{"Multiplexing factor M:",Style["M = 1 / (1 + T/T_p), with T_p = P/C",Italic]},{"Explanation:","Throughput is limited by stop-and-wait delays unless multiple packets or slices are pipelined."}},Alignment->Left,Spacings->{2,2}];
Column[{Style["1. ALOHA vs Slotted ALOHA Comparison Table",Bold,16],alohaComparisonTable,Style["2. Visual Comparison of ALOHA vs Slotted ALOHA Transmission",Bold,16],alohaVisual,Style["3. Throughput Formula and Key Parameters",Bold,16],throughputFormula},Spacings->3]


Module[{alohaTable,alohaVisual},alohaTable=Grid[{{"Feature","ALOHA","Slotted ALOHA"},{"Time Structure","Any time","Slot-aligned"},{"Collision Probability","High","Lower"},{"Efficiency (max)","\[TildeTilde] 18% (1/2e)","\[TildeTilde] 37% (1/e)"},{"Implementation Complexity","Simple","Needs synchronization"},{"Analogy","Random shouting","Timed shouting"}},Frame->All,Background->{None,{LightYellow,White}},ItemStyle->Directive[FontFamily->"Arial",FontSize->12],Alignment->Center];alohaVisual=Graphics[{Style[Text["ALOHA vs Slotted ALOHA Collisions",{5,5.5}],Bold,14],Black,Line[{{1,1},{9,1}}],Text["Time",{9.5,1}],Line[{{1,3},{9,3}}],Text["Time Slots",{9.5,3}],Style[Red,Opacity[0.6]],Rectangle[{1.5,0.7},{3,1.3}],Rectangle[{2.5,0.7},{4,1.3}],Rectangle[{4.2,0.7},{5.5,1.3}],Style[Blue,Opacity[0.6]],Rectangle[{1,2.7},{2,3.3}],Rectangle[{3,2.7},{4,3.3}],Rectangle[{5,2.7},{6,3.3}],Gray,Dashed,Table[Line[{{x,2.5},{x,3.5}}],{x,1,7}],Style[Text["ALOHA",{8,1}],Red,Bold],Style[Text["Slotted ALOHA",{8,3}],Blue,Bold]},ImageSize->600];Column[{Style["9.1 ALOHA vs Slotted ALOHA",Bold,16],alohaTable,alohaVisual},Spacings->2]]


Module[{timelineEvents={{"1960s","ALOHA Protocol","Pure random access, high collisions (~18% efficiency)"},{"1972","Slotted ALOHA","Time-slotted transmissions, reduced collisions (~37% efficiency)"},{"1990s","ATM Debate","Hop-by-Hop vs Rate-Based Flow Control; tradeoffs for QoS"},{"Late 1990s","Ethernet Evolution","Best-effort, layered reliability, TCP recovery"},{"2000s","InfiniBand Emerges","Hardware reliability, credit-based flow control"},{"Modern","Sub-packet SACK","Granular ACKs mitigate stop-and-wait throughput loss"}},timelineGraphics,timelineSpacing=3,stopWaitDiagram,sackDiagram,Tp=5.12*^-9,Tslice=0.64*^-9,Tvals,Mvals,throughputPlot},timelineGraphics=Graphics[{Table[{Black,Line[{{i,0},{i,1}}],Text[Style[timelineEvents[[i,1]],Bold,14],{i,1.3}],Text[timelineEvents[[i,2]],{i,0.8},{0,-1}],Text[Style[timelineEvents[[i,3]],Italic,10],{i,0.5},{0,-1}]},{i,Length[timelineEvents]}],Thick,Line[{{1,0},{Length[timelineEvents],0}}]},PlotRange->{{0,Length[timelineEvents]+1},{-0.5,2}},ImageSize->900,Axes->False,Background->White];stopWaitDiagram=Graphics[{Style[Text["Stop-and-Wait: Wait for full 64-byte ACK before next packet",{0,2}],Bold,12],Table[{LightBlue,Rectangle[{i,1},{i+1,2}],Black,Text[Style[ToString[64 (i-1)]<>"-"<>ToString[64 i]<>" bytes",Italic,10],{i+0.5,1.5}]},{i,0,3}],Arrow[{{1.5,0.8},{1.5,0.3}}],Text["ACK",{1.5,0}],Dashed,Line[{{0,0.2},{4,0.2}}]},PlotRange->{{0,4},{0,2.5}},ImageSize->500,Background->White];sackDiagram=Graphics[{Style[Text["SACK: Pipeline 8-byte slices with individual ACKs",{0,2}],Bold,12],Table[{LightGreen,Rectangle[{i 0.5,1},{(i+1) 0.5,2}],Black,Text[Style[ToString[8 i]<>"-"<>ToString[8 (i+1)]<>" bytes",Italic,10],{(i+0.25) 0.5,1.5}]},{i,0,7}],Table[{Red,Arrowheads[0.03],Arrow[{{(i+0.25) 0.5,0.8},{(i+0.25) 0.5,0.3}}],Text["SACK",{(i+0.25) 0.5,0}]},{i,0,7}],Dashed,Line[{{0,0.2},{4,0.2}}]},PlotRange->{{0,4},{0,2.5}},ImageSize->500,Background->White];Tvals=Range[1,16];Mvals=Table[1/(1+8.64/(10^9 (n Tslice))),{n,Tvals}];throughputPlot=ListLinePlot[Transpose[{Tvals,Mvals}],PlotMarkers->Automatic,PlotRange->{0,1},Frame->True,FrameLabel->{"Slices in Flight (n)","Multiplexing Factor M"},PlotLabel->Style["Throughput Gain vs Number of In-flight Slices",Bold,14],GridLines->Automatic,ImageSize->600];Column[{Style["9. History \[LongDash] Visual Overview and Insights",Bold,18],timelineGraphics,Spacer[30],Style["9.3.10-9.3.13: Stop-and-Wait vs Structured SACK",Bold,16],Row[{stopWaitDiagram,Spacer[40],sackDiagram}],Spacer[30],throughputPlot},Spacings->4]]


Module[{linkCapacity=100 10^9,packetSizeBits=64 8,sliceSizeBits=8 8,roundTripTime=10/10^9,TpPacket,TpSlice,Msingle,Msliced,throughputChart,conveyorLength=20,belts,beltLabels,events={"A","B"},indefiniteOrderGraphics,lamportGraph,indefiniteGraph,zeroBasedPlot,oneBasedPlot},TpPacket=packetSizeBits/linkCapacity;TpSlice=sliceSizeBits/linkCapacity;Msingle=1/(1+roundTripTime/TpPacket);Msliced=1/(1+roundTripTime/(8 TpSlice));throughputChart=BarChart[{Msingle,Msliced},ChartLabels->{"Stop-and-Wait (64B packet)","Pipelined Slices (8B sub-ACK)"},PlotLabel->Style["Multiplexing Factor: Throughput Improvement",Bold,14],Frame->True,FrameLabel->{"Protocol","Utilization"},ImageSize->450,PlotRange->{0,1}];belts=Table[{GrayLevel[0.7],Rectangle[{i,1},{i+3,2}]},{i,0,conveyorLength,4}];beltLabels=Table[Text[Style[If[Mod[i,8]==0,"Time"," "],Italic,12],{i+1.5,1.5}],{i,0,conveyorLength,4}];conveyorBelt=Graphics[{belts,beltLabels,Text[Style["Conveyor Belt Metaphor for Time Flow",Bold,14],{conveyorLength/2,2.5}],Arrowheads[0.03],Arrow[{{0,2.3},{conveyorLength+1,2.3}}],Text["Past",{-1,2.3}],Text["Future",{conveyorLength+1.5,2.3}]},PlotRange->{{-2,conveyorLength+3},{0.5,3}},ImageSize->450];indefiniteOrderGraphics=Graphics[{Style[Text["Event A"],{1,3},Bold,Blue],Style[Text["Event B"],{4,3},Bold,Blue],Style[Arrow[{{1.2,2.5},{3.8,2.5}}],Red,Thick,Dashed],Style[Arrow[{{3.8,2},{1.2,2}}],Purple,Thick,Dashed],Text[Style["A \[RightArrow] B",Red,Italic],{2.5,2.7}],Text[Style["B \[RightArrow] A",Purple,Italic],{2.5,1.7}],Text[Style["Indefinite Causal Order: No fixed event sequence",Bold,14],{2.5,3.8}]},PlotRange->{{0,5},{1.5,4}},ImageSize->450,Axes->False];lamportGraph=Graph[{1, 2, 3}, {DirectedEdge[1, 2], DirectedEdge[2, 3]}, {GraphStyle -> "NameLabeled", ImageSize -> 250, PlotLabel -> Style["Lamport Logical Time: Definite Causal Order", Bold, 12], VertexLabels -> {"Name"}}];indefiniteGraph=Graph[{1, 2, 3}, {UndirectedEdge[1, 2], UndirectedEdge[2, 3]}, {GraphStyle -> "NameLabeled", ImageSize -> 250, PlotLabel -> Style["Indefinite Causal Order: Superposed Event Sequences", Bold, 12], VertexLabels -> {"Name"}}];zeroBasedPlot=Grid[{{Style["Zero-based Indexing",Bold,14],\[SpanFromLeft]},{"Index:",Style[Row[Range[0,4],", "],Bold]},{"Value:",Row[{"a","b","c","d","e"},", "]}},Frame->All,Spacings->{2,1},Background->{None,{LightYellow,None}},ItemSize->All,Alignment->Center];oneBasedPlot=Grid[{{Style["One-based Indexing",Bold,14],\[SpanFromLeft]},{"Index:",Style[Row[Range[1,5],", "],Bold]},{"Value:",Row[{"a","b","c","d","e"},", "]}},Frame->All,Spacings->{2,1},Background->{None,{LightCyan,None}},ItemSize->All,Alignment->Center];Column[{throughputChart,Spacer[10],conveyorBelt,Spacer[10],indefiniteOrderGraphics,Spacer[10],Row[{lamportGraph,Spacer[20],indefiniteGraph}],Spacer[10],zeroBasedPlot,Spacer[5],oneBasedPlot},Spacings->10]]


Module[{packetSize=64,sliceSize=8,numSlices=8,timelineEvents={{"Event A",1},{"Event B",2},{"Event C",3}},boldStyle=Style[#1,Bold,14]&,italicStyle=Style[#1,Italic,12]&,pipelineDiagram,causalTimeline,conceptComparison},pipelineDiagram=Graphics[{Text[Style["64-Byte Packet",Bold,16],{4,1.3}],LightGray,Rectangle[{0,0},{8,1}],Black,Thick,Table[{White,Rectangle[{i,0},{i+1,1}],Black,Text[Style[ToString[sliceSize i]<>"-"<>ToString[sliceSize (i+1)]<>" bytes",Italic,10],{i+0.5,0.5}]},{i,0,numSlices-1}],Table[{Red,Arrowheads[0.03],Arrow[{{i+0.5,-0.2},{i+0.5,-0.7}}],Text[Style["SACK",Italic,10,Red],{i+0.5,-0.85}]},{i,0,numSlices-1}]},PlotRange->{{0,8},{-1,1.5}},ImageSize->600,Background->White,Axes->False];causalTimeline=Graphics[{Text[Style["Deterministic Logical Time (Lamport Clocks)",Bold,14,Black],{2,0.5}],Black,Thick,Line[{{0,0},{4,0}}],Table[{Black,Disk[{i,0},0.1],Text[Style[timelineEvents[[i,1]],Bold,12],{i,-0.3}],Text[Style["Time "<>ToString[timelineEvents[[i,2]]],Italic,10],{i,0.3}]},{i,Length[timelineEvents]}],Text[Style["Indefinite Causal Order (Quantum)",Bold,14,Blue],{8,1.2}],Blue,Thick,Line[{{6,0.7},{10,0.7}}],Table[{Blue,Opacity[0.4],Disk[{7+i,0.7},0.3]},{i,0,2}],Text[Style["Events A, B, C in superposition of orders",Italic,10,Blue],{8.5,1.7}]},PlotRange->{{-1,11},{-1,2}},ImageSize->700,Background->White,Axes->False];conceptComparison=Grid[{{boldStyle["Aspect"],boldStyle["Deterministic Logical Time"],boldStyle["Indefinite Causal Order"]},{"Event Ordering","Definite, total or partial order via happens-before relation","Indefinite, superposition of orders; no fixed before/after until measurement"},{"Causality","Strict, linear and consistent across processes","Probabilistic, non-linear, context-dependent"},{"Applicability","Distributed Systems, Lamport clocks, Vector clocks","Quantum Computing, Quantum SWITCH, fundamental quantum processes"},{"Temporal Model","Linear timeline or logical clock sequence","Nonlinear, superposed, potentially cyclic or ambiguous"},{"Example Use Cases","Ensuring causal consistency in distributed databases","Quantum protocols exploiting causal superposition for computational advantage"}},Frame->All,Alignment->Left,ItemStyle->Directive[FontFamily->"Arial",FontSize->12]];Column[{Style["Chapter 10: Theory \[LongDash] Granular Packets, Time, and Causality",Bold,20],Spacer[20],pipelineDiagram,Spacer[40],causalTimeline,Spacer[40],Style["Conceptual Comparison: Deterministic Logical Time vs Indefinite Causal Order",Bold,16],conceptComparison},Spacings->3]]


channelCapacity=100 10^9;
packetSizeBits=512;
sliceSizeBits=64;
sliceTransmitTime=sliceSizeBits/channelCapacity;
slicesPerPacket=packetSizeBits/sliceSizeBits;
ackLatency=2/10^9;
sliceTimes=Table[sliceTransmitTime i,{i,0,slicesPerPacket-1}];
slicePipelinePlot=Graphics[{Style[LightGreen,Opacity[0.6]],Table[Rectangle[{sliceTimes[[i]],1},{sliceTimes[[i]]+sliceTransmitTime,2}],{i,slicesPerPacket}],Style[Red,PointSize[Large]],Table[Point[{sliceTimes[[i]]+ackLatency,1.5}],{i,slicesPerPacket}],Text[Style["Packet subdivided into 8-byte slices",Bold,14],{0,2.5},Left],Text[Style["Sub-ACKs arrive shortly after each slice",Italic,12],{0,0.5},Left]},PlotRange->{{0,Max[sliceTimes]+5 sliceTransmitTime},{0,3}},Axes->True,AxesLabel->{"Time (s)",""},ImageSize->Large];
classicalBelt=Graphics[{Thick,Black,Arrowheads[0.03],Arrow[{{0,0},{10,0}}],Text[Style["Classical Linear Time Conveyor Belt",Bold,14],{5,0.7}],Table[{Blue,Disk[{i,0},0.15]},{i,1,9}]},PlotRange->{{-1,11},{-1,1}},ImageSize->Medium];
indefiniteBelt=Graphics[{Thick,Black,Arrowheads[0.03],Arrow[{{0,0},{4,0}}],Arrow[{{4,0},{8,0}}],Arrow[{{4,0},{4,3}}],Arrow[{{4,3},{8,3}}],Arrow[{{8,0},{8,3}}],Arrow[{{8,3},{10,1.5}}],Blue,Disk[{1,0},0.15],Blue,Disk[{4,0},0.15],Blue,Disk[{4,3},0.15],Blue,Disk[{8,0},0.15],Blue,Disk[{8,3},0.15],Blue,Disk[{10,1.5},0.15],Text[Style["Indefinite Causal Order\n(Branching/Looping Time)",Bold,14],{5,3.5}]},PlotRange->{{-1,11},{-1,4}},ImageSize->Medium];
lamportGraph=Graph[{"E1", "E2", "E3"}, {DirectedEdge["E1", "E2"], DirectedEdge["E2", "E3"], DirectedEdge["E1", "E3"]}, {GraphStyle -> "NameLabeled", ImageSize -> Medium, PlotLabel -> Style["Lamport Logical Time:\nStrict Causal Ordering", Bold, 14], VertexLabels -> {"Name"}}];
indefiniteCausalGraph=Graph[{"E1", "E2", "E3"}, {UndirectedEdge["E1", "E2"], UndirectedEdge["E2", "E3"], UndirectedEdge["E1", "E3"]}, {EdgeStyle -> {Dashed}, GraphStyle -> "NameLabeled", ImageSize -> Medium, PlotLabel -> Style["Indefinite Causal Order:\nSuperposed/Uncertain Ordering", Bold, 14], VertexLabels -> {"Name"}}];
Column[{Style["10.2.14 Packet Slicing & Sub-ACK Pipelining",Bold,16],slicePipelinePlot,Style["10.6 Conveyor Belt Metaphor",Bold,16],Row[{classicalBelt,Spacer[30],indefiniteBelt}],Style["10.6.6 Lamport Logical Time vs Indefinite Causal Order",Bold,16],Row[{lamportGraph,Spacer[30],indefiniteCausalGraph}]},Spacings->3,Alignment->Center]


Module[{sliceCount=8,sliceWidth=1,sliceHeight=0.8,sliceSpacing=0.2,ackWidth=0.6,ackHeight=0.4,txBaseY=2,ackBaseY=1,arrows,slices,acks},slices=Table[{Style[Blue,Opacity[0.7]],Rectangle[{i (sliceWidth+sliceSpacing),txBaseY},{i (sliceWidth+sliceSpacing)+sliceWidth,txBaseY+sliceHeight}],Text[Style[ToString[i],White,Bold],{i (sliceWidth+sliceSpacing)+sliceWidth/2,txBaseY+sliceHeight/2}]},{i,0,sliceCount-1}];acks=Table[{Style[Green,Opacity[0.7]],Rectangle[{i (sliceWidth+sliceSpacing)+sliceWidth/2,ackBaseY},{i (sliceWidth+sliceSpacing)+sliceWidth/2+ackWidth,ackBaseY+ackHeight}],Text[Style["ACK"<>ToString[i],White,Bold],{i (sliceWidth+sliceSpacing)+sliceWidth/2+ackWidth/2,ackBaseY+ackHeight/2}]},{i,0,sliceCount-1,2}];arrows=Table[Arrow[{{i (sliceWidth+sliceSpacing)+sliceWidth/2,txBaseY},{i (sliceWidth+sliceSpacing)+sliceWidth/2+ackWidth/2,ackBaseY+ackHeight}}],{i,0,sliceCount-1,2}];Graphics[{Style[Text["Pipelined 8-Byte Slices with Sub-ACKs (SACKs)",{4,txBaseY+1}],Bold,14],slices,acks,arrows,Black,Line[{{-sliceSpacing,txBaseY},{sliceCount (sliceWidth+sliceSpacing),txBaseY}}],Black,Line[{{-sliceSpacing,ackBaseY+ackHeight},{sliceCount (sliceWidth+sliceSpacing),ackBaseY+ackHeight}}],Text["Transmitter \[RightArrow]",{-sliceSpacing+0.1,txBaseY+sliceHeight/2}],Text["Receiver \[LeftArrow]",{-sliceSpacing+0.1,ackBaseY+ackHeight/2}]},ImageSize->700,PlotRange->{{-sliceSpacing,sliceCount (sliceWidth+sliceSpacing)+1},{0,txBaseY+2}}]]


Module[{P=512,sliceSize=64,C=100 10^9,Tvals,tTx,Tslice,Mvals,MvalsSliced,effCapacityRaw,effCapacitySliced,sliceWindowSizes={1,4,8},timelineStopWait,timelinePipelined,timelineHeight=1,icoGraph,icoVertices,icoEdges,conveyorBeltPlot,beltLength=10,beltSpeed=1},tTx=P/C;Tslice=sliceSize/C;Tvals=Range[0.1/10^8,3/10^8,0.1/10^9];Mvals=1/(1+Tvals/tTx);MvalsSliced=Table[1/(1+Tvals/(Tslice w)),{w,sliceWindowSizes}];effCapacityRaw=Mvals C;effCapacitySliced=MvalsSliced C;throughputPlot=ListLinePlot[Join[{Transpose[{Tvals 10^9,effCapacityRaw/10^9}]},Table[Transpose[{Tvals 10^9,effCapacitySliced[[w]]/10^9}],{w,Length[sliceWindowSizes]}]],PlotRange->All,Frame->True,FrameLabel->{"Timeout + RTT (ns)","Effective Capacity (Gbps)"},PlotLegends->Placed[Join[{"Stop-and-Wait (1 slice)"},Table[ToString[w]<>" slices",{w,sliceWindowSizes}]],Above],PlotLabel->Style["Throughput Improvement with Packet Slicing and Sub-ACKs",Bold,14],ImageSize->Large];timelineStopWait=Graphics[{Blue,Rectangle[{0,-(timelineHeight/2)},{tTx 10^9,timelineHeight/2}],Text[Style["Full Packet\nTransmission",Blue,Bold],{(tTx 10^9)/2,0}]},PlotRange->{{0,12},{-1,1}},Axes->True,AxesLabel->{"Time (ns)",None},ImageSize->Medium];timelinePipelined=Graphics[Join[Table[{Green,Rectangle[{(i-1) Tslice 10^9,-(timelineHeight/2)},{i Tslice 10^9,timelineHeight/2}]},{i,1,8}],{Text[Style["8 Slices with Sub-ACK Pipeline",Green,Bold],{4 Tslice 10^9,0}]}],PlotRange->{{0,12},{-1,1}},Axes->True,AxesLabel->{"Time (ns)",None},ImageSize->Medium];icoVertices={"Event A","Event B"};icoEdges={Style["Event A"\[DirectedEdge]"Event B",Blue,Thick],Style["Event B"\[DirectedEdge]"Event A",Red,Thick,Dashed]};icoGraph=Graph[icoVertices,icoEdges,VertexLabels->"Name",GraphLayout->"CircularEmbedding",PlotLabel->Style["Indefinite Causal Order: Superposed Event Sequences",Bold,14],ImageSize->Medium];conveyorBeltPlot=Graphics[{Thick,Black,Line[{{0,0},{beltLength,0}}],Table[{GrayLevel[0.7-0.06 i],Rectangle[{i,-0.2},{i+0.8,0.2}]},{i,0,beltLength-1,1}],Red,Arrowheads[0.04],Arrow[{{0,0.1},{beltLength,0.1}}],Text[Style["Conveyor Belt of Time (Forward Direction)",Red,Bold,14],{beltLength/2,0.5}]},PlotRange->{{-1,beltLength+1},{-1,1}},ImageSize->Medium];Column[{throughputPlot,Row[{timelineStopWait,Spacer[20],timelinePipelined}],icoGraph,conveyorBeltPlot},Spacings->3]]


packetSlicingGraphics:=Module[{sliceCount=8,sliceWidth=0.8,sliceHeight=1,ackArrowHeight=0.7,sliceColors,ackColors},sliceColors=Table[Blend[{LightBlue,Blue},i/sliceCount],{i,1,sliceCount}];ackColors=Table[Blend[{LightRed,Red},i/sliceCount],{i,1,sliceCount}];Graphics[{Table[{sliceColors[[i]],EdgeForm[Black],Rectangle[{i-1,1},{i-1+sliceWidth,1+sliceHeight}],Black,Text[Style[ToString[i],Bold,14],{i-1+sliceWidth/2,1+sliceHeight/2}]},{i,1,sliceCount}],Table[{ackColors[[i]],Arrowheads[0.03],Arrow[{{i-1+sliceWidth/2,1},{i-1+sliceWidth/2,1-ackArrowHeight}}]},{i,1,sliceCount}],Text[Style["64-byte Packet split into eight 8-byte slices",Bold,16,DarkBlue],{sliceCount/2,2.5}],Text[Style["Sub-ACKs acknowledge slices, allowing pipelined transmissions.",Italic,12],{sliceCount/2,-0.2}],Text[Style["Throughput improves by keeping multiple slices in flight during RTT.",Italic,12],{sliceCount/2,-0.7}]},PlotRange->{{-1,sliceCount},{-1,3}},ImageSize->600,Axes->False]];
conveyorBeltGraphics:=Module[{beltLength=8,classicalBeltY=2.5,quantumBeltY=0},Graphics[{Text[Style["Classical Time Flow (Conveyor Belt)",Bold,14,DarkGreen],{beltLength/2,3.8}],Brown,Thick,Rectangle[{0,classicalBeltY-0.3},{beltLength,classicalBeltY+0.3}],Arrowheads[0.04],Arrow[{{0,classicalBeltY},{beltLength,classicalBeltY}}],Table[{Blue,Disk[{i-0.5,classicalBeltY},0.2],Black,Text[Style[ToString[i],Bold,12],{i-0.5,classicalBeltY+0.4}]},{i,1,beltLength}],Text[Style["Indefinite Causal Order (Quantum)",Bold,14,DarkRed,Italic],{beltLength/2,1.8}],Brown,Thick,Line[{{0,quantumBeltY},{4,quantumBeltY},{5,quantumBeltY+1},{beltLength,quantumBeltY+1}}],Line[{{4,quantumBeltY},{5,quantumBeltY-1},{beltLength,quantumBeltY-1}}],Red,Disk[{1,quantumBeltY},0.2],Text[Style["A",Bold,12],{1,quantumBeltY+0.4}],Disk[{3,quantumBeltY},0.2],Text[Style["B",Bold,12],{3,quantumBeltY+0.4}],Disk[{6,quantumBeltY+1},0.2],Text[Style["C",Bold,12],{6,quantumBeltY+1.4}],Disk[{6,quantumBeltY-1},0.2],Text[Style["D",Bold,12],{6,quantumBeltY-1.4}]},PlotRange->{{-1,beltLength+1},{-2,4.5}},ImageSize->600,Axes->False]];
logicalVsIndefinite:=Module[{timelineLength=6,lamportEvents,indefiniteEvents,overlaps},lamportEvents=Table[{i+0.5,2.5},{i,0,timelineLength-1}];indefiniteEvents=Table[{i+0.5,1},{i,0,timelineLength-1}];Graphics[{Text[Style["Lamport Logical Time (Deterministic order)",Bold,14,DarkBlue],{timelineLength/2,3.5}],Black,Thick,Arrowheads[0.03],Arrow[{{0,2.5},{timelineLength,2.5}}],Table[{Blue,Disk[lamportEvents[[i]],0.2],Black,Text[Style["E"<>ToString[i],Bold,12],lamportEvents[[i]]+{0,0.4}]},{i,1,Length[lamportEvents]}],Text[Style["Indefinite Causal Order (Quantum superposition)",Bold,14,DarkMagenta],{timelineLength/2,-0.5}],Black,Thick,Line[{{0,1},{timelineLength,1}}],Table[{Magenta,Disk[indefiniteEvents[[i]],0.25],Black,Text[Style["F"<>ToString[i],Bold,12],indefiniteEvents[[i]]+{0,0.4}]},{i,1,Length[indefiniteEvents]}],Red,Dashed,Arrowheads[0.02],Arrow[{indefiniteEvents[[3]],indefiniteEvents[[2]]+{0,0.3}}],Arrow[{indefiniteEvents[[2]],indefiniteEvents[[3]]+{0,0.3}}],Text[Style["Superposition: F2 and F3 have no definite order",Italic,12,Red],{timelineLength/2,1.8}]},PlotRange->{{-0.5,timelineLength+0.5},{-1,4}},ImageSize->600,Axes->False]];
tiktyktikCommonKnowledge:=Module[{stages,yStart=6,yStep=-1,aliceX=1.5,bobX=6.5},stages={"1. Alice sends (Bob unaware)","2. Bob receives (Alice unsure)","3. Bob sends ACK1","4. Alice receives ACK1 (Knows Bob got packet)","5. Alice sends ACK2 (Completes 2nd round trip)","6. Bob receives ACK2 (Mutual knowledge achieved)"};Graphics[{Text[Style["TIKTYKTIK Protocol: Common Knowledge Build-up",Bold,16,DarkCyan],{4,yStart+1.5}],Blue,Disk[{aliceX,yStart+0.5},0.3],Text[Style["Alice",Bold,14],{aliceX,yStart+1}],Purple,Disk[{bobX,yStart+0.5},0.3],Text[Style["Bob",Bold,14],{bobX,yStart+1}],Table[Text[Style[stages[[i]],12],{4,yStart+yStep (i-1)}],{i,1,Length[stages]}],Arrowheads[0.03],Table[With[{y=yStart+yStep (i-1)},If[OddQ[i],{Blue,Arrow[{{aliceX+0.3,y},{bobX-0.3,y}}]},{Purple,Arrow[{{bobX-0.3,y},{aliceX+0.3,y}}]}]],{i,1,Length[stages]}]},PlotRange->{{0,8},{yStart+yStep Length[stages]-1,yStart+2}},ImageSize->600,Axes->False]];
Column[{packetSlicingGraphics,conveyorBeltGraphics,logicalVsIndefinite,tiktyktikCommonKnowledge},Spacings->4]


Module[{archTree,perfReliabPanel,conceptTable,topologySketch,marketSummary,titleStyle=Style[#1,Bold,18,FontFamily->"Arial"]&,subtitleStyle=Style[#1,Bold,14,FontFamily->"Arial"]&,textStyle=Style[#1,FontSize->12,FontFamily->"Arial"]&,keyPointStyle=Style[#1,FontSize->11,FontFamily->"Arial",Italic]&,boxStyle=Directive[EdgeForm[Black],LightYellow],arrowStyle={Black,Arrowheads[0.03],Thick}},archTree=Graph[{"Open Atomic Ethernet Requirements", "Core Technical Architecture", "Open Software Stack", "Research & Validation", "Ecosystem & Governance", "Lossless / Near-Zero-Loss Data Plane", "In-NIC Atomic Verbs", "Deterministic Scheduling", "Reference-Free Causal Ordering", "Self-Stabilizing Control Plane", "Composable Security & Isolation", "Open-Source Reference NIC RTL", "Portable Verbs Library", "Self-Healing Membership Service", "Lightweight Management Telemetry", "Formal Proofs for Atomic Commit", "Tail-latency & Failure-injection Benchmark", "Hybrid Quantum/Classical Shim", "Public Problem-Statement Registry", "Sub-groups", "External Expert Engagement", "Dedicated Business-Case Work-stream"}, {DirectedEdge["Open Atomic Ethernet Requirements", "Core Technical Architecture"], DirectedEdge["Open Atomic Ethernet Requirements", "Open Software Stack"], DirectedEdge["Open Atomic Ethernet Requirements", "Research & Validation"], DirectedEdge["Open Atomic Ethernet Requirements", "Ecosystem & Governance"], DirectedEdge["Core Technical Architecture", "Lossless / Near-Zero-Loss Data Plane"], DirectedEdge["Core Technical Architecture", "In-NIC Atomic Verbs"], DirectedEdge["Core Technical Architecture", "Deterministic Scheduling"], DirectedEdge["Core Technical Architecture", "Reference-Free Causal Ordering"], DirectedEdge["Core Technical Architecture", "Self-Stabilizing Control Plane"], DirectedEdge["Core Technical Architecture", "Composable Security & Isolation"], DirectedEdge["Open Software Stack", "Open-Source Reference NIC RTL"], DirectedEdge["Open Software Stack", "Portable Verbs Library"], DirectedEdge["Open Software Stack", "Self-Healing Membership Service"], DirectedEdge["Open Software Stack", "Lightweight Management Telemetry"], DirectedEdge["Research & Validation", "Formal Proofs for Atomic Commit"], DirectedEdge["Research & Validation", "Tail-latency & Failure-injection Benchmark"], DirectedEdge["Research & Validation", "Hybrid Quantum/Classical Shim"], DirectedEdge["Ecosystem & Governance", "Public Problem-Statement Registry"], DirectedEdge["Ecosystem & Governance", "Sub-groups"], DirectedEdge["Ecosystem & Governance", "External Expert Engagement"], DirectedEdge["Ecosystem & Governance", "Dedicated Business-Case Work-stream"]}, {GraphLayout -> "LayeredDigraphEmbedding", ImageSize -> 700, PlotLabel -> titleStyle["Open Atomic Ethernet: Core Requirements"], VertexLabels -> {Placed["Name", Center]}, VertexStyle -> {boxStyle}}];perfReliabPanel=Grid[{{subtitleStyle["Performance Targets"],"",subtitleStyle["Reliability & Resilience"]},{textStyle["Latency: < 100 ns store-and-forward, < 50 ns cut-through"],"",textStyle["Loss/Corruption Handling: per-hop FEC optional, end-to-end CRC > 2^32"]},{textStyle["Throughput: Scale from 200 Gb/s to 1.6 Tb/s per lane"],"",textStyle["Membership: Fast liveness voting, virtual synchrony support"]},{textStyle["Transaction RTT: Sender \[RightArrow] Receiver ack < 300 ns (in-rack worst-case)"],"",textStyle["Rollback Support: Speculative packets discard/commit hardware tag"]},{textStyle["Energy: <2 pJ/bit at 200 Gb/s, target sub-pJ with advanced PHY"],"",textStyle["Graceful Degradation: Congestion telemetry, buffer health monitoring"]},{textStyle["Clocking: Distributed low-skew clock (photonic/electrical)"],"",textStyle["Security: Inline MACsec-lite, key-roll w/o traffic pause"]}},Frame->All,ItemSize->{{30,300,350}},Alignment->Left,Background->{None,{{LightGray,None}}},Spacings->{1,2}];conceptTable=Grid[{{subtitleStyle["Aspect"],subtitleStyle["Traditional Ethernet"],subtitleStyle["Open Atomic Ethernet"]},{"Protocol Model","Source-Destination, asynchronous, timeout/retry","Bipartite Token Coherence, reversible, no retries"},{"Transaction Semantics","Best-effort, possible drops & duplicates","Exactly-once semantics, atomic commit/rollback"},{"Error Handling","Timeouts, retransmissions, exponential backoff","Logical reversibility, failure recovery via transaction reversal"},{"Topology Control","Fixed physical routing, spanning trees","Dynamic logical & virtual trees, app-programmable"},{"Security Model","MAC/IP based, vulnerable to byzantine attacks","Port-based local addressing, built-in isolation & side-channel detection"},{"Latency","Subject to retries, congestion, unpredictable delays","Deterministic, bounded latency with mesochronous scheduling"},{"Scalability","Fragmented, multiple overlays","Unified Ethernet for chiplets, racks, AI accelerators"}},Frame->All,Alignment->Left,ItemStyle->Directive[FontFamily->"Arial",FontSize->12],Background->{None,{{LightYellow,None}}}];topologySketch=Graphics[{LightBlue,EdgeForm[Black],Rectangle[{0,0},{10,2}],Text[Style["Physical Layer: Chiplet & Rack Interconnect",Bold,14],{5,1}],Black,Dashed,Table[Line[{{x,0},{x,2}}],{x,1,9,2}],Green,EdgeForm[Black],Rectangle[{1,3},{9,5}],Text[Style["Logical Layer: Configurable Trees & Links",Bold,14],{5,4}],Black,Dashed,Table[Line[{{x,3},{x+1,5}}],{x,1,7,2}],Orange,EdgeForm[Black],Rectangle[{2,6},{8,8}],Text[Style["Virtual Layer: Application-controlled Trees",Bold,14],{5,7}],Black,Dashed,Line[{{2,6},{8,8}}],Line[{{8,6},{2,8}}],Text[Style["Dynamic, Secure, Self-Healing",Italic,12],{5,6.5}]},ImageSize->700,PlotRange->{{-1,11},{-1,10}},Background->White,Axes->False];marketSummary=Column[{titleStyle["Market & Innovation Highlights"],keyPointStyle["\[Bullet] Emergence of XPU & SmartNIC revolution"],keyPointStyle["\[Bullet] FPGA NIC implementations for protocol experimentation"],keyPointStyle["\[Bullet] Strong need for ultra-low latency AI inference at the edge"],keyPointStyle["\[Bullet] Shift from best-effort to lossless, deterministic network protocols"],keyPointStyle["\[Bullet] Dynamic network topologies driven by application needs"],keyPointStyle["\[Bullet] Formal methods underpin infrastructure verification"],keyPointStyle["\[Bullet] Collaborative ecosystem involving academic and industry leaders"]},Spacings->1.5];Column[{archTree,Spacer[20],Style["Performance and Reliability Targets",Bold,16],perfReliabPanel,Spacer[20],Style["Conceptual Comparison: Traditional vs Open Atomic Ethernet",Bold,16],conceptTable,Spacer[20],topologySketch,Spacer[20],marketSummary},Spacings->3]]


techArchGraph=Graph[{"Lossless Data Plane", "In-NIC Atomic Verbs", "Deterministic Scheduling", "Reference-Free Causal Ordering", "Self-Stabilizing Control Plane", "Composable Security & Isolation"}, {DirectedEdge["Lossless Data Plane", "In-NIC Atomic Verbs"], DirectedEdge["In-NIC Atomic Verbs", "Deterministic Scheduling"], DirectedEdge["Deterministic Scheduling", "Reference-Free Causal Ordering"], DirectedEdge["Reference-Free Causal Ordering", "Self-Stabilizing Control Plane"], DirectedEdge["Self-Stabilizing Control Plane", "Composable Security & Isolation"]}, {GraphLayout -> "LayeredDigraphEmbedding", GraphStyle -> "NameLabeled", ImageSize -> Large, PlotLabel -> Style["Core Technical Architecture Pipeline", Bold, 16], VertexLabels -> {Placed["Name", Center]}, VertexSize -> {Medium}}];
softwareStack=Grid[{{"Open-Source NIC RTL","Portable Verbs Library"},{"Self-Healing Membership Service","Lightweight Management Telemetry"}},Frame->All,Spacings->{3,2},ItemStyle->Directive[Bold,14,Blue]];
softwareStackPanel=Panel[Column[{Style["Open Software Stack",Bold,16,Darker[Green]],Spacer[5],softwareStack}],ImageSize->Medium];
distributedProblemsGraph=Graph[{"Asynchronous Consensus", "Faulty Nodes", "Byzantine Agreement", "Perfect Failure Detection", "Failure Detection", "Global Snapshot", "Two-Phase Commit", "Exact Clock Sync"}, {UndirectedEdge["Asynchronous Consensus", "Faulty Nodes"], UndirectedEdge["Faulty Nodes", "Byzantine Agreement"], UndirectedEdge["Asynchronous Consensus", "Perfect Failure Detection"], UndirectedEdge["Failure Detection", "Global Snapshot"], UndirectedEdge["Global Snapshot", "Two-Phase Commit"], UndirectedEdge["Two-Phase Commit", "Exact Clock Sync"]}, {EdgeStyle -> {Dashed}, GraphLayout -> "SpringElectricalEmbedding", ImageSize -> Large, PlotLabel -> Style["Unsolvable Distributed Systems Problems", Bold, 16, Red], VertexLabels -> {Placed["Name", Center]}}];
atomicEthernetTokenFlow=GraphicsGrid[{{Graphics[{Style[Arrowheads[0.03],Blue,Thick],Arrow[{{0,0},{4,0}}],Arrow[{{4,0},{0,0}}],Text[Style["Token Coherence Protocol\n(Bipartite Interaction)",Bold,14,Blue],{2,0.5}]},PlotRange->{{-1,5},{-1,1}},ImageSize->350],Graphics[{Style[Circle[{0,0},1],Thick,Red],Style[Text["State Reversal\n(Error Recovery)",{0,0}],Bold,Red,14]},PlotRange->{{-1.5,1.5},{-1.5,1.5}},ImageSize->200]}},Spacings->5];
networkTopology=Module[{phys,logical,virtual},phys=Graph[{1, 2, 3, 4, 5}, {UndirectedEdge[1, 2], UndirectedEdge[2, 3], UndirectedEdge[3, 4], UndirectedEdge[4, 5], UndirectedEdge[2, 5]}, {GraphStyle -> "NameLabeled", ImageSize -> Medium, PlotLabel -> Style["Physical Topology (Static)", Bold, 14], VertexLabels -> {"Name"}}];logical=Graph[{1, 2, 3, 4, 5}, {DirectedEdge[1, 2], DirectedEdge[1, 3], DirectedEdge[3, 4], DirectedEdge[3, 5]}, {GraphStyle -> "NameLabeled", ImageSize -> Medium, PlotLabel -> Style["Logical Topology (Reconfigurable)", Bold, 14], VertexLabels -> {"Name"}}];virtual=Graph[{2, 5, 4, 1}, {DirectedEdge[2, 5], DirectedEdge[5, 4], DirectedEdge[4, 1]}, {GraphStyle -> "NameLabeled", ImageSize -> Medium, PlotLabel -> Style["Virtual Topology (Application-Programmable)", Bold, 14], VertexLabels -> {"Name"}}];Grid[{{phys,logical,virtual}},Spacings->5]];
frameStructureDiagram=Graphics[{Style[Rectangle[{0,0},{8,1}],LightGray,EdgeForm[Thick]],Style[Text["Ultra-low latency frame\n(no headers, no preamble)",{4,0.5}],Bold,14]},PlotRange->{{-1,9},{-1,2}},ImageSize->400];
selfStabilizingLoop=Graphics[{Style[Arrowheads[0.04],Thick,Darker[Orange]],Arrow[{{0,0},{3,0}}],Arrow[{{3,0},{3,3}}],Arrow[{{3,3},{0,3}}],Arrow[{{0,3},{0,0}}],Text[Style["Self-Stabilizing Control Plane Feedback Loop",Bold,14,Darker[Orange]],{1.5,3.5}]},PlotRange->{{-1,4},{-1,5}},ImageSize->400];
Column[{techArchGraph,Spacer[20],softwareStackPanel,Spacer[20],distributedProblemsGraph,Spacer[20],Style["Atomic Ethernet Transaction Model",Bold,16],atomicEthernetTokenFlow,Spacer[20],Style["Network Topologies",Bold,16],networkTopology,Spacer[20],frameStructureDiagram,Spacer[20],selfStabilizingLoop},Spacings->3]


Module[{pipelineStages={"PHY / MAC","In-NIC Atomic Verbs","Deterministic Scheduler","Control Plane","Application API"},pipelineBoxes,pipelineGraphics,physicalNodes=9,logicalTreeEdges,virtualTreeEdges,physicalGraph,logicalGraph,virtualGraph,txStates={"Idle","Send Packet","Await ACK","Commit","Rollback","Complete"},txTransitions,txLifecycleGraph,failureNodes={"Sender","Link","Receiver"},failureStates={"Normal","Packet Lost","Link Failure","Rollback","Recovery","Resume"},failureGraphEdges,trafficNodes=25,trafficPositions,trafficEdges,trafficGraph,meshSize=4,meshNodes,meshEdges,hammingEdges,boxStyle={LightBlue,EdgeForm[Black]},highlightStyle=Directive[Orange,Thick],arrowStyle={Black,Arrowheads[0.03]},largeFont=Directive[FontSize->14,Bold],smallFont=Directive[FontSize->10],circleRadius=0.3},pipelineBoxes=Table[{boxStyle,Rectangle[{i 2,0},{i 2+1.6,1}],Black,Text[Style[pipelineStages[[i]],largeFont],{i 2+0.8,0.5}]},{i,Length[pipelineStages]}];pipelineGraphics=Graphics[{pipelineBoxes,Table[{arrowStyle,Arrow[{{i 2+1.6,0.5},{(i+1) 2,0.5}}]},{i,Length[pipelineStages]-1}]},ImageSize->Large,PlotRange->{{-1,2 Length[pipelineStages]},{-1,2}},PlotLabel->Style["Core Technical Architecture: Data Plane Pipeline",largeFont]];physicalGraph=Graph[Range[physicalNodes],UndirectedEdge@@@Partition[Range[physicalNodes],2,1,{1,1}],VertexLabels->"Name",GraphLayout->"GridEmbedding",VertexSize->Medium,GraphStyle->"NameLabeled",PlotLabel->Style["Physical Topology (Linear / Grid)",largeFont]];logicalTreeEdges=UndirectedEdge@@@{{1,2},{1,3},{2,4},{2,5},{3,6},{3,7},{6,8},{6,9}};logicalGraph=Graph[Range[physicalNodes],logicalTreeEdges,VertexLabels->"Name",GraphLayout->"LayeredDigraphEmbedding",VertexSize->Medium,GraphStyle->"NameLabeled",PlotLabel->Style["Logical Tree Topology Overlay",largeFont]];virtualTreeEdges=UndirectedEdge@@@{{1,5},{5,9},{1,4},{4,7},{7,8},{8,3}};virtualGraph=Graph[Range[physicalNodes],virtualTreeEdges,VertexLabels->"Name",GraphLayout->"LayeredDigraphEmbedding",VertexSize->Medium,GraphStyle->"NameLabeled",PlotLabel->Style["Virtual Application Tree Topology",largeFont]];txTransitions={"Idle"->"Send Packet","Send Packet"->"Await ACK","Await ACK"->"Commit","Await ACK"->"Rollback","Rollback"->"Send Packet","Commit"->"Complete"};txLifecycleGraph=Graph[txStates,txTransitions,VertexLabels->"Name",GraphLayout->"CircularEmbedding",GraphStyle->"NameLabeled",EdgeStyle->Arrowheads[0.03],PlotLabel->Style["Transaction Lifecycle and Atomic Commit States",largeFont]];failureGraphEdges={"Normal"->"Packet Lost","Normal"->"Link Failure","Packet Lost"->"Rollback","Link Failure"->"Rollback","Rollback"->"Recovery","Recovery"->"Resume","Resume"->"Normal"};failureGraph=Graph[failureStates,failureGraphEdges,VertexLabels->"Name",GraphLayout->"LayeredDigraphEmbedding",VertexSize->Medium,GraphStyle->"NameLabeled",PlotLabel->Style["Failure Detection and Self-Stabilizing Recovery",largeFont]];trafficPositions=Flatten[Table[{i,j},{i,1,5},{j,1,5}],1];trafficEdges=UndirectedEdge@@@Select[Subsets[Range[trafficNodes],{2}],EuclideanDistance[trafficPositions[[#1[[1]]]],trafficPositions[[#1[[2]]]]]<=1.5&];trafficGraph=Graph[Range[trafficNodes],trafficEdges,VertexCoordinates->trafficPositions,VertexSize->Small,GraphStyle->"NameLabeled",VertexLabels->None,PlotLabel->Style["Sparse and Localized Datacenter Traffic Pattern",largeFont]];meshNodes=Flatten[Table[{i,j},{i,1,meshSize},{j,1,meshSize}],1];meshEdges=UndirectedEdge@@@Select[Subsets[Range[Length[meshNodes]],{2}],Module[{a=meshNodes[[#1[[1]]]],b=meshNodes[[#1[[2]]]]},Abs[a[[1]]-b[[1]]]+Abs[a[[2]]-b[[2]]]==1]&];hammingEdges=UndirectedEdge@@@Select[Subsets[Range[Length[meshNodes]],{2}],Module[{a=meshNodes[[#1[[1]]]],b=meshNodes[[#1[[2]]]]},Mod[a[[1]]+a[[2]],2]==0&&Mod[b[[1]]+b[[2]],2]==1&&Norm[a-b]<1.5]&];hammingMeshGraph=Graph[Range[Length[meshNodes]],Join[meshEdges,hammingEdges],VertexCoordinates->meshNodes,VertexSize->Medium,VertexLabels->Placed["Name",Center],GraphStyle->"NameLabeled",EdgeStyle->{Black,Thin},PlotLabel->Style["HammingMesh Overlay on 2D Mesh Network",largeFont]];Column[{pipelineGraphics,Row[{physicalGraph,Spacer[20],logicalGraph,Spacer[20],virtualGraph}],txLifecycleGraph,failureGraph,trafficGraph,hammingMeshGraph},Spacings->3]]


Module[{headerColor=Darker[Blue,0.3],nodeColor=Darker[Green,0.2],faultColor=Red,labelStyle=Directive[FontFamily->"Arial",FontSize->12,Bold],width=800,slices=8,sliceWidth=0.9,packetSlicesGraphic},packetSlicesGraphic=Graphics[{Text[Style["OAE Data Plane: Packet Slicing and Atomic Verbs",headerColor,16,Bold],{slices/2,2.7}],Table[{LightBlue,EdgeForm[Black],Rectangle[{i,1},{i+sliceWidth,2}],Black,Text[Style[ToString[i],Bold,14],{i+sliceWidth/2,1.5}]},{i,0,slices-1}],Red,Thick,Arrowheads[0.03],Arrow[{{-0.5,1.5},{0,1.5}}],Text[Style["Atomic Verbs: CAS, Multi-word commit @ 100GbE latency ~300ns",Red,Italic,12],{-0.5,2.2},{Right,Baseline}]},PlotRange->{{-1,slices+1},{0.5,3}},ImageSize->width/2];packetSlicesGraphic]


Module[{archItems,archLabels,functionalItems,functionalLabels,perfItems,perfLabels,dsProblems,dsProblemDescriptions,dsProblemGraph,atomicEthernetGraph,traditionalEthernetGraph,conveyorLength=20,conveyorBeltGraphics,reqPriorityLabels,reqPriorityValues,reqPriorityChart,makeLabeledList},makeLabeledList[items_List]:=Grid[Table[{Style[ToString[i]<>".",Bold],items[[i]]},{i,Length[items]}],Alignment->Left,Spacings->{1,0.3},Frame->None];archItems={"Lossless / Near-Zero-Loss Data Plane: No random drops","In-NIC Atomic Verbs: CAS and multi-word commit @ line-rate","Deterministic Scheduling: mesochronous/slot-based for bounded latency","Reference-Free Causal Ordering: No global clocks; causal trees/hybrid clocks","Self-Stabilizing Control Plane: Auto recovery, no manual reset","Composable Security & Isolation: Side-channel detection, optional QKD"};archLabels="Core Technical Architecture";functionalItems={"Deterministic / Bounded-Latency Delivery for AI/HFT workloads","Reliable Atomic Message Primitives with optional local retransmit","Timeout-And-Retry elimination in fast path (no reliance on SW timers)","Autonomous Discovery & Configuration with zero-touch bring-up","Programmable Packet Processing at Layer 2\.bd (P4/eBPF/HDL modules)","Minimal Hardware Feature Set for complex semantics support","Classical/Quantum Interworking hooks reserved for future expansion"};functionalLabels="Functional Requirements";perfItems={"Latency Target: store-and-forward <100 ns; cut-through <50 ns","Throughput Target: scale line-rate 200 Gb/s to 1.6 Tb/s per lane","Transactional Round-Trip: single sender\[RightArrow]receiver ack <300 ns"};perfLabels="Performance Requirements";dsProblems={"Consensus in Async Systems with Faults is impossible (FLP)","Byzantine Agreement impossible with >1/3 faulty nodes","Perfect Failure Detection impossible in Async Systems","Simultaneous Global State Agreement difficult due to async messages","Two-Phase Commit stalls on network partitions (CAP theorem)","Exact Clock Synchronization impossible due to drift and latency"};dsProblemDescriptions=makeLabeledList[dsProblems];dsProblemGraph=Graph[{1, 2, 3, 4, 5, 6}, {DirectedEdge[1, 2], DirectedEdge[2, 3], DirectedEdge[3, 4], DirectedEdge[4, 5], DirectedEdge[5, 6]}, {GraphLayout -> "LayeredDigraphEmbedding", ImageSize -> 450, PlotLabel -> Style["Fundamental Distributed Systems Problems", Bold, 14], VertexLabels -> {Placed["Name", Center]}, VertexSize -> {Tiny}}];atomicEthernetGraph=Graph[{"Sender", "Receiver", "Network"}, {DirectedEdge["Sender", "Receiver"], DirectedEdge["Receiver", "Sender"], DirectedEdge["Sender", "Network"], DirectedEdge["Receiver", "Network"]}, {EdgeLabels -> {DirectedEdge["Sender", "Receiver"] -> "Atomic Token Exchange", DirectedEdge["Receiver", "Network"] -> "Token Not Visible to Others", DirectedEdge["Receiver", "Sender"] -> "Reverse Transaction / ACK", DirectedEdge["Sender", "Network"] -> "Token Not Visible to Others"}, GraphStyle -> "NameLabeled", ImageSize -> 400, PlotLabel -> Style["Open Atomic Ethernet: Token Coherence Protocol", Bold, 14], VertexLabels -> {"Name"}}];traditionalEthernetGraph=Graph[{"Sender", "Receiver", "Network"}, {DirectedEdge["Sender", "Network"], DirectedEdge["Network", "Receiver"], DirectedEdge["Receiver", "Sender"], UndirectedEdge["Network", "Sender"], UndirectedEdge["Network", "Receiver"]}, {EdgeLabels -> {DirectedEdge["Receiver", "Sender"] -> "ACK (Optional)", DirectedEdge["Sender", "Network"] -> "Packet Send", DirectedEdge["Network", "Receiver"] -> "Packet Delivery"}, GraphStyle -> "NameLabeled", ImageSize -> 400, PlotLabel -> Style["Traditional Ethernet: Source-Destination Packet Flow", Bold, 14], VertexLabels -> {"Name"}}];conveyorBeltGraphics=Graphics[{Table[{GrayLevel[0.7],Rectangle[{i,1},{i+3,2}]},{i,0,conveyorLength,4}],Table[Text[Style[If[Mod[i,8]==0,"Time"," "],Italic,12],{i+1.5,1.5}],{i,0,conveyorLength,4}],Text[Style["Conveyor Belt Metaphor for Time Flow",Bold,14],{conveyorLength/2,2.5}],Arrowheads[0.03],Arrow[{{0,2.3},{conveyorLength+1,2.3}}],Text["Past",{-1,2.3}],Text["Future",{conveyorLength+1.5,2.3}]},PlotRange->{{-2,conveyorLength+3},{0.5,3}},ImageSize->450];reqPriorityLabels={"Lossless Data Plane","In-NIC Atomics","Deterministic Scheduling","Ref-Free Causal Order","Self-Stabilizing Control"};reqPriorityValues={9,8,7,7,6};reqPriorityChart=BarChart[reqPriorityValues,ChartLabels->reqPriorityLabels,PlotLabel->Style["Top Priority Requirements (Scale 1-10)",Bold,14],Frame->True,FrameLabel->{"Requirement","Priority"},ImageSize->500,BarSpacing->0.3,PlotRange->{0,10}];Column[{Style[archLabels,Bold,16],makeLabeledList[archItems],Style[functionalLabels,Bold,16],makeLabeledList[functionalItems],Style[perfLabels,Bold,16],makeLabeledList[perfItems],reqPriorityChart,Row[{atomicEthernetGraph,Spacer[50],traditionalEthernetGraph}],conveyorBeltGraphics},Spacings->5,Alignment->Center]]


Module[{twoSegmentEthernet,chipletGraph,triangleGraph,meshGraph,layeredGraph},twoSegmentEthernet=Graphics[{{Thick,Black,Line[{{0,0},{4,0}}],Line[{{6,0},{10,0}}]},{Red,PointSize[Large],Point[{10,0}]},Text[Style["TERMINATOR",12],{10,-0.3},{-1,0}],{Blue,Disk[{4,0},0.15]},Text[Style["TAP",12],{4,0.3}],{Green,Disk[{6,0},0.15]},Text[Style["REPEATER",12],{6,0.3}],{Gray,Rectangle[{0.5,-0.5},{1.5,0.5}]},Text[Style["STATION",12],{1,-0.7}],{Gray,Rectangle[{8,-0.5},{9,0.5}]},Text[Style["STATION",12],{8.5,-0.7}]},ImageSize->500,PlotRange->{{-1,11},{-1,1}}];chipletGraph=Graph[GridGraph[{3,3}],VertexLabels->"Name",VertexSize->Medium,PlotLabel->Style["3\[Times]3 Logical Tile",Bold,14],ImageSize->300];triangleGraph=Graph[{1, 2, 3}, {UndirectedEdge[1, 2], UndirectedEdge[2, 3], UndirectedEdge[3, 1]}, {GraphLayout -> "CircularEmbedding", ImageSize -> 300, PlotLabel -> Style["Minimum Triangle Topology", Bold, 14], VertexLabels -> {Placed["Name", Center]}, VertexSize -> {Large}}];meshGraph=Graph[GridGraph[{9,9}],VertexSize->Tiny,PlotLabel->Style["Logical 9\[Times]9 Mesh Tile",Bold,14],ImageSize->500];layeredGraph=GraphUnion[Graph[{1, 2, 3, 4}, {DirectedEdge[1, 2], DirectedEdge[1, 3], DirectedEdge[2, 4], DirectedEdge[3, 4]}, {PlotLabel -> "DAG (Causality)"}],Graph[{1, 5, 6, 7}, {DirectedEdge[1, 5], DirectedEdge[1, 6], DirectedEdge[5, 7]}, {PlotLabel -> "Tree (Authority)"}],GraphLayout->"LayeredDigraphEmbedding",VertexLabels->"Name",PlotLabel->Style["Layered System (Graph \[RightArrow] DAG \[RightArrow] Tree)",Bold,14],ImageSize->400];Column[{Style["1. Two-segment Ethernet schematic",Bold,14],twoSegmentEthernet,Style["2. Chiplet \[CapitalAE]thernet 3\[Times]3 tile",Bold,14],chipletGraph,Style["3. Minimum Triangle topology",Bold,14],triangleGraph,Style["4. Logical 9\[Times]9 Mesh Tile",Bold,14],meshGraph,Style["5. DAG + Tree Overlay",Bold,14],layeredGraph},Spacings->2,Alignment->Center]]


packetSlicingGraphics:=Module[{sliceCount=8,sliceWidth=0.8,sliceHeight=1,ackArrowHeight=0.7,sliceColors,ackColors},sliceColors=Table[Blend[{LightBlue,Blue},i/sliceCount],{i,1,sliceCount}];ackColors=Table[Blend[{LightRed,Red},i/sliceCount],{i,1,sliceCount}];Graphics[{Table[{sliceColors[[i]],EdgeForm[Black],Rectangle[{i-1,1},{i-1+sliceWidth,1+sliceHeight}],Black,Text[Style[ToString[i],Bold,14],{i-1+sliceWidth/2,1+sliceHeight/2}]},{i,1,sliceCount}],Table[{ackColors[[i]],Arrowheads[0.03],Arrow[{{i-1+sliceWidth/2,1},{i-1+sliceWidth/2,1-ackArrowHeight}}]},{i,1,sliceCount}],Text[Style["64-byte Packet split into eight 8-byte slices",Bold,16,DarkBlue],{sliceCount/2,2.5}],Text[Style["Sub-ACKs acknowledge slices, allowing pipelined transmissions.",Italic,12],{sliceCount/2,-0.2}],Text[Style["Throughput improves by keeping multiple slices in flight during RTT.",Italic,12],{sliceCount/2,-0.7}]},PlotRange->{{-1,sliceCount},{-1,3}},ImageSize->600,Axes->False]];
conveyorBeltGraphics:=Module[{beltLength=8,classicalBeltY=2.5,quantumBeltY=0},Graphics[{Text[Style["Classical Time Flow (Conveyor Belt)",Bold,14,DarkGreen],{beltLength/2,3.8}],Brown,Thick,Rectangle[{0,classicalBeltY-0.3},{beltLength,classicalBeltY+0.3}],Arrowheads[0.04],Arrow[{{0,classicalBeltY},{beltLength,classicalBeltY}}],Table[{Blue,Disk[{i-0.5,classicalBeltY},0.2],Black,Text[Style[ToString[i],Bold,12],{i-0.5,classicalBeltY+0.4}]},{i,1,beltLength}],Text[Style["Indefinite Causal Order (Quantum)",Bold,14,DarkRed,Italic],{beltLength/2,1.8}],Brown,Thick,Line[{{0,quantumBeltY},{4,quantumBeltY},{5,quantumBeltY+1},{beltLength,quantumBeltY+1}}],Line[{{4,quantumBeltY},{5,quantumBeltY-1},{beltLength,quantumBeltY-1}}],Red,Disk[{1,quantumBeltY},0.2],Text[Style["A",Bold,12],{1,quantumBeltY+0.4}],Disk[{3,quantumBeltY},0.2],Text[Style["B",Bold,12],{3,quantumBeltY+0.4}],Disk[{6,quantumBeltY+1},0.2],Text[Style["C",Bold,12],{6,quantumBeltY+1.4}],Disk[{6,quantumBeltY-1},0.2],Text[Style["D",Bold,12],{6,quantumBeltY-1.4}]},PlotRange->{{-1,beltLength+1},{-2,4.5}},ImageSize->600,Axes->False]];
logicalVsIndefinite:=Module[{timelineLength=6,lamportEvents,indefiniteEvents},lamportEvents=Table[{i+0.5,2.5},{i,0,timelineLength-1}];indefiniteEvents=Table[{i+0.5,1},{i,0,timelineLength-1}];Graphics[{Text[Style["Lamport Logical Time (Deterministic order)",Bold,14,DarkBlue],{timelineLength/2,3.5}],Black,Thick,Arrowheads[0.03],Arrow[{{0,2.5},{timelineLength,2.5}}],Table[{Blue,Disk[lamportEvents[[i]],0.2],Black,Text[Style["E"<>ToString[i],Bold,12],lamportEvents[[i]]+{0,0.4}]},{i,1,Length[lamportEvents]}],Text[Style["Indefinite Causal Order (Quantum superposition)",Bold,14,DarkMagenta],{timelineLength/2,-0.5}],Black,Thick,Line[{{0,1},{timelineLength,1}}],Table[{Magenta,Disk[indefiniteEvents[[i]],0.25],Black,Text[Style["F"<>ToString[i],Bold,12],indefiniteEvents[[i]]+{0,0.4}]},{i,1,Length[indefiniteEvents]}],Red,Dashed,Arrowheads[0.02],Arrow[{indefiniteEvents[[3]],indefiniteEvents[[2]]+{0,0.3}}],Arrow[{indefiniteEvents[[2]],indefiniteEvents[[3]]+{0,0.3}}],Text[Style["Superposition: F2 and F3 have no definite order",Italic,12,Red],{timelineLength/2,1.8}]},PlotRange->{{-0.5,timelineLength+0.5},{-1,4}},ImageSize->600,Axes->False]];
tiktyktikCommonKnowledge:=Module[{stages,yStart=6,yStep=-1,aliceX=1.5,bobX=6.5},stages={"1. Alice sends (Bob unaware)","2. Bob receives (Alice unsure)","3. Bob sends ACK1","4. Alice receives ACK1 (Knows Bob got packet)","5. Alice sends ACK2 (Completes 2nd round trip)","6. Bob receives ACK2 (Mutual knowledge achieved)"};Graphics[{Text[Style["TIKTYKTIK Protocol: Common Knowledge Build-up",Bold,16,DarkCyan],{4,yStart+1.5}],Blue,Disk[{aliceX,yStart+0.5},0.3],Text[Style["Alice",Bold,14],{aliceX,yStart+1}],Purple,Disk[{bobX,yStart+0.5},0.3],Text[Style["Bob",Bold,14],{bobX,yStart+1}],Table[Text[Style[stages[[i]],12],{4,yStart+yStep (i-1)}],{i,1,Length[stages]}],Arrowheads[0.03],Table[With[{y=yStart+yStep (i-1)},If[OddQ[i],{Blue,Arrow[{{aliceX+0.3,y},{bobX-0.3,y}}]},{Purple,Arrow[{{bobX-0.3,y},{aliceX+0.3,y}}]}]],{i,1,Length[stages]}]},PlotRange->{{0,8},{yStart+yStep Length[stages]-1,yStart+2}},ImageSize->600,Axes->False]];
Column[{packetSlicingGraphics,conveyorBeltGraphics,logicalVsIndefinite,tiktyktikCommonKnowledge},Spacings->4]


Module[{n=7,meshGraph,startNode,endNode,reservedPath,pathEdges,forwardingTableGraphics,routingLegend,class1Style,class3Style,nextHopArrow,nodesCoords,allEdges,forwardingAnnotations,oNText,oN2Text},meshGraph=GridGraph[{n,n}];nodesCoords=GraphEmbedding[meshGraph,"SpringEmbedding"];startNode=1;endNode=n^2;reservedPath=FindShortestPath[meshGraph,startNode,endNode];pathEdges=UndirectedEdge@@@Partition[reservedPath,2,1];class1Style=Directive[Thick,Blue,Opacity[0.8]];class3Style=Directive[Dashed,Gray,Thin];nextHopArrow={Arrowheads[0.03],Black};forwardingAnnotations=Table[Module[{node=i,nextHop},If[MemberQ[reservedPath,i],nextHop=Module[{pos=Position[reservedPath,i][[1,1]]},If[pos<Length[reservedPath],reservedPath[[pos+1]],Missing["NotAvailable"]]];If[nextHop=!=Missing["NotAvailable"],Style[Text[Framed["\[RightArrow] "<>ToString[nextHop],Background->LightYellow,RoundingRadius->5],nodesCoords[[node]]+{0.15,0.15}],FontSize->10,Blue],Nothing],Nothing]],{i,VertexList[meshGraph]}];Show[Graph[meshGraph,GraphStyle->"NameLabeled",VertexLabels->"Name",VertexSize->Small,EdgeStyle->class3Style,ImageSize->Large,PlotLabel->Style["2D Mesh Network with Reserved Path (Class 1) vs. Others (Class 3)",Bold,16]],Graphics[{class1Style,Thick,Line[(nodesCoords[[#1]]&)/@reservedPath],(Arrow[{nodesCoords[[#1[[1]]]],nodesCoords[[#1[[2]]]]}]&)/@Partition[reservedPath,2,1],forwardingAnnotations}]];oNText=Style["O(N) Forwarding Table\n(next-hop known locally)",FontSize->14,Blue];oN2Text=Style["O(N\.b2) Probe-based Discovery\n(global flooding/scaling issues)",FontSize->14,Red];GraphicsRow[{Graphics[{Blue,Rectangle[{0,0},{4,1}],White,Text[oNText,{2,0.5}]},ImageSize->300],Graphics[{Red,Rectangle[{0,0},{4,1}],White,Text[oN2Text,{2,0.5}]},ImageSize->300]},Spacings->3]]


perspectiveLayers=Graphics[{LightGray,Rectangle[{0,0},{6,1}],LightGray,Rectangle[{0.5,1},{5.5,2}],LightGray,Rectangle[{1,2},{5,3}],LightGray,Rectangle[{1.5,3},{4.5,4}],Darker[Green],Text[Style["Network Hardware Designer",Bold,14],{3,0.5}],Darker[Blue],Text[Style["Network Operator",Bold,14],{3,1.5}],Darker[Red],Text[Style["Compute Designer",Bold,14],{3,2.5}],Darker[Purple],Text[Style["Application Developer",Bold,14],{3,3.5}],Black,Dashed,Line[{{0,0},{6,4}}]},PlotRange->{{-1,7},{0,5}},ImageSize->450,PlotLabel->Style["Perspectives Layered as 'Turtles All The Way Down'",Bold,16]];
perspectiveLayers


Module[{headerStyle={FontFamily->"Arial",FontSize->18,Bold},subHeaderStyle={FontFamily->"Arial",FontSize->14,Bold,Darker[Gray]},bulletStyle={FontFamily->"Arial",FontSize->12,Italic},textStyle={FontFamily->"Arial",FontSize->12,LineSpacing->1.2},colWidth=600,anon1Grid,coreConceptsBox,forwardingPlot,topoGraphic,summaryPanel},anon1Grid=Grid[{{Style["Anonymous 1 Feedback Summary",headerStyle]},{Pane[Style["\[Bullet] Proposed link layer lacks full requirements clarity\n"<>"\[Bullet] Atomicity demands instant delivery confirmation\n"<>"\[Bullet] Idea echoes Fibre-Channel Class 1 dedicated paths\n"<>"\[Bullet] Keep two on-wire formats: path-setup & steady-state\n"<>"\[Bullet] Per-node O(N) state preferable to O(N\.b2) probe flooding",textStyle],{colWidth,140},Scrollbars->False]}},Alignment->Left];coreConceptsBox=Column[(Style[#1,bulletStyle]&)/@{"Atomic acceptance needs per-interface item indices","OSI layering must address information leakage","Window-like clustered ACKs vs \[OpenCurlyQuote]snake\[CloseCurlyQuote] path reservation","Grey failures (partial degradation) dominate real outages","Interface logic must scale with concurrent \[OpenCurlyQuote]snakes\[CloseCurlyQuote]","Full-duplex link = two independent simplex failure domains"},Spacings->0.6];forwardingPlot=ListLinePlot[{Table[{n,n},{n,1,100}],Table[{n,n^2},{n,1,100}]},PlotStyle->{{Thick},{Thick,Dashed,Red}},PlotLabels->Placed[{"O(N)  per-node","O(N\.b2) probe"},Above],AxesLabel->{"Nodes (N)","Operations"},GridLines->Automatic,PlotRange->{{0,100},{0,10000}},ImageSize->500,PlotLabel->Style["Forwarding-Table Scaling",subHeaderStyle]];topoGraphic=Graphics[{Table[{LightGray,EdgeForm[Gray],Rectangle[{i,j},{i+1,j+1}]},{i,0,3},{j,0,3}],Black,Thick,Table[Line[{{i+0.5,j+0.5},{i+1.5,j+0.5}}],{i,0,2},{j,0,3}],Table[Line[{{i+0.5,j+0.5},{i+0.5,j+1.5}}],{i,0,3},{j,0,2}],{Red,Disk[{1.5,1.5},0.35]},Text[Style["Root Node",12,Bold],{1.5,2.3}],Blue,Arrowheads[0.03],Arrow[{{1.5,1.5},{2.5,1.5}}],Arrow[{{1.5,1.5},{1.5,2.5}}],Text[Style["local BW",11,Blue],{2.6,1.8}],{Purple,Dashed,Circle[{1.5,1.5},3]},Text[Style["global traffic minimized",11,Purple],{4.3,4.1}]},ImageSize->500,PlotRange->{{-0.5,4.5},{-0.5,4.5}},Axes->False,PlotLabel->Style["HammingMesh / Edge-AI Locality",subHeaderStyle]];summaryPanel=Column[{Style["Open Atomic Ethernet \[LongDash] Key Benefits",headerStyle],Style["\[Bullet] Eliminates retries & cascade failures",bulletStyle],Style["\[Bullet] Switchless, ultra-low-latency links",bulletStyle],Style["\[Bullet] Exactly-once via reversible tokens",bulletStyle],Style["\[Bullet] Self-stabilizing O(N) forwarding state",bulletStyle],Style["\[Bullet] Tailored to AI/ML locality (HammingMesh)",bulletStyle],Style["\[Bullet] Works on minimal NIC hardware",bulletStyle]},Spacings->0.8];Column[{anon1Grid,Spacer[8],Style["Core Insights & Challenges",headerStyle],coreConceptsBox,Spacer[10],forwardingPlot,Spacer[10],topoGraphic,Spacer[10],summaryPanel},Spacings->4,Alignment->Center]]


Module[{largeFont=Directive[FontSize->14,Bold],smallFont=Directive[FontSize->10,FontFamily->"Arial"],selfStabilizeCycle,atomicEthernetConcepts},selfStabilizeCycle=Graph[{"Stable State", "Fault Detected", "Rollback Initiated", "Recovery In Progress"}, {DirectedEdge["Stable State", "Fault Detected"], DirectedEdge["Fault Detected", "Rollback Initiated"], DirectedEdge["Rollback Initiated", "Recovery In Progress"], DirectedEdge["Recovery In Progress", "Stable State"]}, {EdgeStyle -> {Arrowheads[0.04]}, GraphLayout -> "CircularEmbedding", PlotLabel -> Style["Self-Stabilising Recovery Cycle", largeFont], VertexLabels -> {"Name"}}];atomicEthernetConcepts=Column[{Style["Atomic-Ethernet \[LongDash] core ideas",largeFont],"\[Bullet] Bipartite token-coherence (not sender \[RightArrow] receiver)","\[Bullet] No message retry; failures roll back then re-apply","\[Bullet] Exactly-once delivery via logical reversibility","\[Bullet] Lossless links remove fast-path time-outs","\[Bullet] Simpler recovery, lower tail-latency, stronger security"},Alignment->Left,Spacings->0.8];Column[{selfStabilizeCycle,Spacer[25],atomicEthernetConcepts},Spacings->3]]


Module[{headerStyle=Style[#1,Bold,16,FontFamily->"Arial"]&,subheaderStyle=Style[#1,Bold,14,FontFamily->"Arial"]&,labelStyle=Style[#1,12,FontFamily->"Arial"]&,classDiagram,forwardingComplexity,atomicTransactionDiagram,topologyDiagram,summaryPanel},classDiagram=Graphics[{{LightBlue,Rectangle[{0,3},{4,5}]},{Black,Thick,Text[subheaderStyle["Class 1 Link (Dedicated)"],{2,4.5}],Text[labelStyle["- Dedicated path reservation"],{2,4}],Text[labelStyle["- Nanosecond setup/teardown"],{2,3.5}]},{LightOrange,Rectangle[{5,3},{9,5}]},{Black,Thick,Text[subheaderStyle["Class 3 Link (Switched)"],{7,4.5}],Text[labelStyle["- DReDDful (Drop, Reorder, etc.)"],{7,4}],Text[labelStyle["- State tables per transaction"],{7,3.5}]},{LightGreen,Rectangle[{2,0},{7,2.5}]},{Black,Thick,Text[subheaderStyle["Open Atomic Ethernet"],{4.5,2.2}],Text[labelStyle["- Bipartite token coherence"],{4.5,1.7}],Text[labelStyle["- Reversible, no-retry transactions"],{4.5,1.2}],Text[labelStyle["- Immediate commit or rollback"],{4.5,0.7}]},Arrowheads[0.03],Arrow[{{2,3},{4.5,2.5}}],Arrow[{{7,3},{4.5,2.5}}]},ImageSize->700,PlotRange->{{-0.5,9.5},{-0.5,5.5}}];forwardingComplexity=Graphics[{{Blue,Thick,Line[{{1,1},{7,1}}],Text[labelStyle["O(N) Local State (Daedaelus)"],{4,1.3}]},Table[{Blue,Disk[{x,1},0.1]},{x,1,7}],{Red,Thick,Line[Table[{x,0.1 x^2+0.5},{x,1,7,0.1}]]},Table[{Red,Disk[{x,0.1 x^2+0.5},0.1]},{x,1,7}],Text[labelStyle["O(N\.b2) Global State (Legacy)"],{4,5.8}]},ImageSize->500,Axes->{True,True},AxesLabel->{"Nodes (N)","State Complexity"},Background->Lighter[Yellow,0.8]];atomicTransactionDiagram=Graphics[{{LightCyan,Disk[{2,2},1.2]},{LightOrange,Disk[{6,2},1.2]},{Black,Thick,Text[labelStyle["Sender"],{2,2}],Text[labelStyle["Receiver"],{6,2}]},{Blue,Arrowheads[0.04],Arrow[{{3.2,2.2},{4.8,2.2}}],Text[labelStyle["Token (Forward)"],{4,2.5}]},{Red,Dashed,Arrowheads[0.03],Arrow[{{4.8,1.8},{3.2,1.8}}],Text[labelStyle["Confirmation"],{4,1.5}]},{Purple,Dotted,Arrowheads[0.03],Arrow[{{6,0.8},{2,0.8}}],Text[labelStyle["Reversal (on Failure)"],{4,0.5}]}},ImageSize->600,PlotRange->{{1,7},{0,3.5}}];topologyDiagram=Graphics[{Table[{LightGray,Rectangle[{i,j},{i+1,j+1}]},{i,0,3},{j,0,3}],Table[Line[{{i+0.5,j+0.5},{i+1.5,j+0.5}}],{i,0,2},{j,0,3}],Table[Line[{{i+0.5,j+0.5},{i+0.5,j+1.5}}],{i,0,3},{j,0,2}],{Red,Disk[{1.5,1.5},0.4]},Text[labelStyle["Root Node"],{1.5,2.1}],{Blue,Arrowheads[0.03],Arrow[{{1.5,1.5},{2.5,1.5}}],Arrow[{{1.5,1.5},{1.5,2.5}}],Text[labelStyle["Local communication"],{2.5,2.5}]},{Purple,Dashed,Circle[{1.5,1.5},2]},Text[labelStyle["Global traffic minimized"],{1.5,3.8}]},ImageSize->500,PlotRange->{{-0.5,4},{-0.5,4.2}}];summaryPanel=Framed[Column[Prepend[(Style["\[FilledRightTriangle] "<>#1,Italic,12,FontFamily->"Arial"]&)/@{"Eliminates timeouts and retries, avoiding cascade failures","Switchless, direct-connected N2N Lattice for low latency","Developers control application-level topologies via GVM","Supports exactly-once semantics via reversible token protocols","Optimized for AI/ML communication patterns with logical overlays","Self-stabilizing and scalable forwarding state management","Compatible with minimal NIC hardware; avoids SmartNIC dependency","Enables new classes of high-performance, deterministic networking"},headerStyle["Open Atomic Ethernet: Key Advantages"]],Spacings->1.2],FrameStyle->Dashed,Background->Lighter[Gray,0.9],RoundingRadius->5];Column[{classDiagram,Spacer[20],forwardingComplexity,Spacer[20],atomicTransactionDiagram,Spacer[20],topologyDiagram,Spacer[20],summaryPanel},Spacings->3]]


Module[{headerStyle={FontFamily->"Arial",FontSize->18,Bold},subHeaderStyle={FontFamily->"Arial",FontSize->14,Bold,Darker[Gray]},bulletStyle={FontFamily->"Arial",FontSize->12,Italic},selfStabilizeCycle,atomicEthernetConcepts},selfStabilizeCycle=Graph[{"Stable State", "Fault Detected", "Rollback Initiated", "Recovery In Progress"}, {DirectedEdge["Stable State", "Fault Detected"], DirectedEdge["Fault Detected", "Rollback Initiated"], DirectedEdge["Rollback Initiated", "Recovery In Progress"], DirectedEdge["Recovery In Progress", "Stable State"]}, {EdgeStyle -> {Arrowheads[0.04]}, GraphLayout -> "CircularEmbedding", ImageSize -> 350, PlotLabel -> Style["Self-Stabilising Fault-Recovery Cycle", subHeaderStyle], VertexLabels -> {"Name"}}];atomicEthernetConcepts=Column[(Style[#1,bulletStyle]&)/@{"Bipartite token-coherence \[Dash] not source/destination packets","No message retries; failures handled by logical reversal","Reversals leave no trace \[Dash] guarantees exactly-once delivery","Lossless link assumption simplifies recovery logic","Endpoints jointly manage forward & reverse states","Design improves security and tail-latency behaviour"},Spacings->0.6,BaseStyle->{FontFamily->"Arial",FontSize->12}];Column[{Style["Open Atomic Ethernet \[Dash] Selected Visuals",headerStyle],selfStabilizeCycle,Spacer[8],Style["Key Concepts",subHeaderStyle],atomicEthernetConcepts},Spacings->6,Alignment->Center]]


Module[{largeFont=Directive[FontSize->14,Bold],smallFont=Directive[FontSize->10,FontFamily->"Arial"],selfStabilizeCycle,atomicEthernetConcepts},selfStabilizeCycle=Graph[{"Stable State", "Fault Detected", "Rollback Initiated", "Recovery In Progress"}, {DirectedEdge["Stable State", "Fault Detected"], DirectedEdge["Fault Detected", "Rollback Initiated"], DirectedEdge["Rollback Initiated", "Recovery In Progress"], DirectedEdge["Recovery In Progress", "Stable State"]}, {EdgeStyle -> {Arrowheads[0.04]}, GraphLayout -> "CircularEmbedding", PlotLabel -> Style["Self-Stabilising Recovery Cycle", largeFont], VertexLabels -> {"Name"}}];atomicEthernetConcepts=Column[{Style["Atomic-Ethernet \[LongDash] Core Ideas",largeFont],"\[Bullet] Bipartite token-coherence (not sender \[RightArrow] receiver)","\[Bullet] No message retry; failures roll back then re-apply","\[Bullet] Exactly-once delivery via logical reversibility","\[Bullet] Loss-free links eliminate fast-path time-outs","\[Bullet] Simpler recovery, lower tail-latency, stronger security"},Alignment->Left,Spacings->0.8];Column[{selfStabilizeCycle,Spacer[25],atomicEthernetConcepts},Spacings->3]]


ListPlot[{Table[{n,n},{n,1,40}],Table[{n,n^2/4},{n,1,40}]},PlotStyle->{Blue,Red},PlotLegends->{"Neighbour-only (O(N))","Global probes (O(N\.b2))"},Frame->True,FrameLabel->{"Node count N","Per-node table entries"},PlotLabel->Style["Forwarding-State Growth",14,Bold],ImageSize->450]


Module[{meshDim=4,coords,meshEdges,hEdges,path,edgeSty,plotLabel=Style["4\[Times]4 HammingMesh Tile (N2N Lattice + AIT Path)",14,Bold]},coords=Flatten[Table[{i,j},{j,meshDim,1,-1},{i,1,meshDim}],1];meshEdges=UndirectedEdge@@@Select[Subsets[Range[meshDim^2],{2}],EuclideanDistance@@coords[[#1]]==1&];hEdges=UndirectedEdge@@@Select[Subsets[Range[meshDim^2],{2}],With[{v1=coords[[#1[[1]]]],v2=coords[[#1[[2]]]]},EuclideanDistance[v1,v2]==Sqrt[2]&&(EvenQ[Total[v1]]\[Xor]EvenQ[Total[v2]])]&];path=UndirectedEdge@@@Partition[{1,2,6,10,11,15,16},2,1];edgeSty[e_]:=Which[MemberQ[path,e]||MemberQ[path,Reverse[e]],Directive[Red,Thick],MemberQ[hEdges,e]||MemberQ[hEdges,Reverse[e]],Directive[Green,Dashed],True,Directive[Gray,Thin]];Graph[Join[meshEdges,hEdges],VertexCoordinates->coords,VertexLabels->Placed["Name",Center],VertexSize->.3,EdgeStyle->{e_:>edgeSty[e]},PlotLabel->plotLabel,ImageSize->500]]


ResourceFunction["DarkMode"][];

nb=EvaluationNotebook[];
SetOptions[nb,Background->RGBColor[0.1,0.1,0.1]];

