(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



nb=EvaluationNotebook[];
SetOptions[nb,Background->RGBColor[0.1,0.1,0.1]];
ResourceFunction["DarkMode"][];


nb=EvaluationNotebook[];
SetOptions[nb,StyleDefinitions->"Default.nb",DefaultNewCellStyle->"Input",Background->Automatic];
OptionRemove[nb,Background];


ClearAll[OctagonalMesh,HighlightDead];
OctagonalMesh[n_Integer]:=Module[{pts,edges},pts=Flatten[Table[{i,j},{i,0,n-1},{j,0,n-1}],1];edges=Flatten[Table[With[{p=pts[[k]]},Select[(p\[UndirectedEdge]p+d&)/@DeleteCases[Tuples[{-1,0,1},2],{0,0}],MemberQ[pts,Last[#1]]&]],{k,Length[pts]}],1];Graph[pts,edges,VertexCoordinates->pts,VertexStyle->White,EdgeStyle->GrayLevel[0.7],VertexSize->0.03,PlotTheme->"Business"]];
HighlightDead[g_Graph,deadVerts:{__List},deadEdges:{__UndirectedEdge}]:=Module[{vv,es,coords},vv=VertexList[g];es=EdgeList[g];coords=vv;Graph[vv,es,VertexCoordinates->coords,VertexStyle->Thread[vv->(If[MemberQ[deadVerts,#1],Red,White]&)/@vv],EdgeStyle->Thread[es->(If[MemberQ[deadEdges,#1],Red,GrayLevel[0.7]]&)/@es],VertexSize->0.03,PlotTheme->"Business"]];
mesh=OctagonalMesh[5];
meshDead=HighlightDead[mesh,{{2,2}},{{1,1}\[UndirectedEdge]{2,2}}];
GraphicsRow[{mesh,meshDead},ImageSize->Large]


ClearAll[OctagonalMesh,HighlightDead];
OctagonalMesh[n_Integer]:=Module[{pts,edges},pts=Flatten[Table[{i,j},{i,0,n-1},{j,0,n-1}],1];edges=Flatten[Table[With[{p=pts[[k]]},Table[If[MemberQ[pts,p+d],p\[UndirectedEdge]p+d,Nothing],{d,DeleteDuplicates[Tuples[{-1,0,1},2]/. {0,0}->Sequence[]]}]],{k,Length[pts]}],1];Graph[pts,edges,VertexCoordinates->pts,VertexStyle->White,EdgeStyle->GrayLevel[0.7],VertexSize->0.03,PlotTheme->"Business"]];
HighlightDead[g_Graph,deadVerts:{_List..},deadEdges:{__UndirectedEdge}]:=Module[{allV,allE,baseOpts},allV=VertexList[g];allE=EdgeList[g];baseOpts=FilterRules[Options[g],Except[{VertexStyle,EdgeStyle}]];Graph[allV,allE,Sequence@@baseOpts,VertexStyle->{Complement[allV,deadVerts]->White,deadVerts->Red},EdgeStyle->{Complement[allE,deadEdges]->GrayLevel[0.7],deadEdges->Red}]];
mesh=OctagonalMesh[5];
meshDead=HighlightDead[mesh,{{2,2}},{{1,1}\[UndirectedEdge]{2,2}}];
GraphicsRow[{mesh,meshDead},ImageSize->Large];
ClearAll[ClosFabric,SpanningMetrics];
ClosFabric[k_Integer,d_Integer]:=Module[{layers,edges},layers=Table[Table[{i,layer},{i,k^(layer-1)}],{layer,1,d}];edges=Flatten[Table[With[{src=layers[[\[ScriptL],i]],tgt=layers[[\[ScriptL]+1]]},Table[src\[UndirectedEdge]v,{v,tgt}]],{\[ScriptL],1,d-1},{i,Length[layers[[\[ScriptL]]]]}],2];Graph[Flatten[layers,1],edges]];
SpanningMetrics[g_Graph]:=Module[{st,hopMat},st=FindSpanningTree[g];hopMat=GraphDistanceMatrix[st];Association["MaxHopCount"->Max[hopMat],"TotalLinks"->EdgeCount[st]]];
clos=ClosFabric[2,4]
metricsClos=SpanningMetrics[clos];
metricsMesh=SpanningMetrics[mesh];
{metricsClos,metricsMesh}


ClearAll[MakeSlice,InvertSlice,SendSnake];
MakeSlice[data_List]:=data;
InvertSlice[data_List]:=Reverse[data];
SendSnake[nslices_Integer]:=Module[{path,returned},path=Table[RandomInteger[{0,255},8],{nslices}];returned=(InvertSlice@*InvertSlice)/@path;If[path===returned,"ACK","Error"]];
TableForm[Table[{n,SendSnake[n]},{n,1,5}],TableHeadings->{None,{"NumSlices","Result"}}]


packetBits=64 8;
ackBits=8 8;
linkMeters=10;
propSpeed=2.0*^8;
reactionTime=6/10^9;
capacity=10^10;
packetTime=packetBits/capacity;
ackTime=ackBits/capacity;
latency=(2 linkMeters)/propSpeed;
roundTrip=latency+2 reactionTime;
numSnakes=Floor[roundTrip/packetTime];
throughputFactor=(numSnakes packetTime)/roundTrip;
Grid[{{"Tp (s)",packetTime},{"Ta (s)",ackTime},{"Round-trip (s)",roundTrip},{"# snakes",numSnakes},{"Ideal M",NumberForm[throughputFactor,{3,2}]}},Frame->All];
ClearAll[snakeSegmentPrimitives];
snakeSegmentPrimitives[t_]:=Module[{l,posList},l=packetTime/roundTrip;posList=Mod[Range[0,numSnakes-1] l+Mod[t/roundTrip,1],1];Flatten[Table[With[{col=ColorData["Rainbow"][i/numSnakes],p=posList[[i]]},If[p+l<=1,{col,Thick,Line[{{p,0},{p+l,0}}]},{col,Thick,Line[{{p,0},{1,0}}],col,Thick,Line[{{0,0},{p+l-1,0}}]}]],{i,1,numSnakes}],1]];
Graphics[{Thick,Gray,Line[{{0,0},{1,0}}],Orange,Evaluate[Sequence@@snakeSegmentPrimitives[0.3 roundTrip]]},Axes->False,PlotRange->{{-0.05,1.05},{-0.5,0.5}},ImageSize->600]
Animate[Graphics[{Thick,Gray,Line[{{0,0},{1,0}}],Evaluate[Sequence@@snakeSegmentPrimitives[t]]},Axes->False,PlotRange->{{-0.05,1.05},{-0.5,0.5}},ImageSize->600,Background->Black],{t,0,roundTrip,Appearance->"Labeled"},AnimationRate->0.5/roundTrip,AnimationRunning->False]
ListLinePlot[Table[{n,(n packetTime)/roundTrip},{n,1,numSnakes+2}],AxesLabel->{"SN (snakes)","M = n\[CenterDot]Tp/RoundTrip"},PlotMarkers->Automatic,PlotRange->All,GridLines->Automatic]


packetBits=64 8;
ackBits=8 8;
linkMeters=10;
propSpeed=2.0*^8;
reactionTime=6/10^9;
capacity=10^10;
packetTime=packetBits/capacity;
ackTime=ackBits/capacity;
latency=(2 linkMeters)/propSpeed;
roundTrip=latency+2 reactionTime;
numSnakes=Floor[roundTrip/packetTime];
throughputFactor=(numSnakes packetTime)/roundTrip;
Grid[{{"Tp (s)",packetTime},{"Ta (s)",ackTime},{"Round-trip (s)",roundTrip},{"# snakes",numSnakes},{"Ideal M",NumberForm[throughputFactor,{3,2}]}},Frame->All]
snakeSegments[t_]:=Module[{l=packetTime/roundTrip,positions},positions=Mod[Range[0,numSnakes-1] l+Mod[t/roundTrip,1],1];Flatten[Table[If[pos+l<=1,{{pos,pos+l}},{{pos,1},{0,pos+l-1}}],{pos,positions}],1]];
Graphics[Flatten[{{Thick,Gray,Line[{{0,0},{1,0}}]},Orange,({Thick,Line[{{#1[[1]],0},{#1[[2]],0}}]}&)/@snakeSegments[0.3 roundTrip]}],Axes->False,PlotRange->{{-0.05,1.05},{-0.5,0.5}},ImageSize->600]
Animate[Graphics[Flatten[{{Thick,Gray,Line[{{0,0},{1,0}}]},MapIndexed[{Thick,ColorData["Rainbow"][First[#2]],Line[{{#1[[1]],0},{#1[[2]],First[#2]}}]}&,snakeSegments[t]]}],PlotRange->{{-0.05,1.05},{-0.5,0.5}},ImageSize->600,Background->Black],{t,0,roundTrip,Appearance->"Labeled"},AnimationRate->0.5/roundTrip,AnimationRunning->False]
ListLinePlot[Table[{n,(n packetTime)/roundTrip},{n,1,numSnakes+2}],AxesLabel->{"SN (snakes)","M = n\[CenterDot]Tp/RoundTrip"},PlotMarkers->Automatic,PlotRange->All,GridLines->Automatic]


Options[createN2NLattice]={"MissingCells"->{},"MissingLinks"->{},"LiveLinkStyle"->Directive[GrayLevel[0.4]],"DeadLinkStyle"->Directive[Red,Dashed,Thick],"TreeStyle"->Directive[RGBColor[0.2,0.4,0.8],Thick],"HighlightTree"->None};
createN2NLattice[width_Integer,height_Integer,opts:OptionsPattern[]]:=Module[{nodes,gridGraph,diagGraph,allLinks,liveLinks,finalGraph,treeEdges},nodes=Range[width height];gridGraph=GridGraph[{width,height}];diagGraph=GridGraph[{width,height},VertexLabels->"Name",GraphLayout->"SpringElectricalEmbedding",EdgeStyle->Opacity[0.1],VertexCoordinates->Tuples[{Range[width],Range[height]}]];allLinks=Sort/@EdgeList[gridGraph]\[Union]Flatten[Table[Sort/@{If[x<width&&y<height,(y-1) width+x\[UndirectedEdge]y width+x+1,Unevaluated[Sequence[]]],If[x>1&&y<height,(y-1) width+x\[UndirectedEdge]y width+x-1,Unevaluated[Sequence[]]]},{y,1,height},{x,1,width}]];liveLinks=Complement[allLinks,OptionValue["MissingLinks"]];finalGraph=Graph[Complement[nodes,OptionValue["MissingCells"]],liveLinks,VertexCoordinates->GraphEmbedding[diagGraph],VertexStyle->Black,VertexSize->Medium,EdgeStyle->OptionValue["LiveLinkStyle"],ImageSize->Large];If[OptionValue["HighlightTree"]=!=None,treeEdges=EdgeList[FindSpanningTree[finalGraph,OptionValue["HighlightTree"]]];HighlightGraph[finalGraph,treeEdges,EdgeStyle->OptionValue["TreeStyle"]],finalGraph]];
Manipulate[createN2NLattice[12,6,"MissingCells"->ToExpression[StringSplit[missingCells,","]],"MissingLinks"->Table[ToExpression[e],{e,StringSplit[missingLinks,","]/. ""->Sequence[]}],"HighlightTree"->If[treeRoot>0,treeRoot,None]],{{missingCells,"15,30,31"},Text,Label->"Missing Cells (e.g., 15,30,31)"},{{missingLinks,"{16\[UndirectedEdge]17, 42\[UndirectedEdge]54}"},Text,Label->"Missing Links (e.g., {16\[UndirectedEdge]17})"},{{treeRoot,1,"Spanning Tree Root (0 for None)"},0,72,1,Appearance->"Labeled"},ControlPlacement->Top]
createClosGraph[servers_]:=Module[{torSwitches,spineSwitches,allNodes,links},torSwitches=Ceiling[servers/4];spineSwitches=Ceiling[torSwitches/2];allNodes=Range[servers+torSwitches+spineSwitches];links=Join[Flatten[Table[i\[UndirectedEdge]servers+Ceiling[i/4],{i,1,servers}]],Flatten[Table[servers+j\[UndirectedEdge]servers+torSwitches+Ceiling[j/2],{j,1,torSwitches}]]];Graph[allNodes,links,GraphLayout->"LayeredDrawing",ImageSize->Medium]];
countSpanningTrees[g_Graph]:=If[ConnectedGraphQ[g],Round[Det[KirchhoffMatrix[g][[2;;All,2;;All]]]],0];
Manipulate[Module[{n2n,clos,n2nWithFailures,closWithFailures,n2nHops,closHops},n2n=createN2NLattice[8,4];clos=createClosGraph[32];SeedRandom[123];failedNodesN2N=RandomSample[VertexList[n2n],failures];failedNodesClos=RandomSample[Take[VertexList[clos],32],failures];n2nWithFailures=VertexDelete[n2n,failedNodesN2N];closWithFailures=VertexDelete[clos,failedNodesClos];n2nHops=If[ConnectedGraphQ[n2nWithFailures],N[Mean[GraphDistanceMatrix[n2nWithFailures]]],\[Infinity]];closHops=If[ConnectedGraphQ[closWithFailures],N[Mean[GraphDistanceMatrix[closWithFailures]]],\[Infinity]];Grid[{{Style["Daedaelus N2N Lattice",Bold,14],Style["Traditional Clos Fabric",Bold,14]},{Show[n2n,ImageSize->400],Show[clos,ImageSize->400]},{Style["After "<>ToString[failures]<>" Node Failures",Bold,12,\[SpanFromLeft]]},{Show[HighlightGraph[n2n,failedNodesN2N,VertexStyle->Red,VertexSize->Large],ImageSize->400],Show[HighlightGraph[clos,failedNodesClos,VertexStyle->Red,VertexSize->Large],ImageSize->400]},{Style["Metrics",Bold,12,\[SpanFromLeft]]},{Grid[{{"Link Count:",EdgeCount[n2n]},{"Avg. Hop Count:",Round[Mean[GraphDistanceMatrix[n2n]],0.1]},{"Spanning Trees:",ScientificForm[countSpanningTrees[n2n],3]},{"Avg. Hop Count (After Failures):",Round[n2nHops,0.1]},{"Spanning Trees (After Failures):",ScientificForm[countSpanningTrees[n2nWithFailures],3]}},Alignment->Left],Grid[{{"Link Count:",EdgeCount[clos]},{"Avg. Hop Count:",Round[Mean[GraphDistanceMatrix[clos]],0.1]},{"Spanning Trees:",ScientificForm[countSpanningTrees[clos],3]},{"Avg. Hop Count (After Failures):",Round[closHops,0.1]},{"Spanning Trees (After Failures):",ScientificForm[countSpanningTrees[closWithFailures],3]}},Alignment->Left]}},Spacings->{1,2},Frame->All]],{{failures,2,"Number of Node Failures"},0,10,1,Appearance->"Labeled"},ControlPlacement->Top]
triangleGraph=Graph[{1->2,2->3,3->1},VertexLabels->{"A","B","C"},VertexCoordinates->CirclePoints[3],ImageSize->300];
forwardEvolution[state_]:=Switch[state,{1,2,tok_},{2,3,1-tok},{2,3,tok_},{3,1,1-tok},{3,1,tok_},{1,2,1-tok}];
reverseEvolution[state_]:=Switch[state,{2,3,tok_},{1,2,1-tok},{3,1,tok_},{2,3,1-tok},{1,2,tok_},{3,1,1-tok}];
drawToken[{source_,dest_,tokenValue_}]:=Module[{pt1,pt2,mid,color},pt1=GraphEmbedding[triangleGraph][[source]];pt2=GraphEmbedding[triangleGraph][[dest]];mid=Mean[{pt1,pt2}];color=If[tokenValue==0,RGBColor[0.2,0.6,0.2],RGBColor[0.2,0.2,0.8]];{Arrowheads[0.05],color,Arrow[{pt1,pt2}],White,EdgeForm[Black],Disk[mid,0.1],Black,Text[Style[ToString[tokenValue],12],mid]}];
Animate[Module[{currentState,history,faultStep=5,recoveryStep=7,statusText,statusColor},history=NestList[forwardEvolution,{1,2,0},10];currentState=Which[step<faultStep,history[[step+1]],step==faultStep,history[[step]],step>faultStep&&step<recoveryStep,Nest[reverseEvolution,history[[step]],recoveryStep-1-step],step>=recoveryStep,Nest[forwardEvolution,history[[step]],step-recoveryStep+2]];{statusText,statusColor}=Which[step<faultStep,{"Forward Evolution",Darker[Green]},step==faultStep,{"FAULT INJECTED - Transaction Failed",Red},step>faultStep&&step<recoveryStep,{"Reverse Evolution (Rollback)",Orange},step>=recoveryStep,{"Forward Evolution (Recovered)",Darker[Green]}];Show[triangleGraph,Graphics[{Text[Style[statusText,Bold,14,statusColor],{0,1.3}],Text[Style["Step: "<>ToString[step],12],{0,-1.3}],drawToken[currentState]}],PlotRange->{{-1.5,1.5},{-1.5,1.5}}]],{step,0,10,1},AnimationRate->0.7,AnimationRepetitions->\[Infinity]]


triangleGraph=Graph[{"A","B","C"},{"A"<->"B","B"<->"C","C"<->"A"},VertexCoordinates->CirclePoints[3],VertexLabels->Placed["Name",Center,Style[#1,White,Bold,18]&],VertexSize->Large,VertexStyle->Gray,ImageSize->400];
Manipulate[Module[{currentNode,nextNode,edge,pos,color,label},currentNode=VertexList[triangleGraph][[Mod[s-1,3]+1]];nextNode=VertexList[triangleGraph][[Mod[s,3]+1]];If[direction==="Forward",edge=currentNode\[UndirectedEdge]nextNode;color=RGBColor[0.2,0.8,0.2];label=Style["Forward Progress (+1)",14,Black];,edge=nextNode\[UndirectedEdge]currentNode;color=RGBColor[1,0,0];label=Style["Reverse Progress (-1)",14,Black];];pos=(1-p) PropertyValue[{triangleGraph,currentNode},VertexCoordinates]+p PropertyValue[{triangleGraph,nextNode},VertexCoordinates];Show[HighlightGraph[triangleGraph,{Style[edge,color,Thick],Style[currentNode,color]}],Graphics[{color,Disk[pos,0.15],Text[label,{0,-1.5}]}],PlotLabel->Style[StringTemplate["Transaction State: Step `s`\nToken Holder: `node`"][Association["s"->s,"node"->currentNode/. {"A"->"Alice","B"->"Bob","C"->"Charlie"}]],16,"Panel"]]],{{s,1,"Step"},1,100,1,Appearance->"Labeled"},{{p,0,"Progress"},0,1,Animator,AnimationRunning->True,AnimationRate->0.5},{{direction,"Forward"},{"Forward","Reverse"},ControlType->RadioButtonBar},ControlPlacement->Top,SynchronousUpdating->True,ControllerMethod->{"Rate"->0.5},Initialization:>{Dynamic[If[p==1,If[direction=="Forward",s=Mod[s,3]+1,s=If[s==1,3,s-1]];p=0;]]}]


ClearAll["Global`*"]
sliceSizeBytes=8;
nVertebrae=8;
channelCapacity=10000000000;
linkLatency=1/100000000;
reactionTime=3/500000000;
sliceBitTime:=(sliceSizeBytes 8)/channelCapacity
frameBitTime:=nVertebrae sliceBitTime
M[n_]:=(n sliceBitTime)/(linkLatency+2 reactionTime)
Clear[InvertSlice]
InvertSlice[slice_Integer]:=BitXor[slice,2^(sliceSizeBytes 8)-1]
Clear[CreateSnake]
CreateSnake[data_List]/;Length[data]==nVertebrae:=data
Clear[InitializeLink]
InitializeLink[L_Integer?Positive]:=ConstantArray[None,L]
ClearAll[sendFIFO,recvFIFO]
sendFIFO={};
recvFIFO={};
Clear[StepProtocol]
StepProtocol[link_List]:=Module[{newLink,head,tail,transformed},tail=Last[link];newLink=Prepend[Most[link],None];If[tail=!=None,transformed=InvertSlice[tail];AppendTo[recvFIFO,transformed];];If[sendFIFO=!={},head=First[sendFIFO];newLink[[1]]=head;sendFIFO=Rest[sendFIFO];];newLink]
linkLengthSlices=Ceiling[linkLatency/sliceBitTime]+nVertebrae;
link=InitializeLink[linkLengthSlices];
snake=CreateSnake[Range[0,nVertebrae-1]];
sendFIFO=snake;
recvFIFO={};
ticks=linkLengthSlices+nVertebrae+2;
Do[link=StepProtocol[link],{ticks}];
recvFIFO


ClearAll["Global`*"];
bitRate=100000000000;
sliceSizeBytes=8;
fifoSlices=8;
propagationSpeed=200000000;
reactionTime=0;
sliceBits:=sliceSizeBytes 8;
sliceTime:=sliceBits/bitRate;
propDelay[L_]:=L/propagationSpeed;
roundTripLatency[L_]:=2 propDelay[L]+2 reactionTime;
slicesInWire[L_]:=Floor[roundTripLatency[L]/sliceTime];
activeSlices[L_]:=Min[fifoSlices,slicesInWire[L]];
handshakeTime[L_]:=roundTripLatency[L]+(activeSlices[L]-1) sliceTime;
throughput[L_]:=(activeSlices[L] sliceBits)/handshakeTime[L];
utilization[L_]:=throughput[L]/bitRate;
Plot[utilization[L],{L,0,2000},PlotRange->{0,1.1},AxesLabel->{"Cable Length L (m)","Utilization M"},LabelStyle->{FontFamily->"Helvetica",FontSize->14},PlotStyle->Thick,GridLines->Automatic,ImageSize->Large,PlotLegends->Placed[{"Slice Protocol M(L)"},{0.7,0.3}]]


ClearAll["Global`*"];
sliceSizeBytes=8;
channelCapacity=10.^9;
Tp:=(sliceSizeBytes 8)/channelCapacity;
reactionTime=6./10^9;
linkLatencies=Range[1,100] Tp;
numSnakes[lat_]:=Floor[lat/Tp]+1;
throughputDegradation[lat_]:=Min[(numSnakes[lat] Tp)/(lat+2 reactionTime),1];
Mvalues=throughputDegradation/@linkLatencies;
ListLinePlot[Transpose[{linkLatencies/Tp,Mvalues}],AxesLabel->{"Link Latency / Tp","Degradation Factor M"},PlotRange->{0,1},PlotLabel->Style["Slice\[Hyphen]Protocol Degradation Factor",14],GridLines->Automatic,ImageSize->Large]
invertSlice[bytes_List]:=(BitXor[#1,2^8-1]&)/@bytes;
testSlice=RandomInteger[{0,2^8-1},sliceSizeBytes];
assertion=invertSlice[invertSlice[testSlice]]===testSlice;
Print["Round\[Hyphen]trip inversion yields original slice? ",assertion];


ClearAll["Global`*"];
vertebraeCount=8;
linkLengthSlices=16;
totalTimeSteps=100;
reactionDelay=1;
ReverseSlice[data_Integer]:=Module[{bits},bits=IntegerDigits[data,2,64];bits=Reverse[bits];FromDigits[bits,2]];
CreateSnake[]:=RandomInteger[{0,2^64-1},vertebraeCount];
InitializeLink[]:=ConstantArray[None,linkLengthSlices];
SimulateSliceProtocol[]:=Module[{link=InitializeLink[],snake,sent,received={},stats={}},snake=CreateSnake[];sent=snake;Do[If[sent=!={}&&link[[1]]===None,link[[1]]=First[sent];sent=Rest[sent];];If[link[[-1]]=!=None,link[[-1]]=ReverseSlice[link[[-1]]];];If[reactionDelay>1,Pause[reactionDelay/10^3];];link=RotateRight[link];If[link[[1]]=!=None,link[[1]]=ReverseSlice[link[[1]]];];If[link[[1]]=!=None,AppendTo[received,link[[1]]];link[[1]]=None;];AppendTo[stats,Length[received]];,{t,1,totalTimeSteps}];stats];
stats=SimulateSliceProtocol[];
ListLinePlot[stats,AxesLabel->{"Time Step","Recovered Slices"},PlotRange->All,PlotTheme->"Detailed",ImageSize->Large]


DynamicModule[{numFlows=4,bandwidth=100000000,rtt=0.01,packetLoss=0.001,mss=1500,simTime=1,data},mathis[mss_,rtt_,p_]:=(mss 8)/(rtt Sqrt[p]);tcpThroughput[numFlows_,bandwidth_,rtt_,packetLoss_]:=Min[bandwidth/numFlows,mathis[mss,rtt,packetLoss numFlows]];updateData[]:=data=Table[tcpThroughput[n,bandwidth,rtt,packetLoss],{n,1,numFlows}];updateData[];Column[{Row[{"Number of Flows: ",Slider[Dynamic[numFlows,(numFlows=#1;updateData[])&],{1,10,1}]}],Row[{"Bandwidth (bps): ",InputField[Dynamic[bandwidth,(bandwidth=#1;updateData[])&],Number]}],Row[{"Base RTT (s): ",InputField[Dynamic[rtt,(rtt=#1;updateData[])&],Number]}],Row[{"Packet Loss Rate: ",InputField[Dynamic[packetLoss,(packetLoss=#1;updateData[])&],Number]}],Dynamic[ListLinePlot[data/10^6,PlotRange->All,AxesLabel->{"Number of Flows","Throughput per Flow (Mbps)"},PlotLabel->"TCP Throughput with Bandwidth Multiplexing"]]}]]


DynamicModule[{numPairs=4,bandwidth=100000000,rtt=0.01,packetSize=1500,simTime=0.1,bandwidthData,interactionData},runSim[]:=(bandwidthData=Table[Module[{time=0,totalBytes=0,flowBytes=Table[0,{i,1,n}],activeFlow=1},While[time<simTime,flowBytes[[activeFlow]]+=packetSize 8;time+=(packetSize 8)/bandwidth+rtt;totalBytes+=packetSize;activeFlow=Mod[activeFlow,n]+1;];totalBytes/simTime],{n,1,numPairs}];interactionData=Table[Module[{time=0,totalBytes=0,flowBytes=Table[0,{i,1,n}]},While[time<simTime,For[i=1,i<=n,i++,flowBytes[[i]]+=packetSize;totalBytes+=packetSize;];time+=(packetSize 8 n)/bandwidth+rtt;];totalBytes/simTime],{n,1,numPairs}];);runSim[];Column[{Row[{"Number of Pairs: ",Slider[Dynamic[numPairs,(numPairs=#1;runSim[])&],{1,10,1}]}],Dynamic[ListLinePlot[{bandwidthData/10^6,interactionData/10^6},PlotLegends->{"Bandwidth Multiplexing","Interaction Multiplexing"},AxesLabel->{"Number of Pairs","Total Throughput (Mbps)"},PlotLabel->"Throughput Comparison",PlotRange->All]]}]]


Manipulate[totalSlices=8;fifoSize=8;sliceWidth=0.5;sliceHeight=0.5;linkLength=20;aliceColor=RGBColor[0.6,0.8,1];bobColor=RGBColor[1,0.8,0.6];makeSlice[pos_,color_,value_]:={color,Rectangle[pos-{sliceWidth/2,sliceHeight/2},pos+{sliceWidth/2,sliceHeight/2}],Black,Text[value,pos]};invertSlice[slice_]:=BitXor[slice,255];If[time==0,{aliceSnake=Table[{i sliceWidth,1},{i,totalSlices}];bobSnake=Table[{linkLength-i sliceWidth,-1},{i,totalSlices}];aliceData=RandomInteger[{0,255},totalSlices];bobData=RandomInteger[{0,255},totalSlices];aliceFIFO=ConstantArray[0,fifoSize];bobFIFO=ConstantArray[0,fifoSize];}];aliceSnake=({#1[[1]]+speed,#1[[2]]}&)/@aliceSnake;bobSnake=({#1[[1]]-speed,#1[[2]]}&)/@bobSnake;Do[If[aliceSnake[[i,1]]>=linkLength,bobFIFO=Prepend[Drop[bobFIFO,-1],invertSlice[aliceData[[i]]]];aliceSnake[[i,1]]=0;];If[bobSnake[[i,1]]<=0,aliceFIFO=Prepend[Drop[aliceFIFO,-1],invertSlice[bobData[[i]]]];bobSnake[[i,1]]=linkLength;];,{i,totalSlices}];Graphics[{Thickness[0.01],Line[{{0,1},{linkLength,1}}],Line[{{0,-1},{linkLength,-1}}],Text[Style["Alice",Large],{-2,0}],Text[Style["Bob",Large],{linkLength+2,0}],Table[makeSlice[aliceSnake[[i]],aliceColor,aliceData[[i]]],{i,totalSlices}],Table[makeSlice[bobSnake[[i]],bobColor,bobData[[i]]],{i,totalSlices}],Text[Style["Alice's FIFO",Medium],{-4,3}],Inset[ArrayPlot[{aliceFIFO},Mesh->All,ImageSize->{200,25},ColorFunction->GrayLevel],{-4,2}],Text[Style["Bob's FIFO",Medium],{linkLength+4,3}],Inset[ArrayPlot[{bobFIFO},Mesh->All,ImageSize->{200,25},ColorFunction->GrayLevel],{linkLength+4,2}]},PlotRange->{{-5,linkLength+5},{-5,5}},ImageSize->Large],{{speed,0.1,"Speed"},0.01,1,0.01},{{time,0,"Time"},0,100,0.1,Animator}]


Manipulate[Module[{speedOfLightInCopper=2.3*^8,bitsPerByte=8,slotTime,metcalfePacketBits,acquisitionProbabilityA,meanWaitingSlotsW,metcalfeEfficiency,aethernetPacketBits,packetTxTime,roundTripDelay,aethernetEfficiency,metcalfeData,aethernetData,plotLabel},metcalfePacketBits=packetSize bitsPerByte;slotTime=(2 linkLength)/speedOfLightInCopper;acquisitionProbabilityA[q_]:=Which[q<1,1,q==1,1,q>1,(q (1-1/q)^(q-1))/q];meanWaitingSlotsW[a_]:=(1-a)/a;metcalfeEfficiency[q_]:=Module[{a,w},a=acquisitionProbabilityA[q];If[a==0,Return[0]];w=meanWaitingSlotsW[a];metcalfePacketBits/(linkSpeed (metcalfePacketBits/linkSpeed+w slotTime))];metcalfeData=Table[{q,metcalfeEfficiency[q]},{q,1,256,5}];aethernetPacketBits=64 bitsPerByte;packetTxTime=aethernetPacketBits/linkSpeed;roundTripDelay=slotTime+ackProcessingTime/1000000000;aethernetEfficiency=Min[1,packetTxTime/roundTripDelay];aethernetData=Table[{q,aethernetEfficiency},{q,1,256,5}];plotLabel=Grid[{{"Metcalfe Model",\[SpanFromLeft]},{"Packet Size (P):",packetSize,"Bytes"},{"Slot Time (T):",NumberForm[slotTime 1000000000,{3,2}],"ns"},{\[SpanFromLeft],\[SpanFromLeft]},{"\[CapitalAE]thernet Model",\[SpanFromLeft]},{"Record Size:","64 Bytes (Fixed)"},{"Transmission Time:",NumberForm[packetTxTime 1000000000,{3,2}],"ns"},{"Round Trip Delay:",NumberForm[roundTripDelay 1000000000,{3,2}],"ns"},{"Efficiency (M):",NumberForm[aethernetEfficiency 100,{3,1}],"%"}},Alignment->Left];ListLinePlot[{metcalfeData,aethernetData},PlotRange->{{0,260},{0,1.05}},AxesLabel->{"Number of Contending Stations (Q)","Efficiency (E)"},PlotLegends->{"Classical Ethernet (Metcalfe Model)","\[CapitalAE]thernet (Point-to-Point Slice Protocol)"},GridLines->Automatic,PlotLabel->"The Efficiency Showdown: Contention vs. Interaction",Epilog->Inset[plotLabel,Scaled[{0.7,0.4}]]]],{{linkSpeed,100000000000,"Link Speed (bps)"},{10000000000,25000000000,100000000000,400000000000},ControlType->SetterBar},{{linkLength,1.0,"Link Length (m)"},0.1,10,0.1,Appearance->"Labeled"},{{packetSize,512,"Metcalfe Packet Size (Bytes)"},{64,512,1500,9000},ControlType->PopupMenu},{{ackProcessingTime,5.0,"Ack Processing Time (ns)"},0,20,0.5,Appearance->"Labeled"},LabelStyle->{Bold,Medium}]


Manipulate[speedOfSignalInCopper=(299792458 2)/3;propagationDelay=linkLength/speedOfSignalInCopper;transmissionTimeData=(packetSize 8)/(linkBandwidth 10^9);transmissionTimeAck=(ackSize 8)/(linkBandwidth 10^9);roundTripTime=2 propagationDelay;classicCycleTime=transmissionTimeData+roundTripTime+transmissionTimeAck;classicEfficiency=transmissionTimeData/classicCycleTime;daedalusIdleTime=Max[0,roundTripTime-transmissionTimeData];daedalusCycleTime=transmissionTimeData+daedalusIdleTime;daedalusEfficiency=transmissionTimeData/daedalusCycleTime;maxTime=Max[classicCycleTime,daedalusCycleTime] 1.1;timelineGraphics[eff_,cycleTime_,idleTimeStart_,idleTimeEnd_,title_]:=Graphics[{Arrowheads[0.02],Arrow[{{0,0},{maxTime,0}}],Text[Style["Time (\[Mu]s)",10],{maxTime,0},{-1.1,-1.5}],Table[{Line[{{t,-0.1},{t,0.1}}],Text[ToString[Round[t 1000000,0.01]],{t,-0.1},{0,1.5}]},{t,0,maxTime,maxTime/5}],Text[Style["Sender",Bold,12],{0,1.5},{1.5,0}],{EdgeForm[Black],FaceForm[RGBColor[0.2,0.6,0.8]],Rectangle[{0,1},{transmissionTimeData,1.3}]},Text["Transmit Data",{transmissionTimeData/2,1.15}],Text[Style["Receiver",Bold,12],{0,-1.5},{1.5,0}],{EdgeForm[Black],FaceForm[RGBColor[0.8,0.6,0.2]],Rectangle[{idleTimeStart,-1},{idleTimeEnd,-1.3}]},Text["Transmit ACK",{(idleTimeStart+idleTimeEnd)/2,-1.15}],{Dashed,Thick,Arrowheads[0.02],Arrow[{{0,1},{propagationDelay,-1.3}}]},{Dashed,Thick,Arrowheads[0.02],Arrow[{{idleTimeStart,-1.3},{idleTimeStart+propagationDelay,1}}]},If[idleTimeStart>transmissionTimeData,{{FaceForm[RGBColor[1,0.8,0.8]],Rectangle[{transmissionTimeData,1},{idleTimeStart,1.3}]},Text[Style["Idle",Red],{(transmissionTimeData+idleTimeStart)/2,1.15}]},{}]},PlotLabel->Style[StringForm["``\nEfficiency: ``%", title, NumberForm[eff 100, {3, 1}]],14,Bold],ImageSize->Large];classicEfficiencyFunc[len_]:=(packetSize 8)/((linkBandwidth 10^9) ((packetSize 8)/(linkBandwidth 10^9)+(2 len)/speedOfSignalInCopper+(ackSize 8)/(linkBandwidth 10^9)));daedalusEfficiencyFunc[len_]:=(packetSize 8)/((linkBandwidth 10^9) ((packetSize 8)/(linkBandwidth 10^9)+Max[0,(2 len)/speedOfSignalInCopper-(packetSize 8)/(linkBandwidth 10^9)]));Grid[{{Style["Daedaelus Protocol Simulation: The Efficiency Showdown",20,Bold,"Panel"],\[SpanFromLeft]},{Panel[Grid[{{Style["Link Length:",Bold],ToString[linkLength]<>" m"},{Style["Link Bandwidth:",Bold],ToString[linkBandwidth]<>" Gbps"},{Style["Packet Size:",Bold],ToString[packetSize]<>" B"},{Style["",Bold],""},{Style["Propagation Delay (one-way):",Bold],ToString[NumberForm[propagationDelay 1000000000,{4,2}]]<>" ns"},{Style["Data Transmission Time:",Bold],ToString[NumberForm[transmissionTimeData 1000000000,{4,2}]]<>" ns"},{Style["Round Trip Time (signal):",Bold],ToString[NumberForm[roundTripTime 1000000000,{4,2}]]<>" ns"}},Alignment->Left],Background->LightGray],\[SpanFromLeft]},{timelineGraphics[classicEfficiency,classicCycleTime,transmissionTimeData+propagationDelay,transmissionTimeData+propagationDelay+transmissionTimeAck,"Classic Stop-and-Wait (SAW)"],timelineGraphics[daedalusEfficiency,daedalusCycleTime,transmissionTimeData,transmissionTimeData+transmissionTimeAck,"D\[AE]d\[AE]lus 'Circulating Snake'"]},{Plot[{classicEfficiencyFunc[len],daedalusEfficiencyFunc[len]},{len,0.1,100},PlotLegends->{"Classic SAW","D\[AE]d\[AE]lus Snake"},PlotLabel->Style["Efficiency vs. Link Length",14,Bold],AxesLabel->{"Link Length (m)","Efficiency"},GridLines->Automatic,PlotStyle->{Directive[Thick,RGBColor[0.8,0.2,0.2]],Directive[Thick,RGBColor[0.2,0.8,0.2]]},ImageSize->Full,PlotRange->{{0,100},{0,1.05}}],\[SpanFromLeft]}},FrameStyle->Directive[Gray,Thick],Spacings->{1,2}],{{linkLength,3,"Link Length (m)"},0.1,100,0.1,Appearance->"Labeled",ImageSize->Medium},{{linkBandwidth,100,"Link Bandwidth (Gbps)"},1,400,1,Appearance->"Labeled",ImageSize->Medium},{{packetSize,1500,"Packet Size (bytes)"},64,4096,8,Appearance->"Labeled",ImageSize->Medium},{{ackSize,64,"ACK Packet Size (bytes)"},8,64,8,Appearance->"Labeled",ImageSize->Medium},ControlPlacement->Left,FrameMargins->10]


params=Association["linkSpeed"->100 10^9,"propagationSpeed"->2 10^8,"cableLength"->1.0,"shannonSlotSize"->64,"sliceSize"->8,"overheadBytes"->20,"ackSize"->8];
shannonSlot=AssociationThread[("Slice"<>ToString[#1]&)/@Range[8],Partition[Range[64],8]];
Print["A Shannon Slot is a 64-byte record, composed of 8 slices:"];
Print[Dataset[shannonSlot]];
CreateContextSlice[protocol_String,liveness_String,state_String,transition_String]:=Association["SLICE"->Association["Comment"->"Encodes acknowledgment depth, closing the loop.","Value"->"11"],"BEATS"->Association["Comment"->"Defines a beat-structured flow for multiple frames.","Value"->"00"],"PROTOCOL"->Association["Comment"->"High-level intent; the packet's 'mission.'","Value"->protocol],"JAM"->Association["Comment"->"Modernized collision handling for transactional rollback.","Value"->"0"],"LIVENESS"->Association["Comment"->"Maintains 'Temporal Intimacy' using balanced ternary arithmetic.","Value"->liveness],"STATE_MACHINE"->Association["Comment"->"Specifies the active state machine for this transaction.","Value"->state],"TRANSITION"->Association["Comment"->"Defines state and direction (forward/reverse) in the machine.","Value"->transition]];
context=CreateContextSlice["001","0110","00000000","0101"];
Print["\nExample CONTEXT Slice for a Liveness Check:"];
Print[Dataset[context]];
Manipulate[Module[{ttx=(packetSize 8)/speed,rtt=(2 len)/params["propagationSpeed"],packetLengthOnWire=((packetSize 8) params["propagationSpeed"])/speed,ackTime=(params["ackSize"] 8)/speed,ackTravelTime=len/params["propagationSpeed"],utilization=ttx/(ttx+rtt)},Graphics[{Thick,Gray,Line[{{0,0},{len,0}}],Text["Sender",{-0.1 len,0.1},{1,0}],Text["Receiver",{1.1 len,0.1},{-1,0}],If[time<=ttx,{Green,Line[{{Max[0,time params["propagationSpeed"]-packetLengthOnWire],0.05},{time params["propagationSpeed"],0.05}}]},{}],If[time>ackTravelTime,{Blue,Arrowheads[Medium],Arrow[{{len-(time-ackTravelTime) params["propagationSpeed"],-0.05},{len-(time-ackTravelTime-ackTime) params["propagationSpeed"],-0.05}}]},{}],If[ttx>rtt,{Dashed,Red,Line[{{0,0.1},{0,-0.1}}],Text[Style["ACK Arrives Before Send Finishes!",Red],{0.5 len,0.2}]},{}]},PlotRange->{{-0.2 len,1.2 len},{-0.3,0.3}},ImageSize->Large,AspectRatio->1/5,GridLines->{Table[i,{i,0,Ceiling[len],0.5}],None},Frame->True,FrameLabel->{{"",""},{Row[{"Cable Length: ",NumberForm[len,{3,1}],"m"}],Style[Column[{"--- Metrics ---","Packet Transmission Time (Ttx): "<>ToString[NumberForm[ttx 10^9,{4,2}]]<>" ns","Round Trip Time (RTT): "<>ToString[NumberForm[rtt 10^9,{4,2}]]<>" ns","Packet Length on Wire: "<>ToString[NumberForm[packetLengthOnWire,{3,2}]]<>" m","Utilization (Ttx / (Ttx+RTT)): "<>ToString[NumberForm[utilization 100,{3,1}]]<>"%"},Alignment->Left],12]}},BaseStyle->{FontFamily->"Helvetica",12}]],{{speed,100 10^9,"Link Speed (bps)"},{10 10^9,25 10^9,100 10^9,400 10^9},ControlType->SetterBar},{{len,1.0,"Cable Length (m)"},0.1,10,0.1,Appearance->"Labeled"},{{packetSize,64,"Packet Size (bytes)"},{64,128,512,1500},ControlType->SetterBar},{{time,0,"Simulation Time"},0,(64 8)/(10 10^9)+(2 10)/(2 10^8),ControlType->Animator,AnimationRate->(64 8)/((100 10^9) 10)}]
ReflectLiveness[aliceSlice_]:=Module[{bobSlice=aliceSlice},bobSlice["LIVENESS","Value"]=StringReverse[aliceSlice["LIVENESS","Value"]];bobSlice["PROTOCOL","Value"]="001";bobSlice];
SimulatePipeline[initialSlice_]:=Module[{pipelineStates},pipelineStates=NestList[Function[{state},Module[{newState=state},newState["Stage"]=state["Stage"]+1;If[state["Stage"]==1,newState["Slice"]=ReflectLiveness[state["Slice"]];newState["Description"]="R2: INTERMEDIATE STATE. Slice transformed via Rewrite Rule 1. The receiver reflects the sender's state, creating an acknowledgment. This is the core of Perfect Information Feedback."];If[state["Stage"]==2,newState["Description"]="R3: EPI OUT. 'Last thing I sent.' Ready for transmission."];If[state["Stage"]==3,newState["Description"]="R4: DIGITAL TWIN INTERFACE. Optional debug/logging stage."];If[state["Stage"]==4,newState["Description"]="R5: DEPARTURE. Slice is serialized and placed on the wire."];newState]],Association["Stage"->0,"Name"->"R0: Arrival","Description"->"STATE: Bits off the wire. Deserialized symbols accumulated into Register 0.","Slice"->initialSlice],5];Grid[Prepend[({#1["Name"],#1["Description"],Dataset[#1["Slice"]]}&)/@pipelineStates,{"Stage","Description","Slice State"}],Dividers->All,Alignment->{Left,Top},ItemStyle->"Text"]];
Print["\nSimulating the FPGA pipeline for the Liveness CONTEXT slice:"];
SimulatePipeline[context]


MobiusFunction::usage="MobiusFunction[n_Integer] computes \\(\\mu(n)\\): 0 if n divisible by a square, otherwise \\((-1)^k\\) where k is the number of prime factors.";
TotientSieve::usage="TotientSieve[max_Integer] returns a list \[CurlyPhi] of length max+1, with \[CurlyPhi][[n]] = EulerPhi(n) for 1 \[LessEqual] n \[LessEqual] max using a linear sieve.";
GcdSummatory::usage="GcdSummatory[max_Integer] returns a list g of length max+1, with g[[n]] = \[Sum]_{k=1}^n GCD(k,n), computable via the identity \\(\[Sum]_{d|n} d\[CenterDot]\[CurlyPhi](n/d)\\).";
DivisorPhiSum::usage="DivisorPhiSum[n_Integer] computes \[Sum]_{d|n} d \[CenterDot] \[CurlyPhi](d), the M\[ODoubleDot]bius-inversion kernel for many collision\[Hyphen]sum formulas.";
SegmentedSieve::usage="SegmentedSieve[l_Integer, r_Integer] returns all primes in [l,r] using the segmented sieve of Eratosthenes.";
Begin["`Private`"];
MobiusFunction[n_Integer?Positive]:=Module[{fac},fac=FactorInteger[n];If[MemberQ[fac[[All,2]],_?(#1>1&)],0,(-1)^Length[fac]]];
TotientSieve[max_Integer?Positive]:=Module[{\[CurlyPhi]},\[CurlyPhi]=Range[0,max];\[CurlyPhi][[1]]=1;Do[If[\[CurlyPhi][[p]]===p,\[CurlyPhi][[p]]=p-1;Do[\[CurlyPhi][[k]]=(\[CurlyPhi][[k]] (p-1))/p,{k,2 p,max,p}];],{p,2,max}];\[CurlyPhi]];
GcdSummatory[max_Integer?Positive]:=Module[{\[CurlyPhi],g},\[CurlyPhi]=TotientSieve[max];g=ConstantArray[0,max+1];Do[Do[g[[j]]+=i \[CurlyPhi][[j/i]],{j,i,max,i}],{i,1,max}];g];
DivisorPhiSum[n_Integer?Positive]:=Total[(#1 EulerPhi[#1]&)/@Divisors[n]];
SegmentedSieve[l_Integer?Positive,r_Integer?Positive]:=Module[{limit,basePrimes,sieve,start},limit=Floor[Sqrt[r]];basePrimes=Prime/@Range[PrimePi[limit]];sieve=ConstantArray[True,r-l+1];Do[start=Max[p^2,Ceiling[l/p] p];Do[sieve[[i-l+1]]=False,{i,start,r,p}],{p,basePrimes}];Select[Range[l,r],If[#1>1,sieve[[#1-l+1]],False]&]];
End[];
Table[MobiusFunction[i],{i,1,10}]
\[CurlyPhi]=TotientSieve[20];
\[CurlyPhi][[2;;20]]
g=GcdSummatory[20];
g[[1;;20]]
DivisorPhiSum[100]
SegmentedSieve[10^6+1,10^6+100]


getMobius[a_Integer?Positive]:=Module[{fac=FactorInteger[a]},If[Min[Last/@fac]>1,0,If[OddQ[Length[fac]],-1,1]]];
totientSieve[maxn_Integer?Positive]:=Module[{phi},phi=Range[0,maxn];Do[If[phi[[p+1]]===p,phi[[p+1]]=p-1;Do[phi[[i+1]]=(phi[[i+1]] (p-1))/p,{i,2 p,maxn,p}]],{p,2,maxn}];phi];
gcdSum[n_Integer?Positive]:=Total[(#1 EulerPhi[n/#1]&)/@Divisors[n]];
harmonicSum[n_Integer?Positive]:=Module[{l=1,r,ans=0},While[l<=n,r=Floor[n/Floor[n/l]];ans+=(r-l+1) Floor[n/l];l=r+1;];ans];
segmentedSieve[L_Integer,R_Integer]/;1<=L<=R:=Module[{limit,basePrimes,isPrime,segment,start},limit=Floor[Sqrt[R]];isPrime=ConstantArray[True,limit];Do[If[isPrime[[i]],Do[isPrime[[j]]=False,{j,i^2,limit,i}]],{i,2,limit}];basePrimes=Pick[Range[limit],isPrime];segment=ConstantArray[True,R-L+1];Do[start=Max[p^2,Ceiling[L/p] p];Do[segment[[j-L+1]]=False,{j,start,R,p}],{p,basePrimes}];Select[Range[L,R],#1>1&&segment[[#1-L+1]]&]];
coprimePairCount[n_Integer?Positive]:=Total[(getMobius[#1] Binomial[Floor[n/#1],2]&)/@Range[n]];
mobiusList=Table[getMobius[i],{i,20}];
phi100=totientSieve[100];
gcdSum360=gcdSum[360]
h1e6=harmonicSum[10^6]
primesSegment=segmentedSieve[10^6,10^6+500]
coprime100=coprimePairCount[100]


ClearAll[M\[ODoubleDot]biusSieve];
M\[ODoubleDot]biusSieve[N_Integer]:=Module[{mu=ConstantArray[0,N],isPrime=ConstantArray[True,N],primes={},i,j},mu[[1]]=1;For[i=2,i<=N,i++,If[isPrime[[i]],AppendTo[primes,i];mu[[i]]=-1;];Do[j=primes[[k]] i;If[j>N,Break[]];isPrime[[j]]=False;If[Mod[i,primes[[k]]]==0,mu[[j]]=0;Break[],mu[[j]]=-mu[[i]]],{k,Length[primes]}];];mu]
M\[ODoubleDot]biusSieve[20]


ClearAll[TotientSieve];
TotientSieve[N_Integer]:=Module[{phi=Range[N],p,i},For[p=2,p<=N,p++,If[phi[[p]]==p,phi[[p]]=p-1;For[i=2 p,i<=N,i+=p,phi[[i]]=(phi[[i]] (p-1))/p];];];phi]
ClearAll[GcdSumArray];
GcdSumArray[N_Integer]:=Module[{phi=TotientSieve[N],gcdSum=ConstantArray[0,N],i,j},For[i=1,i<=N,i++,For[j=i,j<=N,j+=i,gcdSum[[j]]+=i phi[[j/i]]];];gcdSum]
GcdSumArray[10]


ClearAll[BitwisePrimeSieve];
BitwisePrimeSieve[N_Integer?EvenQ]:=Module[{size=N/2,status,sqrtN=Floor[Sqrt[N]],i,j,isPrime},status=ConstantArray[0,size];For[i=3,i<=sqrtN,i+=2,If[BitGet[status[[Quotient[i,2]+1]],1]==0,For[j=i i,j<=N,j+=2 i,status[[Quotient[j,2]+1]]=BitSet[status[[Quotient[j,2]+1]],1]]]];isPrime=Prepend[Select[Range[3,N,2],BitGet[status[[Quotient[#1,2]+1]],1]==0&],2];isPrime]
BitwisePrimeSieve[50]


ClearAll[CoPrimePairCount];
CoPrimePairCount[m_Integer]:=Module[{mu=M\[ODoubleDot]biusSieve[m],ds,count=0},ds=Select[Divisors[m],#1>0&];count=Total[(mu[[#1]] Floor[m/#1]^2&)/@ds];count]
CoPrimePairCount[8]


ClearAll["Global`*"];
protocolOpcodes=Association["000"->"Initialization","001"->"Liveness","010"->"State Machines","011"->"Groundplane Trees, GVM","100"->"Hypergraphs / Confinement","101"->"Quivers. Application Trees","110"->"Heritage (IP) Compatibility","111"->"Escape"];
generateTestFrames[numFrames_Integer]:=Module[{randomBytes,firstByte,protocolBits},Table[protocolBits=StringSplit[RandomChoice[Keys[protocolOpcodes]],""];firstByte=BitSet[RandomInteger[{0,255}],{2->ToExpression[protocolBits[[1]]],3->ToExpression[protocolBits[[2]]],4->ToExpression[protocolBits[[3]]]}];randomBytes=RandomInteger[{0,255},63];Prepend[randomBytes,firstByte],{numFrames}]];
getProtocolFromFrame[frame_List]:=Module[{firstByte,protocolBits},firstByte=First[frame];protocolBits=BitGet[firstByte,{2,3,4}];StringJoin[ToString/@protocolBits]];
protocolSieve[frames_List,targetProtocolName_String]:=Module[{targetOpcode},targetOpcode=Keys[protocolOpcodes][FirstPosition[Values[protocolOpcodes],targetProtocolName]];Select[frames,getProtocolFromFrame[#1]==targetOpcode&]];
incomingFrames=generateTestFrames[100];
targetProtocol="Groundplane Trees, GVM";
sievedFrames=protocolSieve[incomingFrames,targetProtocol];
Grid[{{Style["Total Incoming Frames",Bold],Length[incomingFrames]},{Style["Target Protocol to Sieve",Bold],targetProtocol},{Style["Frames Passing Sieve",Bold,Green],Length[sievedFrames]}},Frame->All,Alignment->Left]
Panel[Column[(Short[#1,10]&)/@sievedFrames[[1;;Min[5,Length[sievedFrames]]]]],Style[StringForm["First `` Frames Matching '``'", Min[5, Length[sievedFrames]], targetProtocol],Italic]]


ClearAll[TopologySieve,IsActiveNode];
TopologySieve[maxAddress_Integer]:=Module[{sqrtN=Floor[Sqrt[maxAddress]],status},status=ByteArray[ConstantArray[0,Ceiling[maxAddress/8]]];Do[If[BitGet[status,i]==0,Do[status=BitSet[status,j],{j,i i,maxAddress,2 i}]],{i,3,sqrtN,2}];Return[status];];
IsActiveNode[address_Integer,sieve_ByteArray]:=Which[address<=1,False,address==2,True,EvenQ[address],False,True,BitGet[sieve,address]==0];
maxNodes=256;
sieveResult=TopologySieve[maxNodes];
primeCommunicators=Select[Range[maxNodes],IsActiveNode[#1,sieveResult]&];
Print["Topology Sieve executed for a fabric of ",maxNodes," nodes."];
Print["Discovered ",Length[primeCommunicators]," prime communicators:"];
Print[primeCommunicators];
ClearAll[CausalStateSieve,GetCausalState];
CausalStateSieve[maxStateID_Integer]:=Module[{mu,primes,isComposite},mu=ConstantArray[0,maxStateID];primes={};isComposite=ConstantArray[False,maxStateID+1];mu[[1]]=1;Do[If[!isComposite[[i]],AppendTo[primes,i];mu[[i]]=-1;];Do[If[i p>maxStateID,Break[]];isComposite[[i p]]=True;If[Mod[i,p]==0,mu[[i p]]=0;Break[];,mu[[i p]]=-mu[[i]];],{p,primes}],{i,2,maxStateID}];Return[mu];];
GetCausalState[stateID_Integer,sieve_List]:=Switch[sieve[[stateID]],1,Style["Forward (+1)",Green],-1,Style["Reverse (-1)",Blue],0,Style["Stalled (0)",Red]];
maxPaths=20;
causalSieve=CausalStateSieve[maxPaths];
Print["Causal states for the first ",maxPaths," transaction paths:"];
Grid[Table[{i,GetCausalState[i,causalSieve]},{i,1,maxPaths}],Dividers->All,Alignment->Left]
ClearAll[CoherenceSieve];
CoherenceSieve[maxNodes_Integer]:=Module[{phi,gcdSum},phi=Range[0,maxNodes];phi[[1]]=0;Do[If[phi[[p]]==p,phi[[p]]=p-1;Do[phi[[i]]=Floor[phi[[i]]/p] (p-1),{i,2 p,maxNodes,p}]],{p,2,maxNodes}];gcdSum=ConstantArray[0,maxNodes+1];Do[Do[gcdSum[[j]]+=i phi[[j/i]],{j,i,maxNodes,i}],{i,1,maxNodes}];Return[Association["Totient"->phi,"ContentionMetric"->gcdSum]];];
maxNetSize=16;
coherenceMetrics=CoherenceSieve[maxNetSize];
Print["Network Coherence Metrics for n = 1 to ",maxNetSize,":"];
dataset=Dataset[Table[Association["Network Size (n)"->n,"Coprime Channels \[CurlyPhi](n)"->coherenceMetrics["Totient"][[n+1]],"Total Contention Metric"->coherenceMetrics["ContentionMetric"][[n+1]]],{n,1,maxNetSize}]];
Print[dataset];


ClearAll[SieveProtocolFilter,SieveVisualization];
SieveProtocolFilter[n_Integer?Positive]:=Module[{sieve},sieve=ConstantArray[True,n];sieve[[1]]=False;Do[If[sieve[[p]],Do[sieve[[i]]=False,{i,p^2,n,p}]],{p,2,Sqrt[n]}];sieve];
SieveVisualization[maxSequence_Integer,highlight_Integer]:=Module[{isValid,grid},isValid=SieveProtocolFilter[maxSequence];grid=Partition[Range[maxSequence],UpTo[10]];Grid[Map[Function[seq,Item[seq,Background->Which[seq==highlight,Gray,isValid[[seq]],RGBColor[0.8,1,0.8],True,RGBColor[1,0.8,0.8]],Frame->True,ItemSize->{3,1.5}]],grid,{2}],Spacings->{0.5,0.5}]];
Manipulate[Column[{Style["Slice Protocol Filter State",14],SieveVisualization[100,currentSlice],Style[If[SieveProtocolFilter[100][[currentSlice]],"Slice "<>ToString[currentSlice]<>": ACCEPTED (Valid Sequence)","Slice "<>ToString[currentSlice]<>": DISCARDED (Invalid Sequence)"],12,Bold,If[SieveProtocolFilter[100][[currentSlice]],Darker[Green],Red]]},Alignment->Center],{{currentSlice,1,"Incoming Slice Sequence #"},1,100,1,Appearance->"Labeled"}]
ClearAll[MobiusStateTracker,MobiusStateVisualization];
MobiusStateTracker[maxState_]:=Array[MoebiusMu,maxState];
AdvanceState[currentState_,newEventPrime_]:=currentState newEventPrime;
MobiusStateVisualization[currentState_]:=Module[{mu,factors,color,label},mu=MoebiusMu[currentState];factors=FactorInteger[currentState];color=Which[mu==0,Red,mu==1,Blue,mu==-1,Darker[Green]];label=Which[mu==0,"INVALID STATE\n(Duplicate Event Detected)\nDISCARD",mu==1,"State A (Parity Even)",mu==-1,"State B (Parity Odd)"];Framed[Column[{Style["Link Transaction State",14],Style[ToString[currentState]<>" = "<>ToString[Times@@(First[#1]^Last[#1]&)/@factors,TraditionalForm],16],Style["\[Mu]("<>ToString[currentState]<>") = "<>ToString[mu],20,Bold,color],Style[label,12,color]},Alignment->Center],FrameStyle->{Thickness[2],color},RoundingRadius->5]];
eventPrimes=Prime[Range[10]];
DynamicModule[{currentState=1},Column[{(Button["Event "<>ToString[p],currentState=AdvanceState[currentState,p]]&)/@eventPrimes,Button["Reset State",currentState=1,ImageSize->Medium],Dynamic[MobiusStateVisualization[currentState]]},Alignment->Center]]


ClearAll[BitwiseSieve,GetPrimeChannels];
BitwiseSieve[n_Integer?Positive]:=Module[{sqrtN,status,size=Ceiling[n/2]},status=ConstantArray[0,size];status[[1]]=BitSet[status[[1]],1];sqrtN=Floor[Sqrt[n]];Do[If[BitGet[status[[(i-1)/2+1]],1]==0,Do[status[[(j-1)/2+1]]=BitSet[status[[(j-1)/2+1]],1],{j,i i,n,2 i}]],{i,3,sqrtN,2}];status];
GetPrimeChannels[n_Integer?Positive]:=Module[{sieveResult,oddPrimes},If[n<2,Return[{}]];sieveResult=BitwiseSieve[n];oddPrimes=Pick[Range[3,n,2],BitGet[sieveResult[[Range[2,Ceiling[n/2]]]],1],0];Prepend[oddPrimes,2]];
maxNodes=200;
primeChannels=GetPrimeChannels[maxNodes];
Print[StringTemplate["For a cluster of `` potential channels, the `` fundamental (prime) channels are:"][maxNodes,Length[primeChannels]]];
Print[primeChannels];
ClearAll[TotalDivisorIntegrity];
TotalDivisorIntegrity[n_Integer?Positive]:=Module[{divs},divs=Divisors[n];Total[divs EulerPhi[divs]]];
ListPlot[Table[TotalDivisorIntegrity[n],{n,1,200}],PlotLabel->"Total Divisor Integrity vs. Network Size",AxesLabel->{"Network Size (n)","Integrity Metric"},PlotTheme->"Detailed",ImageSize->Large]



