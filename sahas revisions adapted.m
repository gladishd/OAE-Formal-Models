(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



nb=EvaluationNotebook[];
SetOptions[nb,Background->RGBColor[0.1,0.1,0.1]];
ResourceFunction["DarkMode"][];


nb = EvaluationNotebook[];
SetOptions[nb, StyleDefinitions -> "Default.nb", 
  DefaultNewCellStyle -> "Input", Background -> Automatic];
OptionRemove[nb, Background];


ClearAll["Global`*"];
CreateHistory[seed_,max_:150]:=Module[{frames={seed},hashes={Hash[seed]},game=CellularAutomaton["GameOfLife"],nxt,nxtHash},While[Length[frames]<max,nxt=game[Last[frames]];nxtHash=Hash[nxt];If[MemberQ[hashes,nxtHash],Break[]];AppendTo[frames,nxt];AppendTo[hashes,nxtHash]];frames]
OverlayFracs[base_,mask_,f_]:=MapThread[If[#2==1,f,#1]&,{base,mask},2]
MakeGrays[hist_]:=Module[{acc=ConstantArray[0.,{16,16}],n=Length[hist]},Do[acc=OverlayFracs[acc,hist[[i]],i/n],{i,n}];acc]
NextInt[bits_,n_]:={FromDigits[Take[bits,n],2],Drop[bits,n]};
NextReal[bits_,n_]:=Module[{v,r},{v,r}=NextInt[bits,n];{N[v/(2^n-1)],r}];
NextFrac[bits_]:=NextReal[bits,16];
NextBool[bits_]:={First[bits]===1,Rest[bits]};
spectrumColors=RGBColor@@@N[1/255 {{0,168,222},{51,51,145},{233,19,136},{235,45,46},{253,233,43},{0,158,84},{0,168,222}}];
SpectrumColor[f_]:=Blend[spectrumColors,f]
Luminance[c_RGBColor]:=0.2126 c[[1]]+0.7152 c[[2]]+0.0722 c[[3]]
MonochromeGradient[hue_,tint_,rev_,kA_,nA_]:=Module[{key,neut,order},key=ColorConvert[Hue[hue,1,1],"RGB"];neut=ColorConvert[Hue[0,0,If[tint,1,0]],"RGB"];If[tint,key=Darker[key,.5]];order=If[rev,Reverse,Identity];With[{k=kA 0.3+.05,n=nA 0.3+.05},Blend[order[{Blend[{key,neut},k],Blend[{neut,key},n]}],#1]&]]
ComplementaryGradient[s_,lA_,dA_,rev_]:=Module[{cs,order},cs=SortBy[SpectrumColor/@{s,Mod[s+.5,1]},Luminance];order=If[rev,Reverse,Identity];With[{l=lA 0.3,d=dA 0.3},Blend[order[{Blend[{cs[[1]],Black},d],Blend[{cs[[2]],White},l]}],#1]&]]
TriadicGradient[s_,lA_,dA_,rev_]:=Module[{cs=SpectrumColor/@Mod[s+{0,1/3,2/3},1],order},cs=SortBy[cs,Luminance];order=If[rev,Reverse,Identity];With[{l=lA 0.3,d=dA 0.3},Blend[order[{Blend[{cs[[1]],Black},d],cs[[2]],Blend[{cs[[3]],White},l]}],#1]&]]
AnalogousGradient[s_,adv_,rev_]:=Module[{cs=SpectrumColor/@Mod[s+1/12 Range[0,3],1],order},If[Luminance[First[cs]]>Luminance[Last[cs]],cs=Reverse[cs]];order=If[rev,Reverse,Identity];With[{a=adv .5+.2},Blend[order[{Blend[{cs[[1]],Black},a],Blend[{cs[[2]],Black},a/2],Blend[{cs[[3]],White},a/2],Blend[{cs[[4]],White},a]}],#1]&]]
SelectMonochrome[bits_]:=Module[{e=bits,h,t,r,kA,nA},{h,e}=NextFrac[e];{t,e}=NextBool[e];{r,e}=NextBool[e];{kA,e}=NextFrac[e];{nA,e}=NextFrac[e];{MonochromeGradient[h,t,r,kA,nA],e}]
SelectComplementary[bits_]:=Module[{e=bits,s,lA,dA,r},{s,e}=NextFrac[e];{lA,e}=NextFrac[e];{dA,e}=NextFrac[e];{r,e}=NextBool[e];{ComplementaryGradient[s,lA,dA,r],e}]
SelectTriadic[bits_]:=Module[{e=bits,s,lA,dA,r},{s,e}=NextFrac[e];{lA,e}=NextFrac[e];{dA,e}=NextFrac[e];{r,e}=NextBool[e];{TriadicGradient[s,lA,dA,r],e}]
SelectAnalogous[bits_]:=Module[{e=bits,s,adv,r},{s,e}=NextFrac[e];{adv,e}=NextFrac[e];{r,e}=NextBool[e];{AnalogousGradient[s,adv,r],e}]
SelectGradient[bits_]:=Module[{tag,rest,grad},{tag,rest}=NextInt[bits,2];{grad,rest}=Switch[tag,0,SelectMonochrome[rest],1,SelectComplementary[rest],2,SelectTriadic[rest],3,SelectAnalogous[rest]];{grad,rest}]
Transform[t_,rx_,ry_]:=Function[{x,y},With[{u=If[t,y,x],v=If[t,x,y]},{If[rx,33-u,u],If[ry,33-v,v]}]]
snowflake=Transform@@@{{False,False,False},{False,True,False},{False,False,True},{False,True,True}};
pinwheel=Transform@@@{{False,False,False},{True,True,False},{True,False,True},{False,True,True}};
SelectSymmetry[bits_]:=Module[{b,rest},{b,rest}=NextBool[bits];{If[b,"snowflake","pinwheel"],rest}]
ApplySymmetry[img_,pat_]:=Module[{tors=If[pat==="snowflake",snowflake,pinwheel]},ReplacePart[ConstantArray[0.,{32,32}],Flatten[Table[(#1@@{x,y}->img[[y,x]]&)/@tors,{y,16},{x,16}]]]]
Fingerprint[val_]:=Module[{bits=IntegerDigits[Hash[val,"SHA256"],2,256],seed,hist,gray,grad,restBits,pat},seed=Partition[bits,16];hist=CreateHistory[seed];gray=MakeGrays[hist];{grad,restBits}=SelectGradient[bits];{pat,restBits}=SelectSymmetry[restBits];{ApplySymmetry[gray,pat],grad}]
Options[LifeHash]={ImageSize->512};
LifeHash[value_,opts:OptionsPattern[]]:=Module[{img,cf},{img,cf}=Fingerprint[value];ArrayPlot[img,ColorFunction->cf,Frame->False,PixelConstrained->1,ImageSize->OptionValue[ImageSize]]]
LifeHash["Wolf"]
LifeHash["Daedalus"]
LifeHash[Range[20]]


(* ::Input::Initialization:: *)
BeginPackage["Conway`"];
Unprotect["Conway`*"];
ClearAll["Conway`*"];
ClearAll["Conway`*`*"];
{BasicImageResolution,BoxedLabel,ContourByArcLength,CurveLegend,DecimalPlacesForm,DefaultColours,DeleteNearbyPoints,DomainEnd,DomainStart,Embolden,EmptyAxes,EmptyFrame,EvaluatePair,Ex,ExportIfNotExists,FString,ImageSizeCentimetre,IncludeYReflection,Italicise,LatinModernFont,LatinModernLabelStyle,LatinModernFontStyle,LaTeXStyle,Margined,ModuleSymbol,NodeLegend,NoExtrapolation,OffsetCharacterCode,OnePointPerspective,ParametricTangent,PlotOptions,PreciseOptions,PrettyString,RegionLegend,ReInterpolate,SeekFirstRootBisection,SeekParametricIntersection,SeekRoot,SeekRootBisection,SeparatedRow,SignificantFiguresForm,SortByPhi,ToName,UniformRange,Way};
Begin["`Private`"];
BasicImageResolution::usage = ("BasicImageResolution\n" <> "Returns frugal ImageResolution of 72.");
BasicImageResolution = 72;
BoxedLabel::usage = ("BoxedLabel[expr, opts]\n" <> "Returns framed version of the expression expr.\n" <> "To be used for PlotLabel.");
BoxedLabel[expr_, opts : OptionsPattern[Framed]] := Framed[expr, ImageMargins -> {{0, 0}, {10, 0}}, opts];
ContourByArcLength::usage = ("ContourByArcLength[fun][{x0, y0}, s0, {sStart, sEnd}\n" <> "  , sSign (def 1)\n" <> "  , terminationFunction (def False &)\n" <> "]\n" <> "Returns contour x == x(s), y == y(s) " <> "(arc-length parametrisation) for:\n" <> "- Function fun == fun(x, y)\n" <> "- Initial condition x(s0) == x0, y(s0) == y0\n" <> "- Arc-length interval sStart < s < sEnd.\n" <> "To traverse the contour backwards, use sSign == -1.\n");
ContourByArcLength[fun_][{x0_, y0_}, s0_, {sStart_, sEnd_}, sSign_: 1, terminationFunction_: (False &)] := Module[{p, q, grad, xDerivative, yDerivative, dummyForTrailingCommas}, p = Derivative[1, 0][fun]; q = Derivative[0, 1][fun]; grad = Function[{x, y}, Sqrt[p[x, y]^2 + q[x, y]^2] // Evaluate]; xDerivative[x_, y_] := +q[x, y]/grad[x, y]; yDerivative[x_, y_] := -p[x, y]/grad[x, y]; With[{x = \[FormalX], y = \[FormalY], s = \[FormalS]}, NDSolveValue[{x'[s] == sSign xDerivative[x[s], y[s]], y'[s] == sSign yDerivative[x[s], y[s]], x[s0] == x0, y[s0] == y0, WhenEvent[terminationFunction[x[s], y[s]], "StopIntegration"]}, {x, y}, {s, sStart, sEnd}, NoExtrapolation]]];
CurveLegend::usage = ("CurveLegend[styleList, labelList, opts]\n" <> "Returns list of individual LineLegends for each {style, label} pair. " <> "To be used in Grid.");
CurveLegend[styleList_List, labelList_List, opts : OptionsPattern[LineLegend]] := Module[{nMax, style, label}, nMax = Length /@ {styleList, labelList} // Min; Table[style = styleList[[n]]; label = labelList[[n]]; LineLegend[{style}, {label}, opts, LegendMarkerSize -> {25, 16}], {n, nMax}]];
DecimalPlacesForm::usage = ("DecimalPlacesForm[n][x]\n" <> "Return x formatted to n decimal places.");
DecimalPlacesForm[n_Integer][x_] := DecimalForm[N[x], {Infinity, n}];
DefaultColours::usage = ("DefaultColours\n" <> "Returns the default colours for Plot since Version 10.");
DefaultColours = ColorData[97, "ColorList"];
DeleteNearbyPoints::usage = ("DeleteNearbyPoints[sep][list]\n" <> "Removes duplicates from the list of points list, " <> "where points with separation less than sep are considered duplicate.");
DeleteNearbyPoints[sep_?NumericQ][list_List] := DeleteDuplicates[list, Norm[#2 - #1] < sep &];
DomainEnd::usage = ("DomainEnd[iFun] or DomainEnd[{iFun, ...}]\n" <> "Returns the end of the domain for the first coordinate " <> "of the interpolating function iFun.");
DomainEnd[iFun_InterpolatingFunction] := iFun["Domain"][[1, 2]];
DomainEnd[{iFun_, ___}] := DomainEnd[iFun];
DomainStart::usage = ("DomainStart[iFun] or DomainStart[{iFun, ...}]\n" <> "Returns the start of the domain for the first coordinate " <> "of the interpolating function iFun.");
DomainStart[iFun_InterpolatingFunction] := iFun["Domain"][[1, 1]];
DomainStart[{iFun_, ___}] := DomainStart[iFun];
Embolden::usage = ("Embolden[str]\n" <> "Returns emboldened version of str." <> "Automatically threads over lists.");
Embolden[str_] := Style[str, Bold];
SetAttributes[Embolden, Listable];
EmptyAxes::usage = ("EmptyAxes[{xMin, xMax}, {yMin, yMax}, opts]\n" <> "Returns empty Plot with default options PlotOptions[Axes], " <> "which may be overridden by options opts.");
EmptyAxes[{xMin_?NumericQ, xMax_?NumericQ}, {yMin_?NumericQ, yMax_?NumericQ}, opts : OptionsPattern[Plot]] := Plot[Indeterminate, {x, xMin, xMax}, opts, PlotRange -> {{xMin, xMax}, {yMin, yMax}}, PlotOptions[Axes] // Evaluate];
EmptyFrame::usage = ("EmptyFrame[{xMin, xMax}, {yMin, yMax}, opts]\n" <> "Returns empty RegionPlot with default options PlotOptions[Frame], " <> "which may be overridden by options opts.");
EmptyFrame[{xMin_?NumericQ, xMax_?NumericQ}, {yMin_?NumericQ, yMax_?NumericQ}, opts : OptionsPattern[RegionPlot]] := RegionPlot[False, {x, xMin, xMax}, {y, yMin, yMax}, opts, PlotOptions[Frame] // Evaluate];
EvaluatePair::usage = ("EvaluatePair[{xFun, yFun}, s, ySign (def 1)]\n" <> "Returns {xFun[s], yFun[s] * ySign}.");
EvaluatePair[{xFun_, yFun_}, s_, ySign_: 1] := {xFun[s], yFun[s]*ySign};
Ex::usage = ("Ex[dest, opts]\n" <> "Operator form of Export. Now modified to display graphic in notebook instead.");
Ex[dest_, opts : OptionsPattern[Export]] := Identity[#] &;
ExportIfNotExists::usage = ("ExportIfNotExists[dest, expr, opts]\n" <> "This function is now obsolete. The notebook uses memoization instead of file-based caching.");
ExportIfNotExists[dest_, expr_, opts : OptionsPattern[Export]] := If[Not@FileExistsQ[dest], expr // Ex[dest, opts]];
SetAttributes[ExportIfNotExists, HoldAll];
FString::usage = ("FString[s]\n" <> "Formats string s as per Python 3.6's f-strings: " <> "contents of curly brackets are evaluated using ToExpression " <> "(use doubled curly brackets for literal brackets).\n" <> "Referencing With variables will NOT work.\n" <> "Avoid referencing free variables: this will be SLOW.\n" <> "Automatically threads over lists.\n" <> "See PEP 498 -- Literal String Interpolation: " <> "https://www.python.org/dev/peps/pep-0498/");
FString[s_String] := s // StringReplace@{"{{" -> "{", "}}" -> "}", StringExpression["{", contents:Shortest[___], "}"] :> ToString[ToExpression[contents] // ReplaceAll[x_Symbol :> ModuleSymbol[SymbolName[x], $ModuleNumber]] // ReplaceRepeated[#, x_Symbol :> ModuleSymbol[SymbolName[x] // StringReplace["$" ~~ __ -> ""], SymbolName[x] // StringReplace[__ ~~ "$" -> ""] // ToExpression // Max[1, # - 1] &], MaxIterations -> Infinity] & // ReplaceAll[x_Symbol :> Symbol[SymbolName[x] // StringReplace["$" ~~ __ -> ""]]]]};
SetAttributes[FString, Listable];
ImageSizeCentimetre::usage = ("ImageSizeCentimetre\n" <> "Returns number of printer's points in 1 centimetre.\n" <> "To be used for raster exports.");
ImageSizeCentimetre = Module[{inchDividedByPoint, inchDividedByCentimetre}, inchDividedByPoint = 72; inchDividedByCentimetre = 254/100; inchDividedByPoint/inchDividedByCentimetre];
IncludeYReflection::usage = ("IncludeYReflection[{x, y}]\n" <> "Returns {{x, y}, {x, -y}}.");
IncludeYReflection[{x_, y_}] := {{x, y}, {x, -y}};
Italicise::usage = ("Italicise[str]\n" <> "Returns italicised version of str.\n" <> "To be used for AxesLabel etc.\n" <> "Automatically threads over lists.");
Italicise[str_] := Style[str, Italic];
SetAttributes[Italicise, Listable];
LatinModernFont::usage = ("LatinModernFont[type (def \"Roman\")]\n" <> "Latin Modern Font of type type.\n" <> "Requires installation of the following fonts:\n" <> "* \"Latin Modern Math\" latinmodern-math.otf\n" <> "  <http://www.gust.org.pl/projects/e-foundry/lm-math/download>" <> "\n" <> "* \"LM Roman 10\" lmroman10-regular.otf\n" <> "  <http://www.gust.org.pl/projects/e-foundry/latin-modern/download>");
LatinModernFont[type : _String : "Roman"] := Association["Math" -> "Latin Modern Math", "Roman" -> "LM Roman 10"][type];
LatinModernLabelStyle::usage = ("LatinModernLabelStyle[size, col (def Black)]\n" <> "Latin Modern Font label style to be used in Plots etc.");
LatinModernLabelStyle[size_Integer, col_: Black] := {col, FontFamily -> LatinModernFont[], FontSize -> size};
LatinModernFontStyle::usage = ("LatinModernFontStyle[type][expr]\n" <> "Style expression expr with Latin Modern Font of type type.");
LatinModernFontStyle[type_][expr_] := Style[expr, FontFamily -> LatinModernFont[type]];
LaTeXStyle::usage = ("LaTeXStyle[expr]\n" <> "Style expression expr with LaTeX fonts without using Szabolcs's MaTeX. " <> "While MaTeX is an excellent package, and outputs vector text labels, " <> "those labels cannot be selected and copied.\n" <> "Requires installation of the following fonts:\n" <> "* \"Latin Modern Math\" latinmodern-math.otf\n" <> "  <http://www.gust.org.pl/projects/e-foundry/lm-math/download>" <> "\n" <> "* \"LM Roman 10\" lmroman10-regular.otf\n" <> "  <http://www.gust.org.pl/projects/e-foundry/latin-modern/download>");
LaTeXStyle[expr_] := (LatinModernFontStyle["Roman"][expr] /. {{"d", x_} :> (SeparatedRow["NegativeVeryThin"]["d", x]), {"\[PartialD]", x_} :> (SeparatedRow[][ToString["\[PartialD]"], x])} /. {char_String?((StringMatchQ[#1, CharacterRange["\[Alpha]", "\[Omega]"]]) & ) :> (char // OffsetCharacterCode["\[Alpha]", 16^^1D6FC] // LatinModernFontStyle["Math"]), char_String?((StringMatchQ[#1, CharacterRange["\[CapitalAlpha]", "\[CapitalOmega]"]]) & ) :> (char // OffsetCharacterCode["\[CapitalAlpha]", 16^^0391] // LatinModernFontStyle["Math"]), "\[PartialD]" :> (FromCharacterCode[16^^1D715] // LatinModernFontStyle["Math"]), "\[Epsilon]" :> (FromCharacterCode[16^^1D716] // LatinModernFontStyle["Math"]), "\[CurlyTheta]" :> (FromCharacterCode[16^^1D717] // LatinModernFontStyle["Math"]), "\[CurlyKappa]" :> (FromCharacterCode[16^^1D718] // LatinModernFontStyle["Math"]), "\[Phi]" :> (FromCharacterCode[16^^1D719] // LatinModernFontStyle["Math"]), "\[CurlyRho]" :> (FromCharacterCode[16^^1D71A] // LatinModernFontStyle["Math"]), "\[CurlyPi]" :> (FromCharacterCode[16^^1D71B] // LatinModernFontStyle["Math"])});
Margined::usage = ("Margined[margins, opts]\n" <> "Operator form of Framed, equivalent to " <> "Framed[#, opts, FrameMargins -> margins, FrameStyle -> None] &");
Margined[margins_, opts : OptionsPattern[Framed]] := Framed[#1, opts, FrameMargins -> margins, FrameStyle -> None] & ;
ModuleSymbol::usage = ("ModuleSymbol[name, num]\n" <> "Builds the symbol with name name and $ModuleNumber num.");
ModuleSymbol[name_String, num_Integer] := Symbol@StringJoin[name, "$", ToString[num]];
NodeLegend::usage = ("NodeLegend[styleList, labelList, opts]\n" <> "Returns list of individual PointLegends for each {style, label} pair. " <> "To be used in Grid.");
NodeLegend[styleList_List, labelList_List, opts : OptionsPattern[PointLegend]] := Module[{nMax, style, label}, nMax = Length /@ {styleList, labelList} // Min; Table[style = styleList[[n]]; label = labelList[[n]]; PointLegend[{style}, {label}, opts], {n, nMax}]];
NoExtrapolation::usage = ("NoExtrapolation\n" <> "Undocumented option for preventing extrapolation " <> "in InterpolatingFunction etc.");
NoExtrapolation = ("ExtrapolationHandler" -> {Indeterminate &, "WarningMessage" -> False});
OffsetCharacterCode::usage = ("OffsetCharacterCode[offset][string]\n" <> "Offset code points of string by an integer offset.\n" <> "OffsetCharacterCode[initial, final][string]\n" <> "Offset code points of string from initial to final. " <> "Both initial and final may be given " <> "as integers (code points) or as strings (first characters).");
OffsetCharacterCode[offset_Integer][string_String] := FromCharacterCode[ToCharacterCode[string] + offset];
OffsetCharacterCode[initial_Integer, final_Integer] := OffsetCharacterCode[final - initial];
OffsetCharacterCode["", final_] := OffsetCharacterCode[0, final];
OffsetCharacterCode[initial_String, final_] := OffsetCharacterCode[First@ToCharacterCode[initial], final];
OffsetCharacterCode[initial_, ""] := OffsetCharacterCode[initial, 0];
OffsetCharacterCode[initial_, final_String] := OffsetCharacterCode[initial, First@ToCharacterCode[final]];
OnePointPerspective::usage = ("OnePointPerspective[d][e, n, r0, v][p]\n" <> "Returns d-dimensional coordinates for one-point perspective for:\n" <> "- Dimension d == 2 (canvas components) or d == 3 (spatial coordinates)\n" <> "- Eye at e in 3D\n" <> "- Canvas plane in 3D with normal n containing point r0\n" <> "- Vertical axis v in 3D\n" <> "- Point p in 3D\n" <> "There are far better ways than the simple implementation here, " <> "but I am not a 3D graphics expert.");
OnePointPerspective[d : 2 | 3][e_, n_, r0_, v_][p_] := Module[{rFunction, r, b, a, x, y}, rFunction[point_] := e + n . (r0 - e)/n . (point - e)*(point - e); r = rFunction[p]; b = rFunction[v] - rFunction[0]; a = Cross[b, Normalize[n]]; x = r . a/a . a; y = r . b/b . b; If[d == 2, {x, y}, r]];
ParametricTangent::usage = ("ParametricTangent[{x, y, ...}, s]\n" <> "Returns (un-normalised) tangent vector of {x, y, ...} evaluated at s." <> "To be used for rotation of Text labelling a parametric curve.");
ParametricTangent[funList_List, s_] := Table[fun'[s], {fun, funList}];
PlotOptions::usage = ("PlotOptions[type]\n" <> "Returns sensible options for a plot of type type, " <> "either Axes or Frame.");
PlotOptions[Axes] = {AxesLabel -> Italicise@{"x", "y"}, LabelStyle -> Directive[Black, 16]};
PlotOptions[Frame] = {AspectRatio -> Automatic, FrameLabel -> Italicise@{"x", "y"}, LabelStyle -> Directive[Black, 16], RotateLabel -> False};
PreciseOptions::usage = ("Precise[maxStepFrac (def 1/512)]\n" <> "Returns options for high precision in NDSolve.\n" <> "These may be overridden by options called before PreciseOptions.");
PreciseOptions[maxStepFrac : _?NumericQ : 1/512] := {MaxStepFraction -> maxStepFrac, MaxSteps -> Infinity, AccuracyGoal -> 16, PrecisionGoal -> 16, WorkingPrecision -> 2 MachinePrecision};
PrettyString::usage = ("PrettyString[s1 -> sp1, s2 -> sp2, ...][expr]\n" <> "Performs string replacements {s1 -> sp1, s2 -> sp2, ...} " <> "on all string subparts of expr.\n" <> "To be used to make pretty output with readable input.");
PrettyString[ruleSeq___Rule][expr_] := expr /. s_String :> StringReplace[s, {ruleSeq}];
RegionLegend::usage = ("RegionLegend[styleList, labelList, opts]\n" <> "Returns list of individual SwatchLegends for each {style, label} pair. " <> "To be used in Grid.");
RegionLegend[styleList_List, labelList_List, opts : OptionsPattern[SwatchLegend]] := Module[{nMax, style, label}, nMax = Length /@ {styleList, labelList} // Min; Table[style = styleList[[n]]; label = labelList[[n]]; SwatchLegend[{style}, {label}, opts, LegendMarkerSize -> 12], {n, nMax}]];
ReInterpolate::usage = ("ReInterpolate[iFun, num (def 1024)]\n" <> "Re-interpolates interpolating function iFun using num uniform subintervals " <> "if iFun has more than num subintervals.\n" <> "To be used to save space.\n" <> "Automatically threads over lists.");
ReInterpolate[iFun_InterpolatingFunction, num : _?NumericQ : 1024] := If[Length@iFun["Grid"] - 1 > num, Interpolation@Table[{x, iFun[x]}, {x, Subdivide[DomainStart[iFun], DomainEnd[iFun], num]}], iFun];
SetAttributes[ReInterpolate, Listable];
SeekFirstRootBisection::usage = ("SeekFirstRootBisection[fun, {xMin, xMax}, num (def 1000), tol (def 10^-6), " <> "opts (def N -> True, \"ReturnIterations\" -> False, " <> "\"ToleranceType\" -> \"Absolute\")]\n" <> "Seeks a numerical root of fun[x] == 0, using the bisection algorithm " <> "over the subinterval {x0, x1} corresponding to the first sign-change " <> "as determined by num subdivisions of the interval {xMin, xMax}, " <> "with tolerance tol over {x0, x1}.\n" <> "Default option N -> True specifies that initial endpoints " <> "should be numericised (for speed) before performing the iteration.\n" <> "Default option \"ReturnIterations\" -> \"False\" " <> "specifies that the number of iterations should not be returned.\n" <> "Default option \"ToleranceType\" -> \"Absolute\" " <> "specifies absolute tolerance. " <> "Use \"ToleranceType\" -> \"Relative\" " <> "for tolerance relative to the interval {x0, x1}.");
SeekFirstRootBisection[fun_, {xMin_?NumericQ, xMax_?NumericQ}, num : Except[_?OptionQ, _?NumericQ] : 1000, tol : Except[_?OptionQ, _?NumericQ] : 10^-6, opts : OptionsPattern@{N -> True, "ReturnIterations" -> False, "ToleranceType" -> "Absolute"}] := Module[{xValues, firstSignChangeIndex, x0, x1}, xValues = (Subdivide[xMin, xMax, num] // If[TrueQ@OptionValue[N], N, Identity]); firstSignChangeIndex = (First@FirstPosition[Differences@Sign[fun /@ xValues], signChange_ /; signChange != 0]); x0 = xValues[[firstSignChangeIndex]]; x1 = xValues[[firstSignChangeIndex + 1]]; SeekRootBisection[fun, {x0, x1}, tol, # -> OptionValue[#] & /@ {N, "ReturnIterations", "ToleranceType"}]];
SeekParametricIntersection::usage = ("SeekParametricIntersection[" <> "{x1, y1}, {x2, y2}, " <> "{start1, end1}, {start2, end2}, " <> "prop1 (def 1/2), prop2 (def 1/2)]\n" <> "Seeks intersection of the parametric curves " <> "(x1, y1)(t1) and (x2, y2)(t2) " <> "over the domains start1 < t1 < end1, start2 < t2 < end2 respectively " <> "with initial guess at proportions prop1 and prop2 of the way respectively. " <> "If both x1 and x2 are interpolating functions, " <> "{start1, end1} and {start2, end2} are chosen automatically if omitted.");
SeekParametricIntersection[{x1_, y1_}, {x2_, y2_}, {start1_, end1_}, {start2_, end2_}, prop1_ : 1/2, prop2_ : 1/2] := Module[{t1Init, t2Init}, t1Init = Way[start1, end1, prop1]; t2Init = Way[start2, end2, prop2]; FindRoot[{x1[#1] - x2[#2], y1[#1] - y2[#2]} &, {{t1Init}, {t2Init}}]];
SeekParametricIntersection[{x1_InterpolatingFunction, y1_}, {x2_InterpolatingFunction, y2_}, prop1_ : 1/2, prop2_ : 1/2] := SeekParametricIntersection[{x1, y1}, {x2, y2}, {DomainStart[x1], DomainEnd[x1]}, {DomainStart[x2], DomainEnd[x2]}, prop1, prop2];
SeekRoot::usage = ("SeekRoot[fun, {xMin, xMax}, num (def 1000), opts (def N -> True)]\n" <> "Seeks a numerical root of fun[x] == 0, using FindRoot, " <> "over the search interval {xMin, xMax} " <> "with num initial subdivisions to determine the best initial guess.\n" <> "Default option N -> True specifies that initial subdivision points " <> "should be numericised (for speed) before fun is applied.\n\n" <> "SeekRoot[fun, xInit]\n" <> "Uses initial guess xInit.");
SeekRoot[fun_, {xMin_?NumericQ, xMax_?NumericQ}, num : Except[_?OptionQ, _?NumericQ] : 1000, opts : OptionsPattern@{N -> True}] := Module[{xInit}, xInit = First@TakeSmallestBy[Subdivide[xMin, xMax, num] // If[TrueQ@OptionValue[N], N, Identity], Abs@*fun, 1, ExcludedForms -> Except[_?NumericQ]]; First@FindRoot[fun, {xInit}]];
SeekRoot[fun_, xInit_?NumericQ] := First@FindRoot[fun, {xInit}];
SeekRootBisection::usage = ("SeekRootBisection[fun, {xMin, xMax}, tol (def 10^-6), " <> "opts (def N -> True, \"ReturnIterations\" -> False, " <> "\"ToleranceType\" -> \"Absolute\")]\n" <> "Seeks a numerical root of fun[x] == 0, using the bisection algorithm, " <> "over the search interval {xMin, xMax} with tolerance tol.\n" <> "Default option N -> True specifies that initial endpoints " <> "should be numericised (for speed) before performing the iteration.\n" <> "Default option \"ReturnIterations\" -> \"False\" " <> "specifies that the number of iterations should not be returned.\n" <> "Default option \"ToleranceType\" -> \"Absolute\" " <> "specifies absolute tolerance. " <> "Use \"ToleranceType\" -> \"Relative\" " <> "for tolerance relative to the interval {xMin, xMax}.");
SeekRootBisection[fun_, {xMin_?NumericQ, xMax_?NumericQ}, tol : Except[_?OptionQ, _?NumericQ] : 10^-6, opts : OptionsPattern@{N -> True, "ReturnIterations" -> False, "ToleranceType" -> "Absolute"}] := Module[{absTol, num, xLeft, xRight, xMid, xSol}, absTol = tol; If[OptionValue["ToleranceType"] =!= "Absolute", absTol *= xMax - xMin]; num = 1; {xLeft, xRight} = (MinMax@{xMin, xMax} // If[TrueQ@OptionValue[N], N, Identity]); While[num < $RecursionLimit, xMid = Way[xLeft, xRight]; If[(xRight - xLeft)/2 < absTol, xSol = xMid; Break[]]; If[fun[xLeft] fun[xMid] > 0, xLeft = xMid, xRight = xMid]; num += 1]; If[TrueQ@Not@OptionValue["ReturnIterations"], xSol, {xSol, num}]];
SeparatedRow::usage = ("SeparatedRow[sep (def \"\")][x1, ...]\n" <> "Returns Row for list {x1, ...} and separator sep.\n" <> "Abbreviations for certain horizontal spacing characters " <> "are defined for sep.");
SeparatedRow[sep_: ""][xSeq___] := Row[{xSeq}, sep /. {"VeryThin" -> "\[VeryThinSpace]", "Thin" -> "\[ThinSpace]", "Medium" -> "\[MediumSpace]", "Thick" -> "\[ThickSpace]", "Invisible" -> "\[InvisibleSpace]", "NegativeVeryThin" -> "\[NegativeVeryThinSpace]", "NegativeThin" -> "\[NegativeThinSpace]", "NegativeMedium" -> "\[NegativeMediumSpace]", "NegativeThick" -> "\[NegativeThickSpace]", "NonBreaking" -> "\[NonBreakingSpace]", Automatic -> ""}];
SignificantFiguresForm::usage = ("SignificantFiguresForm[n][x]\n" <> "Return x formatted to n significant figures.");
SignificantFiguresForm[n_Integer][x_] := Module[{pMin, pMax, digitsSpec}, {pMin, pMax} = ScientificNotationThreshold /. Options[NumberForm]; digitsSpec = If[10^pMin <= Abs[x] < 10^pMax, {n, n - Floor[1 + Log10@Abs[x]]}, {n, n - 1}]; NumberForm[N[x], digitsSpec]];
SortByPhi::usage = ("SortByPhi[list]\n" <> "Sorts the list of (planar) points list by azimuthal angle.");
SortByPhi = SortBy[Mod[ArcTan @@ #, 2 Pi] &];
ToName::usage = ("ToName[number]\n" <> "Converts real number to a string for a file name, " <> "with decimal places replaced by underscores.");
ToName[number_Integer | number_Real] := StringReplace[ToString@DecimalForm[number], "." -> "_"];
ToName[number_?NumericQ] /; Im[number] == 0 := ToName[Re@number // N];
UniformRange::usage = ("UniformRange[start, end, maxStep]\n" <> "Subdivides the interval from start to end uniformly " <> "with step at most maxStep.");
UniformRange[start_?NumericQ, end_?NumericQ, maxStep_?NumericQ] := Subdivide[start, end, (end - start)/maxStep // N // Ceiling];
Way::usage = ("Way[start, end, prop (def 1/2)]\n" <> "Returns proportion prop of the way from start to end.\n" <> "The default for prop is 1/2 (halfway).");
Way[start_, end_, prop_ : 1/2] := (1 - prop) start + prop*end;
End[];
Protect["Conway`*"];
EndPackage[];
BeginPackage["FigureStyles`", {"Conway`"}];
Unprotect["FigureStyles`*"];
ClearAll["FigureStyles`*"];
ClearAll["FigureStyles`*`*"];
{GeneralStyle, BoundaryTracingStyle, ImageSizeTextWidth, ImageSizeTextWidthBeamer, LabelSize, SquigglyArrow, SlidesStyle, {}};
Begin["`Private`"];
GeneralStyle[type_String : Automatic] := Association["AmbientLighting" -> {{"Ambient"}, White}, "Dashed" -> AbsoluteDashing@{5, 4}, "DefaultThick" -> AbsoluteThickness[1.5], "Dotted" -> AbsoluteDashing@{0.3, 4}, "Point" -> PointSize[Large], "Thick" -> AbsoluteThickness[2.5], "Translucent" -> Opacity[0.7], "VeryThick" -> AbsoluteThickness[5], Automatic -> Automatic][type];
BoundaryTracingStyle[type : (_String | Automatic) : Automatic] := Association["Background" -> Directive[GeneralStyle["DefaultThick"], GrayLevel[0.7]], "Contour" -> Directive[GeneralStyle["DefaultThick"], GeneralStyle["Dotted"], Black], "ContourImportant" -> Directive[GeneralStyle["Thick"], Gray], "ContourPlain" -> Directive[GeneralStyle["DefaultThick"], GrayLevel[0.6]], "Edge3D" -> Thick, "NonViable" -> Directive[GeneralStyle["Translucent"], GrayLevel[0.8]], "Solution3D" -> White, "Terminal" -> Directive[GeneralStyle["DefaultThick"], GeneralStyle["Dashed"], Black], "Traced" -> Directive[GeneralStyle["Thick"], Black], "Unphysical" -> Black, "Viable" -> White, "Wall" -> Directive[GeneralStyle["DefaultThick"], Gray], "Wall3D" -> GrayLevel[0.6], Automatic -> Black][type];
BoundaryTracingStyle[typeSeq__String] := Directive @@ BoundaryTracingStyle /@ {typeSeq};
ImageSizeTextWidth = Module[{a4width, bindingoffset, inner, outer}, a4width = 21 Conway`ImageSizeCentimetre; bindingoffset = 2 Conway`ImageSizeCentimetre; inner = 2 Conway`ImageSizeCentimetre; outer = 2.5 Conway`ImageSizeCentimetre; a4width - (bindingoffset + inner + outer)];
ImageSizeTextWidthBeamer = 10.8 Conway`ImageSizeCentimetre;
LabelSize[type_String : Automatic] := Association["Axis" -> 12, "Label" -> 12, "LabelOmega" -> If[$OperatingSystem == "Windows", 13, 15], "Legend" -> 10, "Point" -> 11, "PointBracket" -> 15, "Straight" -> 10, "Tick" -> 9, Automatic -> Automatic][type];
SquigglyArrow[{xBase_, yBase_}, phi_: 0, size_: 1] := Module[{yList, listLength, xList, pointList}, yList = {ConstantArray[-0.1, 5], 1, 0, -1, 0, 1, 0, -1, ConstantArray[+0.1, 7], {}} // 0.15 # & // Flatten; listLength = Length[yList]; xList = Subdivide[0, 1, listLength - 1]; pointList = {xList, yList} // Transpose; Arrow@BSplineCurve[pointList // ScalingTransform@{size, size} // RotationTransform[phi, {0, 0}] // TranslationTransform@{xBase, yBase}]];
SlidesStyle[type_String : Automatic] := Association["Boundary" -> RGBColor["#9400D3"], "Interior" -> Blue, "InteriorRegion" -> RGBColor["#DEF0FF"], "Source" -> Red, "SourceRegion" -> RGBColor["#FFD9D9"], Automatic -> Automatic][type];
End[];
Protect["FigureStyles`*"];
EndPackage[];
BeginPackage["Curvilinear`"];
Unprotect["Curvilinear`*"];
ClearAll["Curvilinear`*"];
ClearAll["Curvilinear`*`*"];
{XBipolar, YBipolar, XYBipolar, UBipolar, VBipolar, UVBipolar, HBipolar, HUBipolar, HVBipolar, CBipolar, SBipolar, AUBipolar, AVBipolar};
{XPolar, YPolar, XYPolar, RPolar, PhiPolar, RPhiPolar, HRPolar, HPhiPolar, ARPolar, APhiPolar};
Begin["`Private`"];
XBipolar[u_, v_] := Sinh[v]/(Cosh[v] - Cos[u]);
YBipolar[u_, v_] := Sin[u]/(Cosh[v] - Cos[u]);
XYBipolar[u_, v_] := {XBipolar, YBipolar} @@ {u, v} // Through // Evaluate;
UBipolar[x_, y_] := ArcTan[x^2 + y^2 - 1, 2 y];
VBipolar[x_, y_] := ArcTanh[2 x/(x^2 + y^2 + 1)];
UVBipolar[x_, y_] := {UBipolar, VBipolar} @@ {x, y} // Through // Evaluate;
HBipolar[u_, v_] := 1/(Cosh[v] - Cos[u]);
HUBipolar[u_, v_] := HBipolar[u, v] // Evaluate;
HVBipolar[u_, v_] := HBipolar[u, v] // Evaluate;
CBipolar[u_, v_] := Cos[u] Cosh[v] - 1;
SBipolar[u_, v_] := Sin[u] Sinh[v];
AUBipolar[u_, v_] := HBipolar[u, v] {-SBipolar[u, v], CBipolar[u, v]} // Evaluate;
AVBipolar[u_, v_] := HBipolar[u, v] {-CBipolar[u, v], -SBipolar[u, v]} // Evaluate;
XPolar[r_, phi_] := r Cos[phi];
YPolar[r_, phi_] := r Sin[phi];
XYPolar[r_, phi_] := {XPolar, YPolar} @@ {r, phi} // Through // Evaluate;
RPolar[x_, y_] := Sqrt[x^2 + y^2];
PhiPolar[x_, y_] := ArcTan[x, y];
RPhiPolar[x_, y_] := {RPolar, PhiPolar} @@ {x, y} // Through // Evaluate;
HRPolar[r_, phi_] := 1;
HPhiPolar[r_, phi_] := r;
ARPolar[r_, phi_] := {Cos[phi], Sin[phi]};
APhiPolar[r_, phi_] := {-Sin[phi], Cos[phi]};
End[];
Protect["Curvilinear`*"];
EndPackage[];
BeginPackage["LaplaceYoung`", {"NDSolve`FEM`", "Conway`"}];
Unprotect["LaplaceYoung`*"];
ClearAll["LaplaceYoung`*"];
ClearAll["LaplaceYoung`*`*"];
{ContactDerivativeList, ContactTracedBoundary, HHalfPlane, XHalfPlaneUniversal, XHalfPlane, DHalfPlane, MeshRefinementUniform, MeshWireframePositions, SolveLaplaceYoung, SolveLaplaceYoungFixedPoint};
Begin["`Private`"];
ContactDerivativeList::usage = ("ContactDerivativeList[sol, gamma]\n" <> "Returns list of pure-function derivatives {p, q, grad2, f, phi} " <> "for the known solution sol == sol(x, y) " <> "and the tracing contact angle gamma:\n" <> "p: x-component of gradient\n" <> "q: y-component of gradient\n" <> "grad2: square of gradient\n" <> "f: flux function\n" <> "phi: viability function\n");
ContactDerivativeList[sol_, gamma_?NumericQ] := Module[{p, q, grad2, f, phi}, p = Derivative[1, 0][sol]; q = Derivative[0, 1][sol]; grad2 = Function[{x, y}, p[x, y]^2 + q[x, y]^2 // Evaluate]; f = Function[{x, y}, Cos[gamma] Sqrt[1 + grad2[x, y]] // Evaluate]; phi = Function[{x, y}, Sin[gamma]^2 grad2[x, y] - Cos[gamma]^2 // Evaluate]; {p, q, grad2, f, phi}];
ContactTracedBoundary::usage = ("ContactTracedBoundary[derList][{x0, y0}, s0, {sStart, sEnd}\n" <> "  , sSign (def 1)\n" <> "  , branchSign (def 1)\n" <> "  , terminationPhi (def 0)\n" <> "  , terminationFunction (def False &)\n" <> "]\n" <> "Returns traced boundary x == x(s), y == y(s) " <> "(arc-length parametrisation) for:\n" <> "- Derivative list derList returned by ContactDerivativeList\n" <> "- Initial condition x(s0) == x0, y(s0) == y0\n" <> "- Arc-length interval sStart < s < sEnd.\n" <> "To traverse the traced boundary backwards, use sSign == -1.\n" <> "To traverse the lower branch, use branchSign == -1.\n" <> "To avoid terminating at Phi == 0, use terminationPhi == -Infinity.\n");
ContactTracedBoundary[derList_List][{x0_, y0_}, s0_, {sStart_, sEnd_}, sSign_: 1, branchSign_: 1, terminationPhi_: 0, terminationFunction_: (False &)] := Module[{p, q, grad2, f, phi, xDerivative, yDerivative, dummyForTrailingCommas}, {p, q, grad2, f, phi} = derList; xDerivative[x_, y_] := Divide[-q[x, y] f[x, y] + branchSign p[x, y] Re@Sqrt@phi[x, y], grad2[x, y]]; yDerivative[x_, y_] := Divide[+p[x, y] f[x, y] + branchSign q[x, y] Re@Sqrt@phi[x, y], grad2[x, y]]; With[{x = \[FormalX], y = \[FormalY], s = \[FormalS]}, NDSolveValue[{x'[s] == sSign xDerivative[x[s], y[s]], y'[s] == sSign yDerivative[x[s], y[s]], x[s0] == x0, y[s0] == y0, WhenEvent[{phi[x[s], y[s]] < terminationPhi, terminationFunction[x[s], y[s]]}, "StopIntegration"]}, {x, y}, {s, sStart, sEnd}, Conway`NoExtrapolation]]];
HHalfPlane::usage = ("HHalfPlane[gamma]\n" <> "Returns the wetting height h == sqrt(2 (1 - sin(gamma))) " <> "for the half-plane solution.");
HHalfPlane[gamma_] := Sqrt[2 (1 - Sin[gamma])];
XHalfPlaneUniversal::usage = ("XHalfPlaneUniversal[t]\n" <> "Returns the half-plane universal curve in implicit form " <> "x == arccosh(2 / T) - sqrt(4 - T^2) - arccosh sqrt(2) + sqrt(2).");
XHalfPlaneUniversal[t_] := ArcCosh[2/t] - Sqrt[4 - t^2] - ArcCosh@Sqrt[2] + Sqrt[2];
XHalfPlane::usage = ("XHalfPlane[gamma][t]\n" <> "Returns the half-plane solution for contact angle gamma along x == 0 " <> "in implicit form x == x (T).");
XHalfPlane[gamma_][t_] := XHalfPlaneUniversal[t] - XHalfPlaneUniversal@HHalfPlane[gamma] // Evaluate;
DHalfPlane::usage = ("DHalfPlane[gamma, gammaT]\n" <> "Returns the offset distance d(gamma, gammaT) " <> "along the half-plane universal curve, between the x == const walls " <> "corresponding to contact angles gamma and gammaT.");
DHalfPlane[gamma_, gammaT_] := XHalfPlaneUniversal@HHalfPlane[gammaT] - XHalfPlaneUniversal@HHalfPlane[gamma];
MeshRefinementUniform::usage = ("MeshRefinementUniform[len]\n" <> "Mesh refinement function to ensure that all mesh elements " <> "have area not exceeding the equilateral triangle of sidelength len.");
MeshRefinementUniform[len_] := Function[{vertices, area}, area > Sqrt[3]/4*len^2 // Evaluate];
MeshWireframePositions::usage = ("MeshWireframePositions[mesh, pattern, containsType (def ContainsAny)]\n" <> "Returns list of positions of elements of mesh " <> "with at least one coordinate satisfying the pattern pattern. " <> "To require all elements satisfying the pattern, " <> "use containsType ContainsOnly.\n" <> "To be used in mesh visualisation, e.g. mesh[\"Wireframe\"[output]].");
MeshWireframePositions[mesh_ElementMesh, pattern_, containsType_: ContainsAny] := Module[{coordinatesPositions, elementPositions}, coordinatesPositions = Position[mesh["Coordinates"], pattern] // Flatten; elementPositions = (Position[mesh["MeshElements"][[1, 1]], list_List /; containsType[list, coordinatesPositions]] // Flatten // Map[{1, #} &]); elementPositions];
SolveLaplaceYoung::usage = ("SolveLaplaceYoung[gamma, mesh, prWet]\n" <> "Solves the Laplace--Young equation over the finite element mesh mesh " <> "with contact angle gamma along the portions of the boundary " <> "for which prWet[x, y] is True.\n" <> "Uses the built-in nonlinear capability of NDSolve`FEM`, Version 12.");
SolveLaplaceYoung[gamma_?NumericQ, mesh_ElementMesh, prWet_] := With[{x = \[FormalX], y = \[FormalY], t = \[FormalCapitalT]}, Module[{grad, iGrad, iDiv, k, tSol}, grad = Grad[#1, {x, y}] & ; iGrad = Inactive[Grad][#1, {x, y}] & ; iDiv = Inactive[Div][#1, {x, y}] & ; k = 1/Sqrt[1 + # . #] & @grad@t[x, y]; tSol = Quiet[NDSolveValue[{iDiv[-k*IdentityMatrix[2] . iGrad@t[x, y]] == -t[x, y] + NeumannValue[Cos[gamma], prWet[x, y]]}, t, Element[{x, y}, mesh]], {NDSolveValue::femibcnd}]; tSol]];
SolveLaplaceYoungFixedPoint::usage = ("SolveLaplaceYoungFixedPoint[gamma, mesh, prWet, tol (def 10^-6)]\n" <> "Solves the Laplace--Young equation over the finite element mesh mesh " <> "with contact angle gamma along the portions of the boundary " <> "for which prWet[x, y] is True and tolerance tol.\n" <> "Uses a simple fixed-point iteration.");
SolveLaplaceYoungFixedPoint[gamma_?NumericQ, mesh_ElementMesh, prWet_, tol : _?NumericQ : 10^-6] := With[{x = \[FormalX], y = \[FormalY], t = \[FormalCapitalT]}, Module[{grad, iGrad, iDiv, tSol, n, relChange, k, tSolNew}, grad = Grad[#1, {x, y}] & ; iGrad = Inactive[Grad][#1, {x, y}] & ; iDiv = Inactive[Div][#1, {x, y}] & ; tSol = 0 & ; n = 0; relChange = Infinity; Monitor[While[Abs[relChange] >= tol, k = 1/Sqrt[1 + # . #] & @grad@tSol[x, y]; tSolNew = Quiet[NDSolveValue[{iDiv[-k*IdentityMatrix[2] . iGrad@t[x, y]] == -t[x, y] + NeumannValue[Cos[gamma], prWet[x, y]]}, t, Element[{x, y}, mesh]], {NDSolveValue::femibcnd}]; n += 1; relChange = (Table[Quiet[tSolNew @@ xy/tSol @@ xy - 1, {Power::infy}], {xy, mesh["Coordinates"]}] /. {Indeterminate -> 0} // Norm[#, Infinity] & ); tSol = tSolNew], {"gamma", gamma, "n", n, "relChange", relChange, "tol", N[tol]}]; {tSol, n}]];
End[];
Protect["LaplaceYoung`*"];
EndPackage[];
Module[{gamma, prismXMax, prismYMax, vatRMax, dipCoatingMesh, predicateWet, dipCoatingSolution},
  gamma = 10 Degree;
  {prismXMax, prismYMax} = {3, 2}/2;
  vatRMax = 5;
dipCoatingMesh := dipCoatingMesh = Module[{fineLengthScale, coarseLengthScale, innerBoundaryPoints, innerBoundaryNumber, outerBoundaryPoints, outerBoundaryNumber, allBoundaryPoints, allBoundaryElements, boundaryMesh, mesh},
    fineLengthScale = 0.01;
    coarseLengthScale = 0.5;
    innerBoundaryPoints = Join[Table[{prismXMax, y}, {y, UniformRange[-prismYMax, prismYMax, +fineLengthScale]}] // Rest, Table[{x, prismYMax}, {x, UniformRange[prismXMax, -prismXMax, -fineLengthScale]}] // Rest, Table[{-prismXMax, y}, {y, UniformRange[prismYMax, -prismYMax, -fineLengthScale]}] // Rest, Table[{x, -prismYMax}, {x, UniformRange[-prismXMax, prismXMax, +fineLengthScale]}] // Rest, {}];
    innerBoundaryNumber = Length[innerBoundaryPoints];
    outerBoundaryPoints = Table[XYPolar[vatRMax, phi], {phi, UniformRange[0, 2 Pi, coarseLengthScale/vatRMax]}] // Rest;
    outerBoundaryNumber = Length[outerBoundaryPoints];
    allBoundaryPoints = Join[innerBoundaryPoints, outerBoundaryPoints];
    allBoundaryElements = LineElement /@ {Table[{n, n + 1}, {n, innerBoundaryNumber}] // Mod[#, innerBoundaryNumber, 1] & , Table[{n, n + 1}, {n, outerBoundaryNumber}] // Mod[#, outerBoundaryNumber, 1] & // # + innerBoundaryNumber & , Nothing};
    boundaryMesh = ToBoundaryMesh["Coordinates" -> allBoundaryPoints, "BoundaryElements" -> allBoundaryElements, {}];
    mesh = ToElementMesh[boundaryMesh, "ImproveBoundaryPosition" -> True, MeshRefinementFunction -> MeshRefinementUniform[coarseLengthScale], "RegionHoles" -> {0, 0}];
    mesh
  ];
  predicateWet = Function[{x, y}, RPolar[x, y] < Way[RPolar[prismXMax, prismYMax], vatRMax] // Evaluate] // Evaluate;
  dipCoatingSolution := dipCoatingSolution = Module[{mesh, tSol},
    mesh = dipCoatingMesh;
    tSol = SolveLaplaceYoung[10 Degree, mesh, predicateWet];
    tSol
  ];
  Print["Finite Element Mesh:"];
  Print[
    Module[{mesh},
      mesh = dipCoatingMesh;
      Show[mesh["Wireframe"], PlotLabel -> StringTemplate["`` elements"]@Length@mesh[[2, 1, 1]]]
    ]
  ];
  Print["3D Plot of Solution:"];
  Print[
    Module[{tSol, mesh, x, y},
      tSol = dipCoatingSolution;
      mesh = tSol["ElementMesh"];
      Plot3D[tSol[x, y], Element[{x, y}, mesh], PlotRange -> Full]
    ]
  ];
  Print["Coating Profile Comparison (Ideal vs. Actual):"];
  Print[
    Module[{tSol, mesh, tSolMin, tSolMax, zMin, zMax, tIdeal, tActual, globalLighting, coatingOffset, coatingOptions, tCoating},
      tSol = dipCoatingSolution;
      mesh = tSol["ElementMesh"];
      tSolMin = tSol[prismXMax, prismYMax];
      tSolMax = Max[tSol[prismXMax, 0], tSol[0, prismYMax]];
      zMin = Way[tSolMin, tSolMax, -0.1];
      zMax = Way[tSolMin, tSolMax, +1.3];
      globalLighting = Automatic;
      coatingOffset = 0.001;
      coatingOptions = {BoundaryStyle -> BoundaryTracingStyle["Edge3D"], Lighting -> globalLighting, Mesh -> None, PlotPoints -> 50, PlotStyle -> BoundaryTracingStyle["Solution3D"], Nothing};
      tCoating["ideal"] = Evaluate@Way[tSolMin, tSolMax, 0.6] &;
      tCoating["actual"] = tSol;
      
      GraphicsRow[
        Table[
          Show[
            Graphics3D@{BoundaryTracingStyle["Wall3D"], EdgeForm@BoundaryTracingStyle["Edge3D"], Cuboid[{-prismXMax, -prismYMax, zMin}, {+prismXMax, +prismYMax, zMax}]},
            ParametricPlot3D[{prismXMax + coatingOffset, y, Way[zMin, tCoating[type][prismXMax, y], p]}, {y, -prismYMax, prismYMax}, {p, 0, 1}, coatingOptions // Evaluate],
            ParametricPlot3D[{x, -prismYMax - coatingOffset, Way[zMin, tCoating[type][x, -prismYMax], p]}, {x, -prismXMax, prismXMax}, {p, 0, 1}, coatingOptions // Evaluate],
            {},
            Lighting -> globalLighting, Boxed -> False, BoxRatios -> {Automatic, Automatic, 1.6}, ImageSize -> 0.35 ImageSizeTextWidth, ViewPoint -> {2.4, -3.5, 1.6}
          ],
          {type, {"ideal", "actual"}}
        ]
      ]
    ]
  ];
]


ClearAll["Global`*"];
rule224={224,{2,{{2,2,2},{2,1,2},{2,2,2}}},{1,1}};
rule90={90,{2,{{2,2,2},{2,1,2},{2,2,2}}},{1,1}};
rule126={126,{2,{{2,2,2},{2,1,2},{2,2,2}}},{1,1}};
rule184={184,{2,{{2,2,2},{2,1,2},{2,2,2}}},{1,1}};
next[rule_][state_]:=Last@CellularAutomaton[rule,state,{{0,1}}];
animate[init_,rule_:rule224]:=DynamicModule[{s=init},Dynamic@ArrayPlot[s=next[rule][s],Mesh->Automatic,ImageSize->Small]];
randomBoard[]:=RandomInteger[1,{20,20}];
block=ConstantArray[0,{5,5}];block[[{3,4},{3,4}]]=1;
tub=ConstantArray[0,{5,5}];tub[[{2,4},3]]=tub[[3,{2,4}]]=1;
beehive=ConstantArray[0,{5,6}];
beehive[[2,{3,4}]]=beehive[[3,{2,5}]]=beehive[[4,{3,4}]]=1;
stillLifeGallery=GraphicsGrid[{{ArrayPlot[block,Mesh->Automatic,ImageSize->Small,PlotLabel->"Block"],ArrayPlot[tub,Mesh->Automatic,ImageSize->Small,PlotLabel->"Tub"],ArrayPlot[beehive,Mesh->Automatic,ImageSize->Small,PlotLabel->"Beehive"]}},Spacings->{2,2}];
blinker=ConstantArray[0,{5,5}];blinker[[{2,3,4},3]]=1;
toad=ConstantArray[0,{6,6}];
toad[[2,3]]=toad[[3,{3,4}]]=toad[[4,{3,4}]]=toad[[5,4]]=1;
oscillatorGallery=Column[{Style["Blinker",Bold],animate[blinker],Style["Toad",Bold],animate[toad]},Spacings->2];
glider=ConstantArray[0,{20,20}];
glider[[3,{1,2,3}]]=glider[[2,3]]=glider[[1,2]]=1;
lwss=ConstantArray[0,{7,30}];
lwss[[3,{3,4,5,6}]]=lwss[[4,{2,6}]]=lwss[[5,6]]=lwss[[6,{2,5}]]=1;
shipGallery=Column[{Style["Glider",Bold],animate[glider],Style["Light-weight Spaceship",Bold],animate[lwss]},Spacings->2];
diehard=ConstantArray[0,{3,8}];
diehard[[1,7]]=diehard[[2,{1,2}]]=diehard[[3,{2,6,7,8}]]=1;
unstableGallery=Column[{Style["Diehard",Bold],animate[diehard]},Spacings->2];
ruleGallery=GraphicsGrid[{{Column[{Style["Rule 90",Bold],animate[randomBoard[],rule90]}],Column[{Style["Rule 126",Bold],animate[randomBoard[],rule126]}],Column[{Style["Rule 184",Bold],animate[randomBoard[],rule184]}]}},Spacings->{3,2}];
dashboard=Column[{Style["Conway\[CloseCurlyQuote]s Game of Life \[LongDash] Interactive Showcase",20,Bold],Style["Still Lifes",16,Bold],stillLifeGallery,Style["Oscillators",16,Bold],oscillatorGallery,Style["Spaceships",16,Bold],shipGallery,Style["Unstable Example",16,Bold],unstableGallery,Style["Random Boards with Alternative Rules",16,Bold],ruleGallery},Spacings->3];
Print[dashboard];
(*CreateDocument[dashboard,WindowTitle->"Game of Life \[LongDash] Exploration (Popup)"];*)


ClearAll[f,evolve,seed,A]
f[x_,y_]:=Boole[y==3||(x==1&&y==2)];   
evolve[m_?MatrixQ]:=Module[{nbr=ListCorrelate[{{1,1,1},{1,0,1},{1,1,1}},m,2,0]},MapThread[f,{m,nbr},2]]
seed[{h_Integer,w_Integer}]:=Module[{m=ConstantArray[0,{h,w}],gun,offset},gun={{5,2},{5,3},{6,2},{6,3},{5,12},{6,12},{7,12},{4,13},{8,13},{3,14},{9,14},{3,15},{9,15},{6,16},{4,17},{8,17},{5,18},{6,18},{7,18},{6,19},{3,22},{4,22},{5,22},{3,23},{4,23},{5,23},{2,24},{6,24},{1,26},{2,26},{6,26},{7,26},{3,36},{4,36},{3,37},{4,37}};
offset={Ceiling[h/2]-10,Ceiling[w/2]-20};Scan[(m[[Sequence@@(#+offset)]]=1)&,gun];
m]
{height,width}={40,80};
A[0]=seed[{height,width}];
A[n_Integer?Positive]:=A[n]=evolve[A[n-1]];
Animate[ArrayPlot[A[t],PixelConstrained->8,ColorRules->{0->White,1->Black},Frame->False,ImageSize->Large],{t,0,200,1},AnimationRunning->False,AnimationRate->20,AnimationRepetitions->Infinity]


ClearAll[colorByAge]
colorByAge[0]:=RGBColor[1,1,1];
colorByAge[n_Integer?Positive]:=ColorData["Rainbow"][Rescale[Min[n,20],{1,20}]];
SetOptions[MatrixPlot,ColorFunction->colorByAge,ColorFunctionScaling->False,Frame->False,ImageSize->400];
ClearAll[initializeGrid]
initializeGrid[rows_Integer?Positive,columns_Integer?Positive,stat_?NumericQ]:=RandomChoice[{stat,1-stat}->{1,0},{rows,columns}];
ClearAll[updateCell]
updateCell[grid_,row_,col_]:=Module[{rmax=Length[grid],cmax=Length[First[grid]],state,nn,zeros},state=grid[[row,col]];nn=Flatten[Table[grid[[Mod[row+dr-1,rmax,1],Mod[col+dc-1,cmax,1]]],{dr,-1,1},{dc,-1,1}]];zeros=Count[nn,0]-Boole[state==0];Which[zeros<5||zeros>=7,0,zeros==5,state+1,zeros==6&&state>0,state+1,True,0]];
ClearAll[updateGrid]
updateGrid[grid_?MatrixQ]:=MapIndexed[updateCell[grid,##2[[1]],##2[[2]]]&,grid,{2}];
ClearAll[runSimulation]
runSimulation[startGrid_,steps_Integer?Positive]:=Module[{grids={startGrid}},Do[AppendTo[grids,updateGrid[Last[grids]]];If[grids[[-1]]===grids[[-2]],Break[]],{steps-1}];grids];
ClearAll[animateSimulation]
animateSimulation[grids_,fps_:6]:=ListAnimate[MatrixPlot/@grids,DefaultDuration->Length[grids]/fps];
SeedRandom[123];
initial=initializeGrid[200,200,0.25];
evolution=runSimulation[initial,100];
animateSimulation[evolution,8]


ClearAll["Global`*"];
idle=".";
sentinel="$";
states=Association["G"->"G","L"->"L","R"->"R","A"->"A","B"->"B","C"->"C","a"->"a","b"->"b","c"->"c","bB"->"bB","cC"->"cC","RL"->"RL","LR"->"LR","F"->"F","I"->idle];
leftChar[s_String]:=StringTake[s,-1];
rightChar[s_String]:=StringTake[s,1];
stateColor=Association[idle->LightGray,"G"->Red,"L"->RGBColor[1,.6,.1],"R"->RGBColor[1,.6,.1],"A"->LightBlue,"B"->LightBlue,"C"->Blue,"a"->RGBColor[.65,.9,.65],"b"->RGBColor[.55,.8,.55],"c"->RGBColor[.45,.7,.45],"bB"->Purple,"cC"->Magenta,"RL"->Brown,"LR"->Yellow,"F"->Black];
drawFrame[seq_List]:=Graphics[Table[{EdgeForm[GrayLevel[.3]],stateColor[seq[[i]]],Rectangle[{i-1,0},{i,1}],Inset[Style[seq[[i]],12,If[stateColor[seq[[i]]]===LightGray,Black,White],Bold],{i-.5,.5}]},{i,Length[seq]}],PlotRangePadding->None,ImageSize->Scaled[1],Background->White];
nextState[l_,s_,r_]:=Module[{lLast=leftChar[l],rFirst=rightChar[r],join=l<>r},Which[s=="A",If[rFirst=="L","G","B"],s=="B","C",s=="C",If[rFirst=="L","G",idle],s=="a",If[lLast=="R","G","b"],s=="b","c",s=="c",If[lLast=="R","G",idle],s=="bB","cC",s=="cC",If[lLast=="R"||rFirst=="L","G",idle],s=="G",Which[MemberQ[{"$$","$G","G$","GG"},join],"F",r==idle&&l==idle,"bB",r==idle,"B",l==idle,"b",True,"G"],s=="L",Which[l==sentinel||lLast=="R","R",lLast=="C","G",r=="G","L",True,idle],s=="R",Which[r==sentinel||rFirst=="L","L",rFirst=="c","G",True,idle],s=="LR",If[lLast=="C"||rFirst=="c","G",idle],s=="RL","LR",s==idle,Which[(l=="G"||lLast=="R")&&(r=="G"||rFirst=="L"),"RL",l=="G"||lLast=="R","R",r=="G"||rFirst=="L","L",lLast=="C","A",rFirst=="c","a",True,idle],True,s]];
updateSeq[seq_List]:=Module[{n=Length[seq]},Table[With[{l=If[i==1,sentinel,seq[[i-1]]],s=seq[[i]],r=If[i==n,sentinel,seq[[i+1]]]},nextState[l,s,r]],{i,n}]];
spaceTimeDiagram[rows_List]:=Module[{codes,crules},codes=Association[idle->0,"G"->1,"L"->2,"R"->3,"A"->4,"B"->5,"C"->6,"a"->7,"b"->8,"c"->9,"bB"->10,"cC"->11,"RL"->12,"LR"->13,"F"->14];crules=Normal[MapIndexed[#2[[1]]-1->stateColor[#1]&,Values[states]]];ArrayPlot[Reverse[rows/. codes],ColorRules->crules,Frame->False,AspectRatio->Automatic,ImageSize->Medium,PlotLabel->Style["Firing-Squad Synchronisation  ("<>ToString[Length[rows]-1]<>" steps)",14,Bold]]];
animateEvolution[rows_List]:=ListAnimate[drawFrame/@rows,ImageSize->Scaled[1],DefaultDuration->6,AnimationRunning->False,AnimationRepetitions->1,ControlPlacement->Top];
evolveFSSP[n_Integer?Positive]:=Module[{seq=ConstantArray[idle,n],rows={},viz},seq[[1]]="G";AppendTo[rows,seq];While[Union[seq]=!={"F"},seq=updateSeq[seq];AppendTo[rows,seq];];viz=Column[{Style["Total steps: "<>ToString[Length[rows]-1],14,Bold],animateEvolution[rows],spaceTimeDiagram[rows]},Spacings->2,Alignment->Center,BaseStyle->{FontFamily->"Helvetica"}];Print[viz];viz];
evolveFSSP[13]


ClearAll["Global`*"];
stateToInt=Association["\[CenterDot]"->0,"G"->1,"L"->2,"R"->3,"A"->4,"B"->5,"C"->6,"a"->7,"b"->8,"c"->9,"bB"->10,"cC"->11,"RL"->12,"LR"->13,"F"->14];
intToState=Association[KeyValueMap[#2->#1&,stateToInt]];
nextState[l_String,s_String,r_String]:=Module[{lLast=StringTake[l,-1],rFirst=StringTake[r,1]},Which[s=="A",If[rFirst=="L","G","B"],s=="B","C",s=="C",If[rFirst=="L","G","\[CenterDot]"],s=="a",If[lLast=="R","G","b"],s=="b","c",s=="c",If[lLast=="R","G","\[CenterDot]"],s=="bB","cC",s=="cC",If[lLast=="R"||rFirst=="L","G","\[CenterDot]"],s=="G",Which[MemberQ[{"$$","$G","G$","GG"},l<>r],"F",r=="\[CenterDot]"&&l=="\[CenterDot]","bB",r=="\[CenterDot]","B",l=="\[CenterDot]","b",True,"G"],s=="L",Which[l=="$"||lLast=="R","R",lLast=="C","G",r=="G","L",True,"\[CenterDot]"],s=="R",Which[r=="$"||rFirst=="L","L",rFirst=="c","G",True,"\[CenterDot]"],s=="LR",If[lLast=="C"||rFirst=="c","G","\[CenterDot]"],s=="RL","LR",s=="\[CenterDot]",Which[(l=="G"||lLast=="R")&&(r=="G"||rFirst=="L"),"RL",l=="G"||lLast=="R","R",r=="G"||rFirst=="L","L",lLast=="C","A",rFirst=="c","a",True,"\[CenterDot]"],True,s]];
simulateFiringSquad[n_:21,maxSteps_:60]:=Module[{seq=ConstantArray["\[CenterDot]",n],history={},newSeq},seq[[1]]="G";AppendTo[history,seq];Do[newSeq=Table[With[{l=If[j==1,"$",seq[[j-1]]],r=If[j==n,"$",seq[[j+1]]]},nextState[l,seq[[j]],r]],{j,n}];AppendTo[history,newSeq];seq=newSeq;If[Union[seq]=={"F"},Break[]],{maxSteps}];history];
palette=ColorData["Rainbow"]/@Subdivide[0,1,14];
colorRules=Thread[Range[0,14]->palette];
firingSquadAnimate[n_:21,max_:60]:=Module[{hist=simulateFiringSquad[n,max]/. stateToInt},ListAnimate[(ArrayPlot[hist[[1;;#1]],ColorRules->colorRules,Frame->False,PixelConstrained->8,ImageSize->Large]&)/@Range[Length[hist]],AnimationRunning->False,AnimationRepetitions->1,DefaultDuration->0.25 Length[hist]]];
firingSquadAnimate[21,60]


DynamicModule[{$happenedBeforeMatrix,$events=CharacterRange["A","Z"],colorRules={1->White,-1->White,0->Black},examples,resetGVM,insertLogic,processCommands,rebuild},examples=Association["Linear Chain"->StringRiffle[Table["insert "<>$events[[i]]<>"->"<>$events[[i+1]],{i,1,25}],"; "],"Diamond Shape"->"insert A->B; insert A->C; insert B->D; insert C->D; insert D->E; insert E->F; insert E->G; insert F->H; insert G->H; insert H->I; insert I->J; insert I->K; insert J->L; insert K->L; insert L->M; insert M->N; insert M->O; insert N->P; insert O->P; insert P->Q; insert Q->R; insert Q->S; insert R->T; insert S->T; insert T->U; insert U->V; insert U->W; insert V->X; insert W->X; insert X->Y; insert Y->Z;","Fork-Join"->"insert A->B; insert A->C; insert A->D; insert B->E; insert C->E; insert D->E; insert E->F; insert F->G; insert F->H; insert G->I; insert H->I; insert I->J; insert J->K; insert J->L; insert J->M; insert K->N; insert L->N; insert M->N; insert N->O; insert O->P; insert O->Q; insert P->R; insert Q->R; insert R->S; insert S->T; insert S->U; insert S->V; insert T->W; insert U->W; insert V->W; insert W->X; insert X->Y; insert Y->Z;","Parallel Streams"->"insert A->B; insert C->D; insert E->F; insert G->H; insert I->J; insert K->L; insert M->N; insert O->P; insert Q->R; insert S->T; insert U->V; insert W->X; insert Y->Z;","Random DAG"->"insert A->D; insert A->C; insert B->D; insert B->E; insert C->F; insert D->G; insert E->H; insert F->H; insert G->I; insert H->J; insert I->K; insert J->K; insert K->L; insert L->M; insert L->N; insert M->O; insert N->P; insert O->Q; insert P->Q; insert Q->R; insert R->S; insert S->T; insert T->U; insert U->V; insert V->W; insert W->X; insert X->Y; insert Y->Z;","Simple Cycle"->"insert A->B; insert B->C; insert C->D; insert D->E; insert E->F; insert F->G; insert G->H; insert H->I; insert I->J; insert J->K; insert K->L; insert L->M; insert M->N; insert N->O; insert O->P; insert P->Q; insert Q->R; insert R->S; insert S->T; insert T->U; insert U->V; insert V->W; insert W->X; insert X->Y; insert Y->Z; insert Z->A;"];resetGVM[]:=($happenedBeforeMatrix=ConstantArray[0,{Length[$events],Length[$events]}];);insertLogic[eA_String,eB_String]:=Module[{posA,posB,n=Length[$events]},posA=First[Flatten[Position[$events,eA]]];posB=First[Flatten[Position[$events,eB]]];If[$happenedBeforeMatrix[[posB,posA]]===1,Return[]];$happenedBeforeMatrix[[posA,posB]]=1;$happenedBeforeMatrix[[posB,posA]]=-1;Do[If[$happenedBeforeMatrix[[k,posA]]===1&&$happenedBeforeMatrix[[k,posB]]=!=1,$happenedBeforeMatrix[[k,posB]]=1;$happenedBeforeMatrix[[posB,k]]=-1;],{k,n}];Do[If[$happenedBeforeMatrix[[posB,k]]===1&&$happenedBeforeMatrix[[posA,k]]=!=1,$happenedBeforeMatrix[[posA,k]]=1;$happenedBeforeMatrix[[k,posA]]=-1;],{k,n}];];processCommands[txt_String]:=Module[{parts},parts=StringSplit[txt,";"];Do[With[{c=StringTrim[part]},If[StringStartsQ[c,"insert"],Module[{ev=StringSplit[StringTrim[StringDrop[c,6]],"->"]},If[Length[ev]==2,insertLogic[ev[[1]],ev[[2]]]]]]],{part,parts}];];rebuild[]:=Module[{edges,Gfull,Gred,fullPlot,hassePlot},edges=Flatten[Table[If[$happenedBeforeMatrix[[i,j]]===1,$events[[i]]->$events[[j]],Nothing],{i,Length[$events]},{j,Length[$events]}]];Gfull=Graph[$events,edges,DirectedEdges->True];Gred=TransitiveReductionGraph[Gfull];fullPlot=GraphPlot[edges,DirectedEdges->True,VertexRenderingFunction->({Black,Disk[#1,0.025],Black,Text[#2,#1]}&),PlotStyle->{RGBColor[0,0,0.5]},ImageSize->{300,250}];hassePlot=GraphPlot[EdgeList[Gred]/. x_\[DirectedEdge]y_:>x->y,DirectedEdges->True,VertexRenderingFunction->({Black,Disk[#1,0.025],Black,Text[#2,#1]}&),PlotStyle->{RGBColor[0,0,0.5]},ImageSize->{300,250}];Column[{fullPlot,Spacer[10],hassePlot}]];Column[Table[resetGVM[];processCommands[examples[exName]];Framed[Column[{Style[exName,Black,Bold,16],Spacer[5],rebuild[],Spacer[10],MatrixPlot[$happenedBeforeMatrix,ColorRules->colorRules,Mesh->All,Frame->True,FrameTicks->{Table[{i,Style[$events[[i]],Black,10]},{i,Length[$events]}],Table[{j,Style[$events[[j]],Black,10]},{j,Length[$events]}]},FrameTicksStyle->Black,ImageSize->{500,450},Background->White]}],Background->White,FrameStyle->Black,RoundingRadius->6],{exName,Keys[examples]}],Spacings->2]]


ClearAll["Global`*"];
idle=".";
sentinel="$";
states=Association["G"->"G","L"->"L","R"->"R","A"->"A","B"->"B","C"->"C","a"->"a","b"->"b","c"->"c","bB"->"bB","cC"->"cC","RL"->"RL","LR"->"LR","F"->"F","I"->idle];
stateColor=Association[idle->LightGray,"G"->Red,"L"->RGBColor[1,.6,.1],"R"->RGBColor[1,.6,.1],"A"->LightBlue,"B"->LightBlue,"C"->Blue,"a"->RGBColor[.65,.9,.65],"b"->RGBColor[.55,.8,.55],"c"->RGBColor[.45,.7,.45],"bB"->Purple,"cC"->Magenta,"RL"->Brown,"LR"->Yellow,"F"->Black];
leftChar[l_String]:=If[l===sentinel,sentinel,StringTake[l,-1]];
rightChar[r_String]:=If[r===sentinel,sentinel,StringTake[r,1]];
drawFrame[seq_List]:=Graphics[Table[{EdgeForm[GrayLevel[.3]],stateColor[seq[[i]]],Rectangle[{i-1,0},{i,1}],Inset[Style[seq[[i]],12,If[stateColor[seq[[i]]]===LightGray,Black,White],Bold],{i-.5,.5}]},{i,Length[seq]}],PlotRangePadding->None,ImageSize->Scaled[1],Background->White];
nextState[l_String,s_String,r_String]:=Module[{lLast=leftChar[l],rFirst=rightChar[r],join=l<>r},Which[s=="A",If[rFirst=="L","G","B"],s=="B","C",s=="C",If[rFirst=="L","G",idle],s=="a",If[lLast=="R","G","b"],s=="b","c",s=="c",If[lLast=="R","G",idle],s=="bB","cC",s=="cC",If[lLast=="R"||rFirst=="L","G",idle],s=="G",Which[MemberQ[{"$$","$G","G$","GG"},join],"F",r==idle&&l==idle,"bB",r==idle,"B",l==idle,"b",True,"G"],s=="L",Which[l==sentinel||lLast=="R","R",lLast=="C","G",r=="G","L",True,idle],s=="R",Which[r==sentinel||rFirst=="L","L",rFirst=="c","G",True,idle],s=="LR",If[lLast=="C"||rFirst=="c","G",idle],s=="RL","LR",s==idle,Which[(l=="G"||lLast=="R")&&(r=="G"||rFirst=="L"),"RL",l=="G"||lLast=="R","R",r=="G"||rFirst=="L","L",lLast=="C","A",rFirst=="c","a",True,idle],True,s]];
spaceTimeDiagram[rows_List]:=Module[{codes,crules},codes=Association[idle->0,"G"->1,"L"->2,"R"->3,"A"->4,"B"->5,"C"->6,"a"->7,"b"->8,"c"->9,"bB"->10,"cC"->11,"RL"->12,"LR"->13,"F"->14];crules={0->LightGray,1->Red,2->RGBColor[1,.6,.1],3->RGBColor[1,.6,.1],4->LightBlue,5->LightBlue,6->Blue,7->RGBColor[.65,.9,.65],8->RGBColor[.55,.8,.55],9->RGBColor[.45,.7,.45],10->Purple,11->Magenta,12->Brown,13->Yellow,14->Black};ArrayPlot[Reverse[rows/. codes],ColorRules->crules,Frame->False,AspectRatio->Automatic,ImageSize->Medium,PlotLabel->Style["Firing-Squad Synchronisation ("<>ToString[Length[rows]-1]<>" steps)",14,Bold]]];
animateEvolution[rows_List]:=ListAnimate[drawFrame/@rows,ImageSize->Scaled[1],DefaultDuration->6,AnimationRunning->False,AnimationRepetitions->1,ControlPlacement->Top];
updateSeq[seq_List]:=Module[{n=Length[seq]},Table[With[{l=If[i==1,sentinel,seq[[i-1]]],s=seq[[i]],r=If[i==n,sentinel,seq[[i+1]]]},nextState[l,s,r]],{i,n}]];
evolveDeterministicFSSP[n_Integer?Positive]:=Module[{seq,rows={}},seq=ConstantArray[idle,n];seq[[1]]="G";AppendTo[rows,seq];While[Union[seq]=!={"F"},seq=updateSeq[seq];AppendTo[rows,seq];];Column[{Style["Deterministic Lamport Firing-Squad ("<>ToString[n]<>" cells)",14,Bold],animateEvolution[rows],spaceTimeDiagram[rows]},Spacings->2,Alignment->Center,BaseStyle->{FontFamily->"Helvetica"}]];
updateSeqLR[seq_List]:=Module[{new=seq,n=Length[seq]},Do[new[[i]]=nextState[If[i==1,sentinel,new[[i-1]]],seq[[i]],If[i==n,sentinel,seq[[i+1]]]],{i,1,n}];new];
updateSeqRL[seq_List]:=Module[{new=seq,n=Length[seq]},Do[new[[i]]=nextState[If[i==1,sentinel,seq[[i-1]]],seq[[i]],If[i==n,sentinel,new[[i+1]]]],{i,n,1,-1}];new];
evolveQuantumFSSP[n_Integer?Positive,maxSteps_Integer?Positive]:=Module[{branches,history={}},branches={ReplacePart[ConstantArray[idle,n],1->"G"]};AppendTo[history,branches];Do[branches=DeleteDuplicates[Flatten[Table[{updateSeqLR[b],updateSeqRL[b]},{b,branches}],1]];AppendTo[history,branches],{maxSteps}];Column[{Style["Quantum-Inspired Firing-Squad ("<>ToString[n]<>" cells, "<>ToString[maxSteps]<>" steps)",14,Bold],Sequence@@Table[Column[{Style["Step "<>ToString[step],12,Bold],GraphicsRow[drawFrame/@history[[step+1]],Spacings->2]}],{step,0,maxSteps}]},Spacings->2]];
Print[Style["Running Deterministic Simulation...",Italic]];
evolveDeterministicFSSP[13]
Print[Style["\nRunning Quantum-Inspired (Multiway) Simulation...",Italic]];
evolveQuantumFSSP[7,6]


ClearAll["Global`*"];
ClearAll[buildRules];
buildRules[pairs_List,next_]:=AssociationThread[StringReplace[pairs," "->""]->ConstantArray[next,Length[pairs]]];
lRules=Merge[{buildRules[{"X, L","L, X","L, L","L, B","L, C","L, G","A, A","A, B","A, C","B, X","B, L","B, A","B, B","B, C","B, G","C, A","C, B","C, C","G, A","G, B","G, C"},"L"],buildRules[{"C, L","G, X","G, G"},"A"],buildRules[{"A, X","A, G","G, L"},"C"],buildRules[{"A, L","C, X","C, G"},"G"]},First];
aRules=Merge[{buildRules[{"L, B"},"L"],buildRules[{"L, A","A, L","A, A","C, L","C, A"},"A"],buildRules[{"A, B","A, G"},"B"],buildRules[{"A, C","B, X","B, C","B, G","G, X","G, C","G, G"},"C"],buildRules[{"X, C","L, C","B, L","B, B"},"G"],buildRules[{"X, A","A, X"},"F"]},First];
bRules=Merge[{buildRules[{"L, C","A, C","C, X","C, L","C, G"},"L"],buildRules[{"B, A","C, A"},"A"],buildRules[{"L, B","L, G","A, A","A, B","B, B","B, G","G, C"},"B"],buildRules[{"B, C","G, L","G, A"},"C"],buildRules[{"L, A","A, L","B, L","G, X","G, G"},"G"]},First];
cRules=Merge[{buildRules[{"L, A","C, A"},"A"],buildRules[{"A, X","A, L","A, B","A, G","C, B","C, G","G, X","G, L","G, B","G, G"},"B"],buildRules[{"L, L","L, C","B, L","B, C","C, L","C, C"},"C"],buildRules[{"L, B","L, G","B, X","B, G"},"G"]},First];
gRules=Merge[{buildRules[{"X, L","C, X","C, L","C, G"},"A"],buildRules[{"A, L","B, L","G, L"},"B"],buildRules[{"X, B","X, C","L, A","L, B","L, C","A, B","A, C","B, X","B, B","B, C","B, G","C, B","C, C","G, B","G, C"},"G"],buildRules[{"X, G","G, X","G, G"},"F"]},First];
finalRules=Association["*"->"F"];
cellRules=Association["L"->lRules,"A"->aRules,"B"->bRules,"C"->cRules,"G"->gRules,"F"->finalRules];
transition[left_,cell_,right_]:=Module[{key=StringReplace[left<>","<>right," "->""]},If[cell==="F","F",Lookup[cellRules[cell],key,Print["Error: Undefined rule for ",{cell,left,right}];Abort[]]]];
stepUpdate[state_List]:=Module[{n=Length[state],nxt},nxt=ConstantArray["",n];nxt[[1]]=transition["X",state[[1]],state[[2]]];nxt[[n]]=transition[state[[-2]],state[[-1]],"X"];Do[nxt[[i]]=transition[state[[i-1]],state[[i]],state[[i+1]]],{i,2,n-1}];nxt];
stateColors=Association["G"->Blue,"L"->LightGray,"A"->Red,"B"->Green,"C"->Yellow,"F"->Purple];
visualizeSteps[history_List]:=Module[{numSteps,numCells,rects},numSteps=Length[history];numCells=Length[First[history]];rects=Flatten[Table[{EdgeForm[Black],FaceForm[stateColors[history[[step,cell]]]],Rectangle[{cell-1,-step}]},{step,1,numSteps},{cell,1,numCells}],1];Graphics[{rects,Table[Text[Style[history[[step,cell]],Bold,12],{cell-0.5,-step+0.5}],{step,1,numSteps},{cell,1,numCells}]},Axes->False,Frame->True,FrameTicks->None,AspectRatio->Automatic,PlotRangePadding->0.1,FrameLabel->{"Cells","Steps"},ImageSize->50 numCells]];
runMazoyerWithGraphics[num_Integer?Positive]:=Module[{current,next,history={},step=0},current=ConstantArray["L",num];current[[1]]="G";AppendTo[history,current];While[True,step++;next=stepUpdate[current];AppendTo[history,next];If[MemberQ[next,"F"],If[AllTrue[next,#1=="F"&],Break[],Break[]]];current=next;];Print["Completed in ",step," steps for squad of size ",num,"."];visualizeSteps[history]];
Column[{runMazoyerWithGraphics[11],runMazoyerWithGraphics[12]}]


ClearAll["Global`*"];
stateToInt=Association["\[CenterDot]"->0,"G"->1,"L"->2,"R"->3,"A"->4,"B"->5,"C"->6,"a"->7,"b"->8,"c"->9,"bB"->10,"cC"->11,"RL"->12,"LR"->13,"F"->14];
intToState=Association[KeyValueMap[#2->#1&,stateToInt]];
nextState[l_String,s_String,r_String]:=Module[{lLast=StringTake[l,-1],rFirst=StringTake[r,1]},Which[s=="A",If[rFirst=="L","G","B"],s=="B","C",s=="C",If[rFirst=="L","G","\[CenterDot]"],s=="a",If[lLast=="R","G","b"],s=="b","c",s=="c",If[lLast=="R","G","\[CenterDot]"],s=="bB","cC",s=="cC",If[lLast=="R"||rFirst=="L","G","\[CenterDot]"],s=="G",Which[MemberQ[{"$$","$G","G$","GG"},l<>r],"F",r=="\[CenterDot]"&&l=="\[CenterDot]","bB",r=="\[CenterDot]","B",l=="\[CenterDot]","b",True,"G"],s=="L",Which[l=="$"||lLast=="R","R",lLast=="C","G",r=="G","L",True,"\[CenterDot]"],s=="R",Which[r=="$"||rFirst=="L","L",rFirst=="c","G",True,"\[CenterDot]"],s=="LR",If[lLast=="C"||rFirst=="c","G","\[CenterDot]"],s=="RL","LR",s=="\[CenterDot]",Which[(l=="G"||lLast=="R")&&(r=="G"||rFirst=="L"),"RL",l=="G"||lLast=="R","R",r=="G"||rFirst=="L","L",lLast=="C","A",rFirst=="c","a",True,"\[CenterDot]"],True,s]];
simulateFiringSquad[n_:21,maxSteps_:60]:=Module[{seq=ConstantArray["\[CenterDot]",n],history={},newSeq},seq[[1]]="G";AppendTo[history,seq];Do[newSeq=Table[With[{l=If[j==1,"$",seq[[j-1]]],r=If[j==n,"$",seq[[j+1]]]},nextState[l,seq[[j]],r]],{j,n}];AppendTo[history,newSeq];seq=newSeq;If[Union[seq]=={"F"},Break[]],{maxSteps}];history];
palette=ColorData["Rainbow"]/@Subdivide[0,1,14];
colorRules=Thread[Range[0,14]->palette];
firingSquadAnimate[n_:21,max_:60]:=Module[{hist=simulateFiringSquad[n,max]/. stateToInt},ListAnimate[(ArrayPlot[hist[[1;;#1]],ColorRules->colorRules,Frame->False,PixelConstrained->8,ImageSize->Large]&)/@Range[Length[hist]],AnimationRunning->False,AnimationRepetitions->1,DefaultDuration->0.25 Length[hist]]];
firingSquadAnimate[21,60]


ClearAll[Evaluate[Select[Names["Global`*"],FreeQ[{"System`","PacletManager`"}/. HoldPattern->HoldPattern,ToExpression[#1,StandardForm,HoldComplete]&]]]];
CornerCoords=Table[{0.25 IntegerDigits[i,4,2][[2]],0.75-0.25 IntegerDigits[i,4,2][[1]]},{i,0,15}];
d=0.01;
RectCoords=Table[{{d,d}+cor,{0.25-d,0.25-d}+cor},{cor,CornerCoords}];
ZeroC=RGBColor["#29AB87"];
OneC=RGBColor["#0F52BA"];
PauliText={Text[Style[ToExpression["II",TeXForm,HoldForm],Large],{0.125,1.125}],Text[Style[ToExpression["IZ",TeXForm,HoldForm],Large],{0.375,1.125}],Text[Style[ToExpression["IX",TeXForm,HoldForm],Large],{0.625,1.125}],Text[Style[ToExpression["IY",TeXForm,HoldForm],Large],{0.875,1.125}],Text[Style[ToExpression["II",TeXForm,HoldForm],Large],{-0.125,0.875}],Text[Style[ToExpression["ZI",TeXForm,HoldForm],Large],{-0.125,0.625}],Text[Style[ToExpression["XI",TeXForm,HoldForm],Large],{-0.125,0.375}],Text[Style[ToExpression["YI",TeXForm,HoldForm],Large],{-0.125,0.125}]};
DividingLines={{Gray,Line[{{0.25,0.0},{0.25,1.25}}]},{Gray,Line[{{0.5,0.0},{0.5,1.25}}]},{Gray,Line[{{0.75,0.0},{0.75,1.25}}]},{Gray,Line[{{-0.25,0.25},{1.0,0.25}}]},{Gray,Line[{{-0.25,0.5},{1.0,0.5}}]},{Gray,Line[{{-0.25,0.75},{1.0,0.75}}]},{Black,Line[{{-0.25,1.0},{1.0,1.0}}]},{Black,Line[{{0.0,0.0},{0.0,1.25}}]}};
DividingLinesRaw={{Gray,Line[{{0.25,0.0},{0.25,1.0}}]},{Gray,Line[{{0.5,0.0},{0.5,1.0}}]},{Gray,Line[{{0.75,0.0},{0.75,1.0}}]},{Gray,Line[{{0.0,0.25},{1.0,0.25}}]},{Gray,Line[{{0.0,0.5},{1.0,0.5}}]},{Gray,Line[{{0.0,0.75},{1.0,0.75}}]}};
ProjPauliTups=Tuples[{0,1},4];
ProjPauliStr={"II","IX","IY","IZ","XI","XX","XY","XZ","YI","YX","YY","YZ","ZI","ZX","ZY","ZZ"};
Tup2BS[tup_List]/;Length[tup]==4:={{tup[[1]],tup[[3]]},{tup[[2]],tup[[4]]},0};
BS2Tup[bs_List]/;Length[bs]==3:={bs[[1,1]],bs[[2,1]],bs[[1,2]],bs[[2,2]]};
R2I[A_List]:=Which[Length[A]==3,FromDigits[BS2Tup[A],2]+1,Length[A]==4,FromDigits[A,2]+1,True,Message[R2I::bad,A];$Failed];
R2I::bad="Unrecognized object for indexing: `1`.";
I2T[i_Integer?Positive]:=IntegerDigits[i-1,2,4];
PauliDict=AssociationThread[ProjPauliStr,Tup2BS/@ProjPauliTups];
BSInner[s1_,s2_]:=Mod[s1[[1]] . s2[[2]]-s2[[1]] . s1[[2]],4];
BetaFn[s1_,s2_]:=Module[{sum},sum=\!\(
\*UnderoverscriptBox[\(\[Sum]\), \(i\), \(2\)]\((s1[[2, i]]\ \((s1[[1, i]] + s2[[1, i]])\)\ s2[[2, i]] + s1[[1, i]]\ s2[[1, i]]\ \((s1[[2, i]] + s2[[2, i]])\))\)\);Mod[1/2 (BSInner[s1,s2]+2 sum),2]];
stabgroup[g1_,g2_]:=Module[{c},If[OddQ[BSInner[g1,g2]],Message[stabgroup::noncomm];Return[$Failed];];c=Mod[g1[[1]]+g2[[1]],2];Mod[{{{0,0},{0,0},0},g1,g2,{c,Mod[g1[[2]]+g2[[2]],2],Mod[BetaFn[g1,g2]+g1[[3]]+g2[[3]],2]}},2]];
stabgroup::noncomm="Generators do not commute.";
ConsistentPhase[sg_List]:=Module[{gamma=ConstantArray[0,16]},Do[gamma[[R2I[BS2Tup[s]]]]=s[[3]],{s,sg}];gamma];
SampleLambda[S_List]:=Module[{ref},If[Length[S]>1,ref=RandomChoice[S[[2;;4]]];{BS2Tup[ref],ConsistentPhase[S]},{I2T[RandomInteger[{2,16}]],ConsistentPhase[S]}]];
GammaId[\[Lambda]_]:=\[Lambda];
GammaP[P_,\[Lambda]_]:=Module[{lt=\[Lambda],bsP=P},lt[[1]]=Mod[lt[[1]]+BS2Tup[bsP],2];Do[If[OddQ[BSInner[bsP,Tup2BS[I2T[j]]]],lt[[2,j]]=Mod[1+lt[[2,j]],2]],{j,16}];lt];
HBS[i_,S_]:=Module[{s=S},s[[1,i]]=S[[2,i]];s[[2,i]]=S[[1,i]];s[[3]]=Mod[S[[3]]+S[[1,i]] S[[2,i]],2];s];
HTup[i_,S_]:=BS2Tup[HBS[i,Tup2BS[S]]];
GammaH[i_,\[Lambda]_]:=Module[{lt=\[Lambda]},lt[[1]]=HTup[i,lt[[1]]];Do[lt[[2,R2I[HTup[i,I2T[j]]]]]=Module[{bs=HBS[i,Tup2BS[I2T[j]]]},Mod[bs[[3]]+lt[[2,j]],2]],{j,16}];lt];
SBS[i_,S_]:=Module[{s=S},s[[2,i]]=Mod[S[[1,i]]+S[[2,i]],2];s[[3]]=Mod[S[[3]]+S[[1,i]] S[[2,i]],2];s];
STup[i_,S_]:=BS2Tup[SBS[i,Tup2BS[S]]];
GammaS[i_,\[Lambda]_]:=Module[{lt=\[Lambda]},lt[[1]]=STup[i,lt[[1]]];Do[lt[[2,R2I[STup[i,I2T[j]]]]]=Module[{bs=SBS[i,Tup2BS[I2T[j]]]},Mod[bs[[3]]+lt[[2,j]],2]],{j,16}];lt];
CNOTBS[a_,b_,S_]:=Module[{s=S},s[[1,b]]=Mod[S[[1,a]]+S[[1,b]],2];s[[2,a]]=Mod[S[[2,a]]+S[[2,b]],2];s[[3]]=Mod[S[[3]]+Mod[S[[1,b]]+S[[2,a]]+1,2] (S[[1,a]] S[[2,b]]),2];s];
CNOTTup[a_,b_,S_]:=BS2Tup[CNOTBS[a,b,Tup2BS[S]]];
GammaCNOT[a_,b_,\[Lambda]_]:=Module[{lt=\[Lambda]},lt[[1]]=CNOTTup[a,b,lt[[1]]];Do[lt[[2,R2I[CNOTTup[a,b,I2T[j]]]]]=Module[{bs=CNOTBS[a,b,Tup2BS[I2T[j]]]},Mod[bs[[3]]+lt[[2,j]],2]],{j,16}];lt];
GammaSWAP[\[Lambda]_]:=GammaCNOT[1,2,GammaCNOT[2,1,GammaCNOT[1,2,\[Lambda]]]];
GammaCZ[\[Lambda]_]:=GammaH[2,GammaCNOT[1,2,GammaH[2,\[Lambda]]]];
GammaCZRedux[a_,b_,\[Lambda]_]:=GammaH[b,GammaCNOT[a,b,GammaH[b,\[Lambda]]]];
MmtOutcome[M_,\[Lambda]_]:=Module[{idx},Which[Length[M]==3,idx=FromDigits[BS2Tup[M],2]+1;Mod[\[Lambda][[2,idx]]+M[[3]],2],Length[M]==4,idx=FromDigits[M,2]+1;\[Lambda][[2,idx]],True,Message[MmtOutcome::bad,M];$Failed]];
MmtOutcome::bad="Unrecognized measurement object `1`.";
GenerateCommutingSubset[P_,inG_]:=Select[inG,EvenQ[BSInner[Tup2BS[#1],Tup2BS[P]]]&];
GenerateACommutingSubset[P_,inG_]:=Select[inG,OddQ[BSInner[Tup2BS[#1],Tup2BS[P]]]&];
CommutingCase[M_,\[Lambda]_]:=Module[{\[Gamma]=\[Lambda][[2]]},Do[\[Gamma][[R2I[s]]]=RandomInteger[{0,1}],{s,GenerateACommutingSubset[BS2Tup[M],GenerateCommutingSubset[\[Lambda][[1]],ProjPauliTups]]}];\[Gamma][[R2I[Mod[BS2Tup[M]+\[Lambda][[1]],2]]]]=Mod[BetaFn[M,Tup2BS[\[Lambda][[1]]]]+\[Lambda][[2,R2I[BS2Tup[M]]]]+\[Lambda][[2,R2I[\[Lambda][[1]]]]],2];\[Gamma]];
AntiCommutingCase[M_,\[Lambda]_]:=Module[{\[Gamma]=\[Lambda][[2]]},Do[\[Gamma][[R2I[s]]]=RandomInteger[{0,1}],{s,GenerateACommutingSubset[BS2Tup[M],GenerateCommutingSubset[\[Lambda][[1]],ProjPauliTups]]}];Do[\[Gamma][[R2I[Mod[s+BS2Tup[M],2]]]]=Mod[BetaFn[M,Tup2BS[s]]+\[Lambda][[2,R2I[BS2Tup[M]]]]+\[Lambda][[2,R2I[s]]],2],{s,GenerateCommutingSubset[BS2Tup[M],GenerateCommutingSubset[\[Lambda][[1]],ProjPauliTups]]}];\[Gamma]];
PhaseUpdate[M_,\[Lambda]_]:=If[EvenQ[BSInner[M,Tup2BS[\[Lambda][[1]]]]],CommutingCase[M,\[Lambda]],AntiCommutingCase[M,\[Lambda]]];
OnticMeasurementUpdate[M_,\[Lambda]_]:={If[Length[M]==3,BS2Tup[M],M],PhaseUpdate[M,\[Lambda]]};
RectProperties[\[Lambda]_,ind_]:={If[\[Lambda][[2,ind]]==1,OneC,ZeroC],Rectangle[RectCoords[[ind,1]],RectCoords[[ind,2]]]};
RectList[\[Lambda]_]:=Module[{pl=R2I[\[Lambda][[1]]]},Flatten[{Table[RectProperties[\[Lambda],i],{i,16}],{Disk[{0.125-d,0.125-d}+RectCoords[[pl,1]],0.07]}}]];
FiniteStatePauli[l_List]:=Table[Graphics[Join[RectList[l[[i]]],PauliText,DividingLines],PlotRange->{{-0.25,1.0},{0,1.25}},ImageSize->300],{i,Length[l]}];
FiniteStateRaw[l_List]:=Table[Graphics[Join[RectList[l[[i]]],DividingLinesRaw],PlotRange->{{0,1.0},{0,1.0}},ImageSize->300],{i,Length[l]}];
LocateMcell[M_,\[Lambda]_]:=Module[{G=RectList[\[Lambda]],idx},idx=R2I[If[Length[M]==3,BS2Tup[M],M]];PrependTo[G[[idx]],If[EvenQ[BSInner[M,Tup2BS[\[Lambda][[1]]]]],EdgeForm[{Thickness[0.01],Green,Dashed}],EdgeForm[{Thickness[0.01],Green}]]];AppendTo[G,{Opacity[0.5],Disk[{0.125-d,0.125-d}+RectCoords[[idx,1]],0.07]}];G];
LocateDetUpdates[M_,\[Lambda]_]:=Module[{G=LocateMcell[M,\[Lambda]]},If[EvenQ[BSInner[M,Tup2BS[\[Lambda][[1]]]]],Module[{target=R2I[Mod[BS2Tup[M]+\[Lambda][[1]],2]]},PrependTo[G[[target]],EdgeForm[{Thickness[0.01]}]];AppendTo[G,{EdgeForm[{Thickness[0.01],Green,Dashed}],Transparent,G[[target,3]]}];PrependTo[G[[target]],Opacity[0.5]];],Do[Module[{a=R2I[s],b=R2I[Mod[s+BS2Tup[M],2]]},PrependTo[G[[a]],EdgeForm[{Thickness[0.01],Purple}]];PrependTo[G[[b]],EdgeForm[{Thickness[0.01],Purple}]];AppendTo[G,{EdgeForm[{Thickness[0.01],Green,Dashed}],Transparent,G[[b,3]]}];PrependTo[G[[b]],Opacity[0.5]];],{s,GenerateCommutingSubset[BS2Tup[M],GenerateCommutingSubset[\[Lambda][[1]],ProjPauliTups]]}]];G];
LocateRandUpdates[M_,\[Lambda]_]:=Module[{G=LocateDetUpdates[M,\[Lambda]]},Do[PrependTo[G[[R2I[s]]],Opacity[0.5]],{s,GenerateACommutingSubset[BS2Tup[M],GenerateCommutingSubset[\[Lambda][[1]],ProjPauliTups]]}];G];
UpdateSteps[M_,\[Lambda]_]:={\[Lambda][[2,R2I[If[Length[M]==3,BS2Tup[M],M]]]],Graphics[{RectList[\[Lambda]],DividingLinesRaw},PlotRange->{{0,1},{0,1}}],Graphics[{LocateMcell[M,\[Lambda]],DividingLinesRaw},PlotRange->{{0,1},{0,1}}],Graphics[{LocateDetUpdates[M,\[Lambda]],DividingLinesRaw},PlotRange->{{0,1},{0,1}}],Graphics[{LocateRandUpdates[M,\[Lambda]],DividingLinesRaw},PlotRange->{{0,1},{0,1}}],Graphics[{RectList[OnticMeasurementUpdate[M,\[Lambda]]],DividingLinesRaw},PlotRange->{{0,1},{0,1}}]};
ConvertPrep[prep_List]:=Module[{PBs},PBs=Table[PauliDict[StringTake[s,-2]],{s,prep}];Do[If[StringLength[prep[[i]]]==3,PBs[[i,3]]=1],{i,Length[prep]}];PBs];
ChoosePrep[prepSpec_]:=Module[{w},w=If[Length[prepSpec]==1,ConstantArray[1,Length[prepSpec[[1]]]]/Length[prepSpec[[1]]],prepSpec[[2]]];RandomChoice[w->prepSpec[[1]]]];
ChooseTrans[transSpec_]:=Module[{w},w=If[Length[transSpec]==1,ConstantArray[1,Length[transSpec[[1]]]]/Length[transSpec[[1]]],transSpec[[2]]];RandomChoice[w->transSpec[[1]]]];
ChooseMmt[mmtSpec_]:=Module[{w},w=If[Length[mmtSpec]==1,ConstantArray[1,Length[mmtSpec[[1]]]]/Length[mmtSpec[[1]]],mmtSpec[[2]]];RandomChoice[w->mmtSpec[[1]]]];
ChooseAdaptiveT[op_,outs_]:=Module[{c=ChooseTrans[op[[1]]]},Do[If[outs[[cond[[1]]]]==cond[[2]],c=ChooseTrans[cond[[3]]]],{cond,op[[2]]}];c];
ChooseAdaptiveM[op_,outs_]:=Module[{c=ChooseMmt[op[[1]]]},Do[If[outs[[cond[[1]]]]==cond[[2]],c=ChooseMmt[cond[[3]]]],{cond,op[[2]]}];c];
ImplementAdaptiveT[op_,outp_]:=Module[{opn,\[Lambda]2},opn=ChooseAdaptiveT[op,outp[[2]]];\[Lambda]2=CliffordDict[opn][Last[outp[[3]]]];{opn,\[Lambda]2}];
ImplementNonAdaptiveT[op_,outp_]:=Module[{opn,\[Lambda]2},opn=ChooseTrans[op];\[Lambda]2=CliffordDict[opn][Last[outp[[3]]]];{opn,\[Lambda]2}];
ImplementAdaptiveM[op_,outp_]:=Module[{m,res,\[Lambda]2},m=ChooseAdaptiveM[op,outp[[2]]];res=MmtOutcome[PauliDict[m],Last[outp[[3]]]];\[Lambda]2=MmtDict[m][Last[outp[[3]]]];{m,res,\[Lambda]2}];
ImplementNonAdaptiveM[op_,outp_]:=Module[{m,res,\[Lambda]2},m=ChooseMmt[op];res=MmtOutcome[PauliDict[m],Last[outp[[3]]]];\[Lambda]2=MmtDict[m][Last[outp[[3]]]];{m,res,\[Lambda]2}];
CliffordDict=Association["II"->GammaId,"IX"->(GammaP[{{0,1},{0,0},0},#1]&),"IY"->(GammaP[{{0,1},{0,1},0},#1]&),"IZ"->(GammaP[{{0,0},{0,1},0},#1]&),"XI"->(GammaP[{{1,0},{0,0},0},#1]&),"XX"->(GammaP[{{1,1},{0,0},0},#1]&),"XY"->(GammaP[{{1,1},{0,1},0},#1]&),"XZ"->(GammaP[{{1,0},{0,1},0},#1]&),"YI"->(GammaP[{{1,0},{1,0},0},#1]&),"YX"->(GammaP[{{1,1},{1,0},0},#1]&),"YY"->(GammaP[{{1,1},{1,1},0},#1]&),"YZ"->(GammaP[{{1,0},{1,1},0},#1]&),"ZI"->(GammaP[{{0,0},{1,0},0},#1]&),"ZX"->(GammaP[{{0,1},{1,0},0},#1]&),"ZY"->(GammaP[{{0,1},{1,1},0},#1]&),"ZZ"->(GammaP[{{0,0},{1,1},0},#1]&),"IH"->(GammaH[2,#1]&),"HI"->(GammaH[1,#1]&),"IS"->(GammaS[2,#1]&),"SI"->(GammaS[1,#1]&),"CNOT12"->(GammaCNOT[1,2,#1]&),"CNOT21"->(GammaCNOT[2,1,#1]&),"CZ"->(GammaCZ[#1]&)];
MmtDict=Association["II"->GammaId,"IX"->(OnticMeasurementUpdate[{{0,1},{0,0},0},#1]&),"IY"->(OnticMeasurementUpdate[{{0,1},{0,1},0},#1]&),"IZ"->(OnticMeasurementUpdate[{{0,0},{0,1},0},#1]&),"XI"->(OnticMeasurementUpdate[{{1,0},{0,0},0},#1]&),"XX"->(OnticMeasurementUpdate[{{1,1},{0,0},0},#1]&),"XY"->(OnticMeasurementUpdate[{{1,1},{0,1},0},#1]&),"XZ"->(OnticMeasurementUpdate[{{1,0},{0,1},0},#1]&),"YI"->(OnticMeasurementUpdate[{{1,0},{1,0},0},#1]&),"YX"->(OnticMeasurementUpdate[{{1,1},{1,0},0},#1]&),"YY"->(OnticMeasurementUpdate[{{1,1},{1,1},0},#1]&),"YZ"->(OnticMeasurementUpdate[{{1,0},{1,1},0},#1]&),"ZI"->(OnticMeasurementUpdate[{{0,0},{1,0},0},#1]&),"ZX"->(OnticMeasurementUpdate[{{0,1},{1,0},0},#1]&),"ZY"->(OnticMeasurementUpdate[{{0,1},{1,1},0},#1]&),"ZZ"->(OnticMeasurementUpdate[{{0,0},{1,1},0},#1]&)];
RunCircuit[cir_]:=Module[{out={{},{},{}},prep,grp},prep=ChoosePrep[cir[[1]]];grp=If[Length[prep]>1,stabgroup@@Take[ConvertPrep[{prep}],2],{{{0,0},{0,0},0}}];out[[1]]={prep};out[[3]]={SampleLambda[grp]};Do[Switch[op[[1]],"T",If[TrueQ[op[[2]]],With[{t=ImplementAdaptiveT[op[[3]],out]},AppendTo[out[[1]],t[[1]]];AppendTo[out[[3]],t[[2]]]],With[{t=ImplementNonAdaptiveT[op[[3]],out]},AppendTo[out[[1]],t[[1]]];AppendTo[out[[3]],t[[2]]]]],"M",If[TrueQ[op[[2]]],With[{m=ImplementAdaptiveM[op[[3]],out]},AppendTo[out[[1]],m[[1]]];AppendTo[out[[2]],m[[2]]];AppendTo[out[[3]],m[[3]]]],With[{m=ImplementNonAdaptiveM[op[[3]],out]},AppendTo[out[[1]],m[[1]]];AppendTo[out[[2]],m[[2]]];AppendTo[out[[3]],m[[3]]]]]],{op,Rest[cir]}];out];
RunCircuitFromInput[cir_,in0_]:=Module[{out=in0},Do[Switch[op[[1]],"T",If[TrueQ[op[[2]]],With[{t=ImplementAdaptiveT[op[[3]],out]},AppendTo[out[[1]],t[[1]]];AppendTo[out[[3]],t[[2]]]],With[{t=ImplementNonAdaptiveT[op[[3]],out]},AppendTo[out[[1]],t[[1]]];AppendTo[out[[3]],t[[2]]]]],"M",If[TrueQ[op[[2]]],With[{m=ImplementAdaptiveM[op[[3]],out]},AppendTo[out[[1]],m[[1]]];AppendTo[out[[2]],m[[2]]];AppendTo[out[[3]],m[[3]]]],With[{m=ImplementNonAdaptiveM[op[[3]],out]},AppendTo[out[[1]],m[[1]]];AppendTo[out[[2]],m[[2]]];AppendTo[out[[3]],m[[3]]]]]],{op,cir}];out];
CircEx={{{"IZ","ZI"}},{"T",False,{{"HI","SI"}}},{"M",False,{{"IX"}}},{"T",True,{{{"II"}},{{1,0,{{"ZX"}}}}}},{"M",False,{{"XZ","YY"},{0.5,0.5}}},{"M",True,{{{"XX"}},{{2,0,{{"IZ"}}},{2,1,{{"ZX"}}}}}}};
out1=RunCircuit[CircEx];
FiniteStatePauli[out1[[3]]]
FiniteStateRaw[out1[[3]]]


DynamicModule[{symbols={"\|01f352","\|01f347","\|01f34b","\|01f349","\|01f34a"},values=Association["\|01f352"->10,"\|01f347"->20,"\|01f34b"->30,"\|01f349"->40,"\|01f34a"->60],reelFinals,spinStart,spinning=False,godMode=False,winnings=0},reelFinals=ConstantArray["",3];spinStart=0;Deploy[Column[{Style["THE SLOTS",34,FontFamily->"Bebas Neue"],Spacer[20],Row[Table[With[{ii=ii},Dynamic[Style[If[spinning&&AbsoluteTime[]-spinStart<1.6,RandomChoice[symbols],reelFinals[[ii]]],FontSize->48],UpdateInterval->0.05]],{ii,1,3}],Spacer[20]],Spacer[20],Row[{Button["Spin",If[!spinning,spinning=True;spinStart=AbsoluteTime[];RunScheduledTask[reelFinals=Table[RandomChoice[symbols],{3}];If[godMode,reelFinals=ConstantArray[First[reelFinals],3];];If[Length[Union[reelFinals]]==1,winnings+=values[reelFinals[[1]]]];spinning=False;,{1.6,1}];],ImageSize->{80,40}],Spacer[20],Button["God's Eye",godMode=!godMode,Appearance->Dynamic[If[godMode,"Pressed","Normal"]],ImageSize->{80,40}]}],Spacer[20],Dynamic[Style["Winnings: "<>ToString[winnings],20]]},Alignment->Center]]]


Module[{shared,semaphore,raceVals,atomicVals,mutexVals,handshakeEvents,reqList,resList,serverResList,racePlot,atomicPlot,mutexPlot,handshakePlot,reqPlot,resPlot,serverPlot,labelStyle,plotLabelStyle},labelStyle=Directive[FontFamily->"Helvetica",FontSize->14];plotLabelStyle=Directive[FontFamily->"Helvetica",FontSize->16,Bold];shared=1;raceVals={shared=10;shared,shared};Print["RaceCondition Output:"];Print["  Writer: shared = 10"];Print["  Reader: read shared = "<>ToString[shared]];racePlot=ListLinePlot[raceVals,Joined->True,PlotMarkers->{"\[FilledCircle]",12},PlotStyle->Thick,Frame->True,FrameLabel->{Style["Step",labelStyle],Style["Shared Value",labelStyle]},PlotLabel->Style["RaceCondition Shared Value",plotLabelStyle],GridLines->Automatic,LabelStyle->labelStyle,ImageSize->400];shared=1;atomicVals={shared=10;shared,shared};Print["\nAtomicSync Output:"];Print["  Writer: shared = 10"];Print["  Reader: read shared = "<>ToString[shared]];atomicPlot=ListLinePlot[atomicVals,Joined->True,PlotMarkers->{"\[EmptyCircle]",12},PlotStyle->{Dashed,Thick},Frame->True,FrameLabel->{Style["Step",labelStyle],Style["Shared Value",labelStyle]},PlotLabel->Style["AtomicSync Shared Value",plotLabelStyle],GridLines->Automatic,LabelStyle->labelStyle,ImageSize->400];shared=1;semaphore=1;P[]:=semaphore--;V[]:=semaphore++;mutexVals={};P[];AppendTo[mutexVals,shared=10];V[];P[];AppendTo[mutexVals,shared];V[];Print["\nWithMutex Output:"];Print["  Writer: shared = 10"];Print["  Reader: read shared = "<>ToString[Last[mutexVals]]];mutexPlot=ListLinePlot[mutexVals,Joined->True,PlotMarkers->{"\[FilledSquare]",12},PlotStyle->{DotDashed,Thick},Frame->True,FrameLabel->{Style["Step",labelStyle],Style["Shared Value",labelStyle]},PlotLabel->Style["WithMutex Shared Value",plotLabelStyle],GridLines->Automatic,LabelStyle->labelStyle,ImageSize->400];handshakeEvents={"SYN","SYN_ACK","ACK","DATA","FIN"};Print["\nHandshake Sequence:"];Print/@{"  Client: sent SYN","  Server: sent SYN_ACK","  Client: sent ACK","  Server: sent DATA","  Client: received data","  Client: sent FIN"};handshakePlot=ListPlot[Transpose[{Range[Length[handshakeEvents]],ConstantArray[1,Length[handshakeEvents]]}],PlotMarkers->{"\[FilledCircle]",14},PlotStyle->Thick,Frame->True,FrameTicks->{Table[{i,handshakeEvents[[i]]},{i,Length[handshakeEvents]}],None},FrameLabel->{Style["Handshake Step",labelStyle],None},PlotLabel->Style["Handshake Sequence",plotLabelStyle],GridLines->None,LabelStyle->labelStyle,ImageSize->400];reqList=Table[RandomInteger[{1,5}],{5}];resList=Table[RandomInteger[{1,5}],{5}];serverResList=Table[RandomInteger[{1,5}],{5}];Print["\nClient/Server Simulation:"];Print["  Client REQ values: "<>ToString[reqList]];Print["  Client RES values: "<>ToString[resList]];Print["  Server RES values: "<>ToString[serverResList]];reqPlot=ListLinePlot[reqList,Joined->True,PlotMarkers->{"\[FilledUpTriangle]",12},PlotStyle->Thick,Frame->True,FrameLabel->{Style["Request #",labelStyle],Style["REQ Value",labelStyle]},PlotLabel->Style["Client REQ Values",plotLabelStyle],GridLines->Automatic,LabelStyle->labelStyle,ImageSize->400];resPlot=ListLinePlot[resList,Joined->True,PlotMarkers->{"\[FilledDownTriangle]",12},PlotStyle->Thick,Frame->True,FrameLabel->{Style["Request #",labelStyle],Style["RES Value",labelStyle]},PlotLabel->Style["Client RES Values",plotLabelStyle],GridLines->Automatic,LabelStyle->labelStyle,ImageSize->400];serverPlot=ListLinePlot[serverResList,Joined->True,PlotMarkers->{"\[FilledDiamond]",12},PlotStyle->Thick,Frame->True,FrameLabel->{Style["Response #",labelStyle],Style["RES Value",labelStyle]},PlotLabel->Style["Server RES Values",plotLabelStyle],GridLines->Automatic,LabelStyle->labelStyle,ImageSize->400];Print["\nStyled Visualizations:"];Column[{racePlot,atomicPlot,mutexPlot,handshakePlot,reqPlot,resPlot,serverPlot},Spacings->2]]


getCurrentPrice[ticker_String]:=FinancialData[ticker];
aaplLastPrice=getCurrentPrice["AAPL"];
Print["Current Apple Inc. (AAPL) Price: ",aaplLastPrice];
getHistory[ticker_String,start_,end_]:=FinancialData[ticker,{start,end}];
ibmHistory=getHistory["IBM",{2024,1,1},{2024,6,30}];
DateListPlot[ibmHistory,PlotLabel->"IBM Price (2024)",AspectRatio->1/3]
getDetailedHistory[ticker_String,property_String,start_,end_]:=FinancialData[ticker,property,{start,end}];
spxVolume=getDetailedHistory["^SPX","Volume","2025-06-01","2025-06-30"];
DateListPlot[spxVolume,PlotLabel->"S&P 500 Volume (June 2025)",Joined->False,Filling->Axis]
googPrice=getCurrentPrice["GOOG"];
Print["Current Alphabet Inc. (GOOG) Price: ",googPrice];
msftHistory=getHistory["MSFT","2020-01-01",Today];
DateListPlot[msftHistory["Path"],PlotTheme->"Web",PlotLabel->"MSFT Closing Price Since 2020",ImageSize->Large]


ClearAll[eventLog,protocolThroughput,throughputTimeline,latencyRecords,uniqueIPs,uniqueMACs,protocolConnections,totalPacketCount,logFile,styleHeading,currentTimestamp,displayPacketDetails,saveToLog,recordPacketInfo,handlePacketData,computeThroughput,computeLatency,showStatistics,generateDashboard,iface,proc];
eventLog=Association[];
protocolThroughput=Association[];
throughputTimeline=Association[];
latencyRecords=Association["TCP"->{},"UDP"->{},"IP"->{}];
uniqueIPs={};
uniqueMACs={};
protocolConnections=Association[];
totalPacketCount=0;
logFile="network_events.log";
SetOptions[EvaluationNotebook[],DefaultFont->"Helvetica",DefaultFontSize->14,CellMargins->25,Background->RGBColor[0.98,0.98,0.98]];
styleHeading[text_]:=Style[text,18,Bold,FontFamily->"Arial",FontColor->RGBColor[0.1,0.2,0.5]];
currentTimestamp[]:=AbsoluteTime[];
displayPacketDetails[protocol_,src_,dest_,size_]:=Print[Style["Packet: ",Italic,FontSize->12],Row[{Style[protocol,Bold,FontColor->RGBColor[0.5,0,0.7]],": ",src," \[RightArrow] ",dest,", ",size," bytes"}]];
saveToLog[protocol_,src_,dest_,size_,timestamp_]:=Module[{entry},entry=DateString[timestamp,{"Year","-","Month","-","Day"," ","Hour",":","Minute",":","Second"}]<>" | "<>protocol<>" | Src: "<>src<>", Dst: "<>dest<>", Size: "<>ToString[size]<>" bytes\n";entry>>>logFile;displayPacketDetails[protocol,src,dest,size];];
recordPacketInfo[protocol_,src_,dest_,size_,timestamp_]:=(totalPacketCount++;protocolThroughput[protocol]=Lookup[protocolThroughput,protocol,0]+size;eventLog[protocol]=Append[Lookup[eventLog,protocol,{}],size];protocolConnections[protocol]=Lookup[protocolConnections,protocol,0]+1;If[protocol==="Ethernet",uniqueMACs=uniqueMACs\[Union]{src,dest},uniqueIPs=uniqueIPs\[Union]{src,dest}];If[MemberQ[{"TCP","UDP","IP"},protocol],latencyRecords[protocol]=Append[latencyRecords[protocol],timestamp]];);
handlePacketData[protocol_,src_,dest_,size_]:=Module[{ts},ts=currentTimestamp[];saveToLog[protocol,src,dest,size,ts];recordPacketInfo[protocol,src,dest,size,ts];];
computeThroughput[interval_:10]:=Module[{bps},Print[styleHeading["--- Throughput (bps) ---"]];If[interval<=0,Return[]];KeyValueMap[(If[Lookup[protocolThroughput,#1,0]>0,bps=(#2 8)/interval;throughputTimeline[#1]=Append[Lookup[throughputTimeline,#1,{}],bps];Print[#1<>": ",NumberForm[bps,{7,0}]," bps"];];protocolThroughput[#1]=0;)&,protocolThroughput];Print[StringRepeat["-",25]];];
computeLatency[]:=Module[{avg=Association[],diffs},Print[styleHeading["--- Latency (ms) ---"]];Do[If[Length[latencyRecords[prot]]>1,diffs=Differences[latencyRecords[prot]] 1000;avg[prot]=Mean[diffs],avg[prot]=0];Print["Avg ",prot,": ",NumberForm[avg[prot],{6,2}]," ms"];,{prot,{"TCP","UDP","IP"}}];avg];
showStatistics[]:=Module[{},Print[styleHeading["--- Network Monitoring Summary ---"]];KeyValueMap[(Print[#1<>": ",Length[#2]," pkts; Avg Size: ",If[Length[#2]>0,NumberForm[Mean[#2],{6,2}],0]," bytes"];)&,eventLog];Print["Unique IPs: ",Length[uniqueIPs],", Unique MACs: ",Length[uniqueMACs]];Print["Total Packets: ",totalPacketCount];Print[StringRepeat["-",35]];];
generateDashboard[]:=Module[{tpPlot,latHist,barStats,pieProtocol,tcpLat,udpLat,ipLat,counts},tpPlot=If[Length[Values[throughputTimeline]]>=2,ListLinePlot[Values[throughputTimeline],PlotTheme->"Business",PlotLegends->Placed[Keys[throughputTimeline],Above],AxesLabel->{"Interval","bps"},PlotLabel->Style["Throughput Over Time",16,Bold],ImageSize->300],Graphics[Text["No throughput data"],ImageSize->300]];tcpLat=Differences[latencyRecords["TCP"]] 1000;udpLat=Differences[latencyRecords["UDP"]] 1000;ipLat=Differences[latencyRecords["IP"]] 1000;latHist=If[Length[tcpLat]+Length[udpLat]+Length[ipLat]>0,Histogram[{tcpLat,udpLat,ipLat},15,ChartLegends->{"TCP","UDP","IP"},PlotTheme->"Business",AxesLabel->{"Latency (ms)","Frequency"},PlotLabel->Style["Latency Distribution",16,Bold],ImageSize->300],Graphics[Text["No latency data"],ImageSize->300]];counts=Join[Values[protocolConnections],{Length[uniqueIPs],Length[uniqueMACs]}];barStats=BarChart[counts,ChartLabels->Placed[Join[Keys[protocolConnections],{"IPs","MACs"}],Below],PlotTheme->"Business",AxesLabel->{"Category","Count"},PlotLabel->Style["Protocol & Address Stats",16,Bold],LabelingFunction->Above,ImageSize->300];pieProtocol=If[Total[Values[protocolConnections]]>0,PieChart[Values[protocolConnections],ChartLabels->Placed[Keys[protocolConnections],"RadialCallout"],PlotTheme->"Business",PlotLabel->Style["Protocol Usage Breakdown",16,Bold],ImageSize->300],Graphics[Text["No protocol data"],ImageSize->300]];Framed[Grid[{{Style["Network Monitoring Dashboard",20,Bold]},{tpPlot,latHist},{barStats,pieProtocol}},Spacings->{3,3}],Background->White,FrameStyle->Directive[GrayLevel[0.7],Thickness[0.005]],RoundingRadius->8,ImageSize->650]];
iface="en0";
proc=StartProcess[{"tcpdump","-l","-n","-q","-i",iface}];
Print[styleHeading["Capturing on "<>iface<>" \[Ellipsis] (Shift+Enter to stop)"]];
While[True,line=ReadLine[proc];If[line===EndOfFile,Break[]];tcpMatch=StringCases[line,RegularExpression["IP\\s+([^\\.]+)\\.(\\d+)\\s*>\\s*([^\\.]+)\\.(\\d+):.*length\\s*(\\d+)"]:>{"Src"->"$1:$2","Dst"->"$3:$4","Len"->"$5"}];If[tcpMatch=!={},p=First[tcpMatch];handlePacketData["TCP",p["Src"],p["Dst"],ToExpression[p["Len"]]];Continue[];];udpMatch=StringCases[line,RegularExpression["UDP\\s+([^\\.]+)\\.(\\d+)\\s*>\\s*([^\\.]+)\\.(\\d+):.*length\\s*(\\d+)"]:>{"Src"->"$1:$2","Dst"->"$3:$4","Len"->"$5"}];If[udpMatch=!={},p=First[udpMatch];handlePacketData["UDP",p["Src"],p["Dst"],ToExpression[p["Len"]]];Continue[];];ipMatch=StringCases[line,RegularExpression["IP\\s+(\\S+)\\s*>\\s*(\\S+):.*length\\s*(\\d+)"]:>{"Src"->"$1","Dst"->"$2","Len"->"$3"}];If[ipMatch=!={},p=First[ipMatch];handlePacketData["IP",p["Src"],p["Dst"],ToExpression[p["Len"]]];Continue[];];ethMatch=StringCases[line,RegularExpression["length\\s*(\\d+)"]:>{"Len"->"$1"}];If[ethMatch=!={},handlePacketData["Ethernet","<eth>","<eth>",ToExpression[First[ethMatch]["Len"]]];];];
computeThroughput[10];
computeLatency[];
showStatistics[];
If[totalPacketCount==0,Do[With[{t=AbsoluteTime[]+i 5,pr=RandomChoice[{"TCP","UDP","IP","Ethernet"}],sz=RandomInteger[{64,1500}],src="10.0.0."<>ToString[RandomInteger[{1,254}]]<>":80",dst="10.0.0."<>ToString[RandomInteger[{1,254}]]<>":443"},recordPacketInfo[pr,src,dst,sz,t]],{i,1,50}];computeThroughput[5];];
dashboard=generateDashboard[];
KillProcess[proc];
dashboard


ClearAll[cons,cdrAndFree];
cons[element_,l_List]:=Prepend[l,element];
cdrAndFree[l_List]:=Rest[l];
ClearAll[queueCreate,queueEmpty,queueEnq,queueDeq];
queueCreate[]:={};
queueEmpty[q_List]:=q==={};
queueEnq[q_List,elem_]:=Append[q,elem];
queueDeq[q_List]:={First[q],Rest[q]};
ClearAll[Packet];
Packet[id_Integer,type_String]:=Association["id"->id,"type"->type];
ClearAll[processPacket];
processPacket[pkt_]:=Module[{id=pkt["id"],t=pkt["type"],msg},msg=Switch[t,"ARP","\:21bb ARP request \[RightArrow] ARP reply","ICMP","\:27f3 ICMP echo \[RightArrow] ICMP reply","DATA","\[RightArrow] DATA packet forwarded",_,"\[CenterEllipsis] Unknown packet"];Association["PacketID"->id,"Type"->t,"Result"->msg]];
ClearAll[generateDemoPackets];
generateDemoPackets[n_Integer]:=Module[{types={"ARP","ICMP","DATA"}},Table[Packet[i,RandomChoice[types]],{i,1,n}]];
ClearAll[runSimulation];
runSimulation[packets_List]:=processPacket/@packets;
ClearAll[simulateAndVisualize,createTextBarChart];
createTextBarChart[counts_Association]:=Module[{maxLabelLength,paddedLabels,bars},maxLabelLength=Max[(StringLength[#1]&)/@Keys[counts]];paddedLabels=(StringPadRight[#1,maxLabelLength]&)/@Keys[counts];bars=(StringJoin[Table["\[FilledSquare]",{#1}]]&)/@Values[counts];TableForm[Transpose[{paddedLabels,bars}]]];
simulateAndVisualize[n_Integer]:=Module[{packets,results,counts},packets=generateDemoPackets[n];results=runSimulation[packets];counts=Counts[results[[All,"Result"]]];Print[Style["Simulation Results: Conventional Router",Bold]];Print[TableForm[Values[results],TableHeadings->{None,Keys[First[results]]}]];Print["\n",Style["Result Distribution",Bold]];Print[createTextBarChart[counts]];];
simulateAndVisualize[15]


timings={{"x^3 Erf[x]^2",0.000016},{"(x^7 - 24 x^4 - 4 x^2 + 8 x - 8)/(x^8 + 6 x^6 + 12 x^4 + 8 x^2)",0.000017},{"(-4 x^2 - 4 x^3 - x^4)/((-1 + x^2)(1 + x + x^2)^2)",0.000009},{"x^3/(1 + x)",0.000003},{"(x^4 - 3 x^2 + 6)/(x^6 - 5 x^4 + 5 x^2 + 4)",0.000006},{"(-1 - E^x + E^x x Log[x])/((1 + E^x)^2 x)",0.000012}};
Dataset[(AssociationThread[{"Expression","Time (s)"},#1]&)/@timings,AppearanceRules->Association["HeaderBackground"->LightGray,"RowAlternation"->{White,LightYellow}]]
Grid[Prepend[timings,{"Expression","Time (s)"}],Frame->All,Background->{None,{LightGray,{White}}},Alignment->{Left,Center},ItemStyle->{FontFamily->"Courier",FontSize->12}]
BarChart[timings[[All,2]],ChartLabels->Placed[(Rotate[#1,45 \[Degree]]&)/@timings[[All,1]],Below],ChartStyle->RGBColor[0.2,0.6,0.8],ImageSize->Large,PlotTheme->"Detailed",AxesLabel->{None,"Time (s)"},PlotLabel->Style["Poor Man\[CloseCurlyQuote]s Integrator: Example Timings",14,Bold],LabelStyle->Directive[FontFamily->"Arial",FontSize->12],GridLines->{None,Automatic},GridLinesStyle->Dashed]


ClearAll[initState,receiverStep,buildFrameBits,buildTestBits,runSimulation,simStates,valueSeq];
initState[]:=Association["value"->0,"desMAC"->0,"srcMAC"->0,"ET"->0,"Payload"->0,"CRC32"->FromDigits["100000100110000010001110110110111",2],"size"->0,"out"->0,"done"->False];
receiverStep[state_,inBit_]:=Module[{value,desMAC,srcMAC,ET,Payload,CRC32,size,out,done,newValue,newDesMAC,newSrcMAC,newET,newPayload,newSize,newOut,newDone},{value,desMAC,srcMAC,ET,Payload,CRC32,size,out,done}=Lookup[state,{"value","desMAC","srcMAC","ET","Payload","CRC32","size","out","done"}];newValue=value;newDesMAC=desMAC;newSrcMAC=srcMAC;newET=ET;newPayload=Payload;newSize=size;newOut=out;newDone=done;If[value==0,newDesMAC=0;newSrcMAC=0;newET=0;newPayload=0;newSize=0;newOut=0;newDone=False;];Which[0<=value<=61,If[inBit===Mod[value+1,2],newValue=value+1,newValue=0],62<=value<=69,If[inBit===BitGet[FromDigits["11010101",2],value-62],newValue=value+1,newValue=0],70<=value<=117,newDesMAC=BitShiftLeft[desMAC,1]+inBit;newValue=value+1,118<=value<=165,newSrcMAC=BitShiftLeft[srcMAC,1]+inBit;newValue=value+1,166<=value<=181,newET=BitShiftLeft[ET,1]+inBit;If[value==181,newET=BitShiftLeft[newET,3]];newValue=value+1,182<=value<=181+ET+32,newPayload=BitShiftLeft[Payload,1]+inBit;If[value==181+ET,newOut=newPayload];If[value==181+ET+32,Module[{temp=newPayload},Do[If[BitGet[temp,k]==1,temp=Fold[BitXor[#1,BitShiftLeft[CRC32,j]]&,temp,Range[0,32]]],{k,ET+31,33,-1}];If[temp==0,newDone=True;newSize=ET/8,newDone=False];];newValue=0,newValue=value+1],True,newValue=value];Association["value"->newValue,"desMAC"->newDesMAC,"srcMAC"->newSrcMAC,"ET"->newET,"Payload"->newPayload,"CRC32"->CRC32,"size"->newSize,"out"->newOut,"done"->newDone]];
buildFrameBits[wrongFcs_:False]:=Module[{bits,fcs},bits={};Do[bits=Join[bits,{1,0}],{31}];bits=Join[bits,ConstantArray[1,2],ConstantArray[0,48],ConstantArray[1,48]];bits=Join[bits,ConstantArray[0,14],ConstantArray[1,2]];bits=Join[bits,Riffle[ConstantArray[{1,0},16],{}]];fcs=Flatten[Table[{0,1},{16}]];If[wrongFcs,fcs=1-fcs];Join[bits,fcs]];
buildTestBits[]:=Module[{f1,f2},f1=buildFrameBits[False];f2=buildFrameBits[True];Join[f1,ConstantArray[0,5],f2]];
runSimulation[]:=Module[{bits,states},bits=buildTestBits[];states=FoldList[receiverStep,initState[],bits];states];
simStates=runSimulation[];
valueSeq=simStates[[All,"value"]][[1;;80]];
TableForm[Transpose[{Range[Length[valueSeq]],buildTestBits[][[1;;80]],valueSeq}],TableHeadings->{None,{"Idx","inBit","value"}}]
Count[simStates,#1["done"]&]


topology=Association[1->{2,3,5},2->{1,4,6},3->{1,4,7},4->{2,3,5,8},5->{1,4,9},6->{2,7,10},7->{3,6,8},8->{4,7,9,10},9->{5,8,10},10->{6,8,9}];
startDiscovery[1,8,5001];
startDiscovery[4,10,7001];
Do[simulateStep[],{100}];
edges=DeleteDuplicates[Sort/@Flatten[Table[{i,j},{i,Keys[topology]},{j,topology[i]}],1]];
g=Graph[UndirectedEdge@@@edges,VertexLabels->Placed["Name",Center],GraphLayout->"SpringEmbedding",ImagePadding->20,VertexStyle->White,EdgeStyle->LightGray,VertexSize->Medium];
getRoute[src_,dest_]:=Module[{route={src},cur=src},While[cur=!=dest,cur=nodes[cur,"RoutingTable"][dest][[1]];AppendTo[route,cur];];route];
route1=getRoute[1,8];
route2=getRoute[4,10];
hg=HighlightGraph[g,{PathGraph[UndirectedEdge@@@Partition[route1,2,1]],PathGraph[UndirectedEdge@@@Partition[route2,2,1]]},{(EdgeStyle->{UndirectedEdge@@#1->{Thick,Red}}&)/@Partition[route1,2,1],(EdgeStyle->{UndirectedEdge@@#1->{Thick,Blue}}&)/@Partition[route2,2,1]}];
hg


ClearAll["Global`*"];
f[p_,q_,r_,k_]:=FractionalPart[Mean[{p,q,r}]+k];
Manipulate[Module[{initArray,evolution},initArray=N[Table[value[x],{x,-Floor[steps/2],Floor[steps/2],1}]];evolution=CellularAutomaton[{Function[{nb},Mod[Mean[nb]+k,1]],{},1},initArray,steps];view[evolution,Frame->True,FrameTicks->None,PlotRange->All,AspectRatio->1,ImageSize->{800,400},ColorFunction->"Rainbow",ColorFunctionScaling->True]],{{steps,500,"Steps"},10,500,1},{{k,0.0081,"k"},0,1,0.0001,Appearance->"Labeled"},{{view,ArrayPlot,"View"},{ArrayPlot->"Cell Gray Level",ListContourPlot->"Contour",ListDensityPlot->"Density"}},{{value,If[#1==0,1,0]&,"Initial Condition"},{(If[#1==0,1,0]&)->"One Cell",(.1+Sinc[#1]/2&)->"Sinc",(1/2 (1+Sin[#1])&)->"Sine",(RandomInteger[1]&)->"Random",(UnitStep[#1]&)->"Unit Step"}},ControlPlacement->Left]


ClearAll["Global`*"];
SeedRandom[1234];
nSamples=200;
nFeatures=4;
ABMInputsV2=RandomReal[{0,1},{nSamples,nFeatures}];
ABMOutputsV2=(Total[#1]+RandomReal[{-0.1,0.1}]&)/@ABMInputsV2;
ABMAssocV2=AssociationThread[ABMInputsV2->ABMOutputsV2];
ABMNormalV2=Normal[ABMAssocV2];
ABMNormalRandom=RandomSample[ABMNormalV2];
{fullTrain,testSet}=TakeDrop[ABMNormalRandom,Round[nSamples 0.8]];
{finalTrain,finalDev}=TakeDrop[fullTrain,Round[Length[fullTrain] 0.8]];
finalTest=testSet;
Print["Training examples: ",Length[finalTrain]];
Print["Development examples: ",Length[finalDev]];
Print["Test examples: ",Length[finalTest]];
models=Association["RandomForest"->Predict[finalTrain,Method->"RandomForest"],"GradientBoostedTrees"->Predict[finalTrain,Method->"GradientBoostedTrees"],"NeuralNetwork"->Predict[finalTrain,Method->{"NeuralNetwork","NetworkDepth"->3,"NetworkType"->"FullyConnected","L2Regularization"->0.05,MaxTrainingRounds->4000}],"GaussianProcess"->Predict[finalTrain,Method->"GaussianProcess"],"DecisionTree"->Predict[finalTrain,Method->"DecisionTree"],"NearestNeighbors"->Predict[finalTrain,Method->"NearestNeighbors"],"LinearRegression"->Predict[finalTrain,Method->"LinearRegression"]];
Do[modelName=key;model=models[key];pm=PredictorMeasurements[model,finalTest];Print["--- ",modelName," ---"];Print["MeanSquare: ",pm["MeanSquare"]];Print[pm["ResidualPlot"]],{key,Keys[models]}];
netSimple=NetChain[{BatchNormalizationLayer[],Tanh,20,20,BatchNormalizationLayer[],Tanh,1}];
trainedNet=NetTrain[netSimple,finalTrain,All,ValidationSet->finalTest,MaxTrainingRounds->2000,Method->{"ADAM","LearningRate"->0.001,"L2Regularization"->0.1}];
Print["Net Training Completed."];
trainedNet["LossEvolutionPlot"]


places={"p1","p2","p3"};
transitions={"t1","t2"};
arcs={{"p1","t1"},{"t1","p2"},{"p2","t2"},{"t2","p3"}};
initialTokens=Association["p1"->1,"p2"->0,"p3"->0];
vertices=Join[places,transitions];
edges=DirectedEdge@@@arcs;
vertexStyles=Join[Thread[places->Lighter[Green,0.3]],Thread[transitions->Lighter[Orange,0.3]]];
vertexShapes=Join[Thread[places->"Circle"],Thread[transitions->"Square"]];
vertexSizes=Thread[vertices->0.4];
petriNetGraph=Graph[vertices,edges,VertexStyle->vertexStyles,VertexShapeFunction->vertexShapes,VertexSize->vertexSizes,EdgeStyle->Directive[Thick,Darker[Gray,0.3]],VertexLabels->Placed["Name",Center],Background->Lighter[Gray,0.9],ImageSize->Medium];
petriNetGraph
drawPetriNetWithTokens[marking_Association]:=Module[{g,coords,tokenGraphics},g=Graph[vertices,edges,VertexStyle->vertexStyles,VertexShapeFunction->vertexShapes,VertexSize->vertexSizes,EdgeStyle->Directive[Thick,Darker[Gray,0.3]],VertexLabels->Placed["Name",Center],Background->Lighter[Gray,0.97],ImageSize->Medium,GraphLayout->"SpringElectricalEmbedding"];coords=AssociationThread[VertexList[g],GraphEmbedding[g]];tokenGraphics=Flatten[Table[With[{n=marking[p],pos=coords[p]},Table[{Black,Disk[pos,0.07-0.025 i]},{i,0,n-1}]],{p,places}]];Show[g,Epilog->tokenGraphics]]
drawPetriNetWithTokens[initialTokens]
fireTransitions[marking_]:=Module[{nextStates={}},If[marking["p1"]>=1,AppendTo[nextStates,Association["p1"->marking["p1"]-1,"p2"->marking["p2"]+1,"p3"->marking["p3"]]]];If[marking["p2"]>=1,AppendTo[nextStates,Association["p1"->marking["p1"],"p2"->marking["p2"]-1,"p3"->marking["p3"]+1]]];nextStates]
generateBranchialGraph[init_,maxSteps_:4]:=Module[{states=Association[],edges={},queue,nodeKey,children,seen=Association[]},nodeKey[state_]:=ToString[Normal[state]];states[nodeKey[init]]=init;queue={{init,0}};seen[nodeKey[init]]=True;While[queue=!={},{state,depth}=First[queue];queue=Rest[queue];If[depth>=maxSteps,Continue[]];children=fireTransitions[state];Do[k=nodeKey[child];If[!KeyExistsQ[seen,k],states[k]=child;seen[k]=True;AppendTo[queue,{child,depth+1}]];AppendTo[edges,nodeKey[state]->k],{child,children}];];Graph[Keys[states],edges,VertexLabels->v_:>Placed[Style[v,Small],Center],VertexStyle->LightBlue,EdgeStyle->Thin,GraphLayout->"RadialEmbedding",VertexSize->0.3,ImageSize->Large]]
generateBranchialGraph[initialTokens,4]
highlightFiring[marking_]:=drawPetriNetWithTokens[marking];
stateSeq=FoldList[Function[{s,tr},Which[tr==="t1"&&s["p1"]>=1,Association["p1"->s["p1"]-1,"p2"->s["p2"]+1,"p3"->s["p3"]],tr==="t2"&&s["p2"]>=1,Association["p1"->s["p1"],"p2"->s["p2"]-1,"p3"->s["p3"]+1],True,s]],initialTokens,{"t1","t2","t2"}];
Row[(highlightFiring[#1]&)/@stateSeq,Spacer[10]]


Column[{Style["1. Packet Slicing Visualization (PIF Guarantees 1st Slice Perfect)",Bold,14,Blue],Module[{packetLength=64,sliceLength=8,slices,faultPattern,sliceColors},slices=packetLength/sliceLength;SeedRandom[123];faultPattern=Join[{0},RandomInteger[{0,1},slices-1]];sliceColors=(If[#1==0,Green,Red]&)/@faultPattern;Graphics[Table[{EdgeForm[Black],FaceForm[sliceColors[[i]]],Rectangle[{i,0},{i+1,1}],Text[Style[ToString[i],White,12,Bold],{i+0.5,0.5}]},{i,1,slices}],Axes->None,ImageSize->480,PlotRange->{{0,slices},{0,1}},AspectRatio->0.16]],Spacer[20],Style["2. All Four Link Reliability States",Bold,14,Blue],Grid[Partition[Table[Module[{state=s,colorA,colorB,labelA,labelB},Switch[state,"11",colorA=colorB=Green;labelA="A\[RightArrow]B";labelB="B\[RightArrow]A","10",colorA=Green;colorB=Red;labelA="A\[RightArrow]B";labelB="B\[RightArrow]A","01",colorA=Red;colorB=Green;labelA="A\[RightArrow]B";labelB="B\[RightArrow]A","00",colorA=colorB=Red;labelA="A\[RightArrow]B";labelB="B\[RightArrow]A"];Column[{Style[state,Bold,14],Graphics[{Arrowheads[0.12],{colorA,Arrow[{{0,0},{1,0}}]},Text[labelA,{0.5,0.1},{0,0}],{colorB,Arrow[{{1,0.2},{0,0.2}}]},Text[labelB,{0.5,0.3},{0,0}]},PlotRange->{{-0.2,1.2},{-0.1,0.4}},ImageSize->120,Axes->False,Background->Lighter[Gray,0.95]]}]],{s,{"11","10","01","00"}}],2],Spacings->{2,2}],Spacer[20],Style["3. L(n) and FailureModes(n) Formulas and Enumeration Table",Bold,14,Blue],Module[{L,FailureModes,table},L[n_]:=If[n<=8,Binomial[n,2],4 n];FailureModes[n_]:=4^L[n]-1;table=Table[{n,L[n],FailureModes[n]},{n,2,20}];Grid[Prepend[table,{"n","L(n)","FailureModes(n)"}],Frame->All,Alignment->Center]],Spacer[20],Style["4. Log-Plot: Explosion of Failure Modes as n Increases",Bold,14,Blue],Module[{L,FailureModes,failureData},L[n_]:=If[n<=8,Binomial[n,2],4 n];FailureModes[n_]:=4^L[n]-1;failureData=Table[{n,FailureModes[n]},{n,2,20}];ListLogPlot[failureData,Joined->True,PlotMarkers->Automatic,Mesh->All,AxesLabel->{"n","Failure Modes (log scale)"},PlotLabel->Style["Explosion of Failure Modes in Octavalent Mesh",Bold,14],ImageSize->420]],Spacer[20],Style["5. Interactive: n, L(n), and FailureModes(n) Explorer",Bold,14,Blue],Module[{L,FailureModes},L[n_]:=If[n<=8,Binomial[n,2],4 n];FailureModes[n_]:=4^L[n]-1;Manipulate[Column[{Row[{"n = ",n,",   L(n) = ",L[n],",   FailureModes(n) = ",FailureModes[n]}],ListLogPlot[Table[{k,FailureModes[k]},{k,2,n}],Joined->True,Mesh->All,AxesLabel->{"n","Failure Modes (log)"},PlotLabel->"Combinatorial Failure Modes for Ethernet Link States"]}],{{n,10,"Number of Nodes"},2,20,1,Appearance->"Labeled"}]],Spacer[20],Style["6. Epistricted Registers (EPI): State Restriction Visualization",Bold,14,Blue],Module[{allStates,epistrictedStates},allStates=Tuples[{0,1},2];epistrictedStates={{0,0},{1,1}};GraphicsGrid[{{Style["All Classical States",Bold,12],Style["Epistricted States",Bold,12]},{Graphics[Table[{If[MemberQ[epistrictedStates,state],Green,Blue],Disk[state,0.15],Text[state,state+{0,-0.25}]},{state,allStates}],Axes->False,PlotRange->{{-0.5,1.5},{-0.5,1.5}},ImageSize->200],Graphics[Table[{If[MemberQ[epistrictedStates,state],Green,LightGray],Disk[state,0.15],Text[state,state+{0,-0.25}]},{state,allStates}],Axes->False,PlotRange->{{-0.5,1.5},{-0.5,1.5}},ImageSize->200]}}]]}]


L[n_]:=If[n<=9,Binomial[n,2],4 n]
LinkStates[n_]:=4^L[n]
FailureModes[n_]:=LinkStates[n]-1
table=Table[{n,L[n],LinkStates[n],FailureModes[n]},{n,2,20}];
tableHeadings={"Nodes n","Links L(n)","Total Configs","Failure Modes"};
Print["--- Fault Model Table ---"];
Grid[Prepend[table,tableHeadings],Frame->All,Alignment->Center,Background->{None,{{Lighter[Gray,0.95]},None}}]
Print["--- Failure Modes Growth (Log Plot) ---"];
ListLogPlot[Table[{n,FailureModes[n]},{n,2,20}],Joined->True,Mesh->All,MeshStyle->Red,PlotMarkers->Automatic,PlotLabel->"Number of Failure Modes vs. Nodes (n)",Frame->True,FrameLabel->{"Nodes n","Failure Modes (log scale)"},GridLines->Automatic,ImageSize->Large]
Print["--- Example Link State Enumerations for n = 3 ---"];
nSmall=3;
linksSmall=Subsets[Range[nSmall],{2}];
statesSmall=Tuples[{"00","01","10","11"},Length[linksSmall]];
Grid[Prepend[Table[Row[Table[linksSmall[[k]]->statesSmall[[i,k]],{k,Length[linksSmall]}],"  "],{i,1,8}],"Links and States (First 8 configs)"],Frame->All]
Print["--- Visualization: Link State Colors in n=4 Graph ---"];
nVis=4;
nodesVis=Range[nVis];
linksVis=Subsets[nodesVis,{2}];
SeedRandom[42];
randStates=RandomChoice[{"00","01","10","11"},Length[linksVis]];
stateColor["11"]=Green;
stateColor["10"]=Blue;
stateColor["01"]=Orange;
stateColor["00"]=Red;
Graph[nodesVis,Table[Style[UndirectedEdge@@linksVis[[k]],Thick,stateColor[randStates[[k]]]],{k,Length[linksVis]}],VertexLabels->"Name",EdgeLabels->Table[UndirectedEdge@@linksVis[[k]]->randStates[[k]],{k,Length[linksVis]}],ImageSize->Medium,PlotLabel->"Random Fault Configuration (edge color = link state)"]
Print["--- PIF Model: Echo of First 8 Bytes ---"];
EchoSlice[packet_]:=Take[packet,8]
packet=RandomInteger[{0,255},64];
firstSlice=EchoSlice[packet];
Grid[{{"Full 64-byte packet (Tx)",packet},{"First 8 bytes echoed back (Rx)",firstSlice}},Frame->All,ItemStyle->{Directive[Bold,14]},Background->{None,{{LightBlue,None}}}]
Print["--- EPI Model: Epistricted Register States (Spekkens-like) ---"];
allStates=Tuples[{0,1},2];
epistrictedStates=Select[allStates,Total[#1]==1&];
Grid[{{"All possible states",allStates},{"Epistricted states",epistrictedStates}},Frame->All,ItemStyle->{Directive[Bold,14]},Background->{None,{{LightYellow,None}}}]


Module[{nCells=20,cells,coords,portsPerCell,maxPorts=12,edges,groundplane,portAngles,portLabels,portAssignment,spanningTrees,hopCounts,treeEdges,failedLink,rerouteTree,rerouteEdges,timeReversalStates,vizOpts,hexPortLabels=ToString/@Range[0,11]},SeedRandom[2025];cells=Range[nCells];coords=AssociationThread[cells->RandomReal[{0,10},{nCells,2}]];portsPerCell=RandomInteger[{5,9},nCells];edges=Reap[Module[{currentEdges={}},Do[Module[{cell=cells[[i]],nPorts=portsPerCell[[i]],candidates,added=0},candidates=SortBy[DeleteCases[cells,cell],EuclideanDistance[coords[cell],coords[#1]]&];Do[Module[{edge=cell\[UndirectedEdge]candidates[[j]]},If[added<nPorts&&!MemberQ[currentEdges,edge]&&!MemberQ[currentEdges,candidates[[j]]\[UndirectedEdge]cell]&&Count[currentEdges,_?(MemberQ[{cell,candidates[[j]]},#1[[1]]]&&MemberQ[{cell,candidates[[j]]},#1[[2]]]&)]<portsPerCell[[cell]]&&Count[currentEdges,_?(MemberQ[{cell,candidates[[j]]},#1[[1]]]&&MemberQ[{cell,candidates[[j]]},#1[[2]]]&)]<portsPerCell[[candidates[[j]]]],Sow[edge];AppendTo[currentEdges,edge];added++;]],{j,Length[candidates]}];],{i,nCells}]]][[2,1]];groundplane=Graph[cells,edges,VertexCoordinates->coords,VertexLabels->Placed["Name",Center],GraphStyle->"NameLabeled",ImageSize->600];portAssignment=Association[];Do[Module[{nbrs,assignedPorts=Range[portsPerCell[[cell]]],assignment=Association[]},nbrs=DeleteCases[VertexList[NeighborhoodGraph[groundplane,cell]],cell];Do[If[Length[assignedPorts]>0&&(MemberQ[edges,cell\[UndirectedEdge]nbr]||MemberQ[edges,nbr\[UndirectedEdge]cell]),assignment[nbr]=First[assignedPorts];assignedPorts=Rest[assignedPorts];],{nbr,nbrs}];portAssignment[cell]=assignment;],{cell,cells}];spanningTrees=Association[];hopCounts=Association[];treeEdges=Association[];Do[Module[{tree=FindSpanningTree[groundplane,RootVertex->root]},spanningTrees[root]=tree;hopCounts[root]=AssociationThread[VertexList[tree],(GraphDistance[tree,root,#1]&)/@VertexList[tree]];treeEdges[root]=EdgeList[tree];],{root,cells}];failedLink=RandomChoice[edges];Module[{root=First[failedLink],reducedEdges,reducedGraph},reducedEdges=DeleteCases[edges,failedLink|UndirectedEdge@@Reverse[List@@failedLink]];reducedGraph=Graph[cells,reducedEdges];rerouteTree=Quiet[FindSpanningTree[reducedGraph,RootVertex->root]];rerouteEdges=EdgeList[rerouteTree];hopCounts[root]=AssociationThread[VertexList[rerouteTree],(GraphDistance[rerouteTree,root,#1]&)/@VertexList[rerouteTree]];spanningTrees[root]=rerouteTree;];timeReversalStates=Association["BeforeFailure"->groundplane,"AfterFailure"->Graph[cells,DeleteCases[edges,failedLink]]];vizOpts={VertexSize->Medium,VertexLabels->Placed["Name",Center],PlotRangePadding->Scaled[0.1],ImageSize->Large,EdgeStyle->GrayLevel[0.5]};GraphicsRow[{Graph[cells,edges,VertexCoordinates->coords,EdgeStyle->Directive[Gray,Thin],VertexLabels->Placed["Name",Center],PlotLabel->Style["Groundplane: Physical Connectivity",Bold,14],ImageSize->400],Graph[cells,treeEdges[cells[[1]]],VertexCoordinates->coords,EdgeStyle->Directive[Blue,Thick],VertexLabels->Placed["Name",Center],PlotLabel->Style["Spanning Tree (TRAPH) Rooted at Cell "<>ToString[cells[[1]]],Bold,14],ImageSize->400],Graph[cells,edges,VertexCoordinates->coords,EdgeShapeFunction->(If[#2===failedLink,{Red,Thick,Dashed,Line[#1]},{Gray,Thin,Line[#1]}]&),VertexLabels->Placed["Name",Center],PlotLabel->Style["Failed Link Highlighted in Red",Bold,14],ImageSize->400],Graph[cells,rerouteEdges,VertexCoordinates->coords,EdgeStyle->Directive[Green,Thick,Dashed],VertexLabels->Placed["Name",Center],PlotLabel->Style["Failover Rerouted Spanning Tree at Root "<>ToString[First[failedLink]],Bold,14],ImageSize->400]},Spacings->20]]


SeedRandom[23];
nNodes=7;
chipNet=Graph[{"A","B","C","D","E","F","G"},{"A"\[UndirectedEdge]"B","A"\[UndirectedEdge]"D","B"\[UndirectedEdge]"C","B"\[UndirectedEdge]"E","C"\[UndirectedEdge]"F","D"\[UndirectedEdge]"E","D"\[UndirectedEdge]"G","E"\[UndirectedEdge]"F","F"\[UndirectedEdge]"G"},VertexCoordinates->Association["A"->{0,1},"B"->{1,2},"C"->{2.2,2.4},"D"->{0,-0.8},"E"->{1.2,0.3},"F"->{2.5,1.2},"G"->{2.2,-0.7}],VertexStyle->Lighter[Blue,0.6],EdgeStyle->Gray,VertexLabels->"Name",ImageSize->370];
sourcePath={"A","B","E","F","G"};
sourceRoutingGraph=HighlightGraph[chipNet,{Style[PathGraph[sourcePath],Orange,Thick],Style["A",Green,Bold,18],Style["G",Red,Bold,18]},GraphHighlightStyle->"Dehighlighted"];
sourceLabel=Labeled[sourceRoutingGraph,Column[{Style["Source Routing",16,Bold,Orange],"Path encoded: A \[RightArrow] B \[RightArrow] E \[RightArrow] F \[RightArrow] G\nHeader: [B,E,F,G]\nAt each node, the next hop is read from header."}],Top];
destPath=FindShortestPath[chipNet,"A","G"];
destRoutingGraph=HighlightGraph[chipNet,{Style[PathGraph[destPath],Purple,Thick,Dashed],Style["A",Green,Bold,18],Style["G",Red,Bold,18]},GraphHighlightStyle->"Dehighlighted"];
destLabel=Labeled[destRoutingGraph,Column[{Style["Destination-Based Routing",16,Bold,Purple],"Packet carries destination G\nEach node forwards via table:\nNext = FwdTbl[destination]"}],Top];
serviceLocation="F";
namePath=FindShortestPath[chipNet,"A",serviceLocation];
nameRoutingGraph=HighlightGraph[chipNet,{Style[PathGraph[namePath],Blue,Thick,Dotted],Style["A",Green,Bold,18],Style[serviceLocation,Red,Bold,18]},GraphHighlightStyle->"Dehighlighted"];
nameLabel=Labeled[nameRoutingGraph,Column[{Style["Name-Based Routing",16,Bold,Blue],"Packet: [service=foo]\nRouters resolve name \[RightArrow] location\nPath = A \[RightArrow] B \[RightArrow] C \[RightArrow] F"}],Top];
summaryTable=Grid[{{"Routing Type","Header Overhead","Per-Hop Logic","Flexibility"},{"Source Routing","High","Low","Low"},{"Destination-Based","Low","Medium","Medium"},{"Name-Based","Medium/High","High","High"}},Frame->All,Background->{None,{{LightGray,None,None,None}}},Alignment->Left];
Column[{Style["Chiplet Ethernet: Routing Paradigm Visualization","Section"],Row[{sourceLabel,Spacer[8],destLabel,Spacer[8],nameLabel}],Spacer[12],Style["Routing Paradigm Summary","Subsection"],summaryTable}]


SeedRandom[100];
nodes=Range[8];
edges={1\[UndirectedEdge]2,1\[UndirectedEdge]5,2\[UndirectedEdge]3,2\[UndirectedEdge]6,3\[UndirectedEdge]4,3\[UndirectedEdge]7,4\[UndirectedEdge]8,5\[UndirectedEdge]6,6\[UndirectedEdge]7,7\[UndirectedEdge]8};
g=Graph[nodes,edges,VertexLabels->"Name",GraphStyle->"NameLabeled",ImageSize->340];
antStart=1;
antSteps=7;
antPath=Module[{path={antStart}},Do[Module[{curr=Last[path],nb},nb=DeleteCases[NeighborhoodVertices[g,curr],Alternatives@@path];If[nb==={}||!ListQ[nb],Break[],AppendTo[path,RandomChoice[nb]]]],{antSteps}];path=DeleteDuplicates[path];path];
antEdges=UndirectedEdge@@@Partition[antPath,2,1];
pheromoneColors=Table[Blend[{Yellow,Orange},k/antSteps],{k,0,Length[antEdges]-1}];
antTrailGraph=HighlightGraph[g,{Style[antPath,Directive[Bold,Black,20]],MapThread[Style,{antEdges,pheromoneColors}]}];
antTrailLabel="Ant-Based Discovery:\nScouts sample and reinforce paths (pheromones).";
hiveNode=6;
beePaths=Table[FindShortestPath[g,hiveNode,i],{i,Complement[nodes,{hiveNode}]}];
beeEdges=Flatten[(UndirectedEdge@@@Partition[#1,2,1]&)/@beePaths];
beeGraph=HighlightGraph[g,{Style[hiveNode,Directive[Bold,Darker[Yellow],24]],Style[beeEdges,Thick,Yellow],Style[Flatten[beePaths],Directive[Bold,Black,18]]}];
beeLabel="Bee-Inspired: Scouts report to Hive; dance broadcasts best routes.";
snakeStart=1;
snakeRoute=Quiet[FindHamiltonianPath[g]];
If[!ListQ[snakeRoute]||Length[snakeRoute]<Length[nodes],snakeRoute=FindPath[g,snakeStart,8,All,12];If[ListQ[snakeRoute]&&snakeRoute=!={},snakeRoute=snakeRoute[[1]],snakeRoute={snakeStart}]];
snakeEdges=If[Length[snakeRoute]>1,UndirectedEdge@@@Partition[snakeRoute,2,1],{}];
snakeGraph=HighlightGraph[g,{Style[snakeRoute,Directive[Bold,Purple,20]],Style[snakeEdges,Thick,Purple]}];
snakeLabel="Snake Traversal:\nSystematically visits all nodes, returns with full map.";
spiderOrigin=1;
spiderThreads=Table[FindPath[g,spiderOrigin,n,3],{n,Complement[nodes,{spiderOrigin}]}];
spiderThreadsFlat=Select[Flatten[spiderThreads,1],Length[#1]>1&];
spiderEdges=Flatten[(UndirectedEdge@@@Partition[#1,2,1]&)/@spiderThreadsFlat];
spiderGraph=HighlightGraph[g,{Style[spiderOrigin,Directive[Bold,Black,22]],Style[spiderEdges,Dashed,Darker[Gray,0.4]]}];
spiderLabel="Spider Web: Multi-threaded discovery and local neighbor webs.";
wormPath={1,2,6,7,8};
wormEdges=UndirectedEdge@@@Partition[wormPath,2,1];
flitColors={Red,Orange,Green};
frames=Table[HighlightGraph[g,{Style[wormPath[[1;;i]],Directive[Bold,Black,18]],If[i>=2,Style[wormEdges[[1;;i-1]],Thick,Blue],{}],If[i>=1,Style[wormPath[[i]],flitColors[[1]]],{}],If[i>=2&&i<Length[wormPath],Style[wormPath[[2;;i]],flitColors[[2]]],{}],If[i==Length[wormPath],Style[wormPath[[i]],flitColors[[3]]],{}]}],{i,1,Length[wormPath]}];
wormLabel="Wormhole Routing:\nFlits forwarded in a pipeline (head, body, tail).";
routingTable={{"Technique","Discovery/Forwarding","Overhead","Adaptivity","Ideal Use"},{"Ant","Random scouts, pheromone trails","Low","High","Adaptive routing, scalable"},{"Bee","Hive aggregation, dancing","Medium","Medium","Semi-centralized optimization"},{"Snake","Full network traversal, return","High","Low","Diagnostics, full map"},{"Spider","Multi-thread, local web","Medium","High","Redundant mesh building"},{"Wormhole","Flits in pipeline","Low","High","Low-latency forwarding"}};
Print["--- Biologically Inspired Topology Learning & Routing ---"];
Grid[{{Labeled[antTrailGraph,antTrailLabel,Top],Labeled[beeGraph,beeLabel,Top]},{Labeled[snakeGraph,snakeLabel,Top],Labeled[spiderGraph,spiderLabel,Top]}},Spacings->{2,2}]
Print["--- Wormhole Routing Animation (Head/Body/Tail Flits) ---"];
ListAnimate[frames,AnimationRunning->False]
Print["--- Technique Comparison Table ---"];
Grid[routingTable,Frame->All,Alignment->Center,Background->{None,{{Lighter[Gray,0.95]},None}}]


Module[{gridSize=5,nodes,nodeCoords,directions,dirVectors,dirNames,pheromoneTable,pheromoneDecay=0.9,pheromoneIncrement=0.3,packets,maxSteps=40,busyPorts,colors,choosePort,updatePheromones,movePackets,routerGraphics,pheromoneGraphics,packetGraphics},nodes=Flatten[Table[{x,y},{x,1,gridSize},{y,1,gridSize}],1];nodeCoords=Association[Table[node->{node[[1]],node[[2]]},{node,nodes}]];directions={"N"->{0,1},"NE"->{1,1},"E"->{1,0},"SE"->{1,-1},"S"->{0,-1},"SW"->{-1,-1},"W"->{-1,0},"NW"->{-1,1}};dirNames=directions[[All,1]];dirVectors=Association[directions];colors=AssociationThread[dirNames->Take[ColorData[97,"ColorList"],Length[dirNames]]];pheromoneTable=Association[Table[node->Association[Table[dir->RandomReal[{0.1,0.3}],{dir,dirNames}]],{node,nodes}]];packets={{{1,1},{gridSize,gridSize},{},None},{{gridSize,1},{1,gridSize},{},None},{{1,gridSize},{gridSize,1},{},None}};busyPorts=Association[Table[node->{},{node,nodes}]];possiblePorts[node_]:=Select[directions,MemberQ[nodes,node+#1[[2]]]&];choosePort[node_,dest_,lastDir_]:=Module[{ports=possiblePorts[node],sortedPorts,freePorts,chosenDir,pheromonesAtNode=pheromoneTable[node]},sortedPorts=SortBy[ports,{-pheromonesAtNode[#1[[1]]],EuclideanDistance[node+#1[[2]],dest]}&];freePorts=Select[sortedPorts,!MemberQ[busyPorts[node],#1[[1]]]&];If[freePorts=!={},chosenDir=freePorts[[1,1]],chosenDir=If[Complement[dirNames,busyPorts[node]]=!={},First[Complement[dirNames,busyPorts[node]]],None]];chosenDir];updatePheromones[path_]:=Module[{},Do[pheromoneTable[path[[i]]][path[[i+1]]]=Min[1.0,pheromoneTable[path[[i]]][path[[i+1]]]+pheromoneIncrement],{i,Length[path]-1}];pheromoneTable=(AssociationMap[#1 pheromoneDecay&,#1]&)/@pheromoneTable;];movePackets[]:=Module[{newPackets={},chosenDir,nextNode,p,currNode,dest,path,lastDir},busyPorts=Association[Table[node->{},{node,nodes}]];For[p=1,p<=Length[packets],p++,{currNode,dest,path,lastDir}=packets[[p]];If[currNode===dest,updatePheromones[Append[path,currNode]];Continue[];];chosenDir=choosePort[currNode,dest,lastDir];If[chosenDir===None,AppendTo[newPackets,{currNode,dest,Append[path,currNode],lastDir}],nextNode=currNode+dirVectors[chosenDir];busyPorts[currNode]=Append[busyPorts[currNode],chosenDir];With[{oppDir=Switch[chosenDir,"N","S","NE","SW","E","W","SE","NW","S","N","SW","NE","W","E","NW","SE"]},busyPorts[nextNode]=Append[busyPorts[nextNode],oppDir]];AppendTo[newPackets,{nextNode,dest,Append[path,currNode],chosenDir}];];];packets=newPackets;];routerGraphics[]:=Graphics[Table[{LightGray,EdgeForm[Black],Rectangle[nodeCoords[node]-0.3,nodeCoords[node]+0.3],Table[{colors[dirNames[[i]]],Disk[nodeCoords[node]+0.35 dirVectors[dirNames[[i]]],0.1],Text[Style[dirNames[[i]],Small,Bold,Black],nodeCoords[node]+0.65 dirVectors[dirNames[[i]]]]},{i,Length[dirNames]}]},{node,nodes}],PlotRange->{{0,gridSize+1},{0,gridSize+1}},ImageSize->700,Background->Lighter[Gray,0.95]];pheromoneGraphics[]:=Graphics[Flatten[Table[Table[Module[{pos=nodeCoords[node]+0.15 dirVectors[dir],level},level=pheromoneTable[node][dir];{Opacity[level],colors[dir],Thick,Arrow[{pos,pos+0.2 dirVectors[dir]}]}],{dir,dirNames}],{node,nodes}],1],PlotRange->{{0,gridSize+1},{0,gridSize+1}},ImageSize->700];packetGraphics[]:=Graphics[Table[If[Length[packets]>=p,Style[Disk[nodeCoords[packets[[p,1]]],0.18],Directive[Thick,Black]],{}],{p,Length[packets]}],PlotRange->{{0,gridSize+1},{0,gridSize+1}},ImageSize->700];DynamicModule[{localStep=1},Panel[Column[{Style["Biologically Inspired Scouting & Bufferless Deflection Routing Simulation",Bold,16],Dynamic[Show[routerGraphics[],pheromoneGraphics[],packetGraphics[],PlotRange->{{0,gridSize+1},{0,gridSize+1}},ImageSize->700]],Row[{Button["Step Forward",movePackets[];localStep++,Enabled->Dynamic[localStep<maxSteps]],Button["Reset",packets={{{1,1},{gridSize,gridSize},{},None},{{gridSize,1},{1,gridSize},{},None},{{1,gridSize},{gridSize,1},{},None}};pheromoneTable=Association[Table[node->Association[Table[dir->RandomReal[{0.1,0.3}],{dir,dirNames}]],{node,nodes}]];localStep=1;]}],Dynamic[Text[StringForm["Step `` of ``", localStep, maxSteps]]]}]]]]


Module[{nNodes=10,path,coords,nodeRadius=0.15,packetLength=5,flitSize=0.25,flitSpacing=0.3,maxSteps,step=0,animFrames,flitPositions,headFlitIndex,stalled=False,headColor=Red,bodyColor=Orange,tailColor=Blue,blockedColor=Gray,edgeVector,edgeLength,flitCoord,edgeIndex},path=Range[nNodes];coords=Table[{i,0},{i,nNodes}];edges=Partition[path,2,1];maxSteps=nNodes+packetLength+5;flitCoord[edgeIdx_,pos_]:=Module[{startPt,endPt},startPt=coords[[edgeIdx]];endPt=coords[[edgeIdx+1]];startPt+pos (endPt-startPt)];nodeGraphics:=Table[{LightGray,EdgeForm[Black],Disk[coords[[i]],nodeRadius],Black,Text[Style[ToString[i],Bold,14],coords[[i]]+{0,-0.3}]},{i,nNodes}];edgeGraphics:=Table[{Black,Thick,Line[{coords[[i]],coords[[i+1]]}]},{i,nNodes-1}];animFrames=Table[step=t;flitPositions=Table[Module[{pos},pos=step-i+1;If[pos<1,Nothing,edgeIdx=Floor[pos];frac=pos-edgeIdx;If[edgeIdx>nNodes-1,Nothing,{edgeIdx,frac}]]],{i,packetLength}];flitPositions=DeleteCases[flitPositions,Nothing];stalled=step>=8&&step<=12;If[stalled,flitPositions=flitPositions/. {4,_}:>{4,0.9};flitPositions=SortBy[flitPositions,#1[[1]]&];flitPositions=Table[If[i==1,{4,0.9},{4,Max[0,0.9-(i-1) flitSpacing]}],{i,Length[flitPositions]}];];flitGraphics=Table[Module[{edgeIdx=flitPositions[[i,1]],pos=flitPositions[[i,2]],col},col=Which[i==1&&stalled,blockedColor,i==1,headColor,i==packetLength,tailColor,True,bodyColor];{col,Disk[flitCoord[edgeIdx,pos],flitSize]}],{i,Length[flitPositions]}];Graphics[{edgeGraphics,nodeGraphics,flitGraphics,Black,Text[Style["Step: "<>ToString[step],Bold,16],{0,1}],If[stalled,Text[Style["Status: BLOCKED at Edge 4",Red,Bold,14],{0,0.7}],Text[Style["Status: Transmitting",Darker[Green],Bold,14],{0,0.7}]]},PlotRange->{{0,nNodes+1},{-1,1}},ImageSize->700,Background->Lighter[Gray,0.9]],{t,1,maxSteps}];Manipulate[animFrames[[step]],{step,1,maxSteps,1},Initialization:>(Print["Wormhole Routing Simulation:\nRed=Head Flit, Orange=Body Flits, Blue=Tail Flit"];Print["Gray flit indicates blocked/stalled state"];)]]


Module[{macAddresses={"MAC1","MAC2","MAC3","MAC4","MAC5","MAC6","MAC7"},initialEdges={"MAC1"\[UndirectedEdge]"MAC2","MAC1"\[UndirectedEdge]"MAC3","MAC2"\[UndirectedEdge]"MAC4","MAC2"\[UndirectedEdge]"MAC5","MAC3"\[UndirectedEdge]"MAC5","MAC4"\[UndirectedEdge]"MAC6","MAC5"\[UndirectedEdge]"MAC6","MAC5"\[UndirectedEdge]"MAC7","MAC6"\[UndirectedEdge]"MAC7"},g,spanningTree,treeEdges,colors,dynamicUpdates,maxUpdates=3,computeSpanningTree,highlightLoopFreePaths,simulateDynamicChange},g=Graph[macAddresses,initialEdges,VertexLabels->"Name",ImageSize->450];computeSpanningTree[graph_]:=FindSpanningTree[graph];spanningTree=computeSpanningTree[g];treeEdges=EdgeList[spanningTree];colors=ColorData[97,"ColorList"];highlightLoopFreePaths[graph_,src_]:=Module[{allPaths,edgeHighlightRules={},edgesInPath},allPaths=Table[FindShortestPath[graph,src,dst],{dst,VertexList[graph]}];Do[If[Length[allPaths[[i]]]>=2,edgesInPath=UndirectedEdge@@@Partition[allPaths[[i]],2,1];AppendTo[edgeHighlightRules,Thread[edgesInPath->colors[[Mod[i-1,Length[colors]]+1]]]]],{i,Length[allPaths]}];DeleteDuplicates[Flatten[edgeHighlightRules,1]]];Print["\n--- Initial Network Topology ---"];Print[Graph[g,GraphLayout->"SpringElectricalEmbedding",EdgeStyle->Directive[Gray,Thin],VertexSize->Medium]];Print["\n--- Loop-Free Spanning Tree (Avoid Broadcast Storms) ---"];Print[Graph[g,EdgeStyle->Thread[EdgeList[g]->(If[MemberQ[treeEdges,#1],Directive[Blue,Thick],Gray]&)/@EdgeList[g]],GraphLayout->"SpringElectricalEmbedding",VertexSize->Medium]];Print["\n--- Loop-Free Paths Highlighted by Path Identifiers ---"];Print[Graph[g,EdgeStyle->highlightLoopFreePaths[spanningTree,"MAC1"],GraphLayout->"SpringElectricalEmbedding",VertexSize->Medium]];simulateDynamicChange[graph_,step_]:=Module[{updatedGraph},Switch[step,1,EdgeDelete[graph,"MAC2"\[UndirectedEdge]"MAC5"],2,EdgeAdd[graph,"MAC3"\[UndirectedEdge]"MAC6"],3,VertexDelete[graph,"MAC4"],_,graph]];dynamicUpdates=Table[Module[{gUpdated,st,edgeRules},Quiet[gUpdated=simulateDynamicChange[g,i];st=computeSpanningTree[gUpdated];edgeRules=highlightLoopFreePaths[st,"MAC1"];Print[Style[StringForm["\n--- Dynamic Topology Update Step `1` ---", i],Bold,14]];Print[Graph[gUpdated,EdgeStyle->edgeRules,GraphLayout->"SpringElectricalEmbedding",VertexSize->Medium,ImageSize->450]];g=gUpdated;]],{i,1,maxUpdates}];Print["\n--- Computational Overhead Timing ---"];Print[Timing[Do[computeSpanningTree[g],{1000}]]];]


vertices=Range[10];
edges={1\[UndirectedEdge]2,1\[UndirectedEdge]3,2\[UndirectedEdge]3,2\[UndirectedEdge]4,3\[UndirectedEdge]5,4\[UndirectedEdge]5,4\[UndirectedEdge]6,5\[UndirectedEdge]7,6\[UndirectedEdge]7,6\[UndirectedEdge]8,7\[UndirectedEdge]9,8\[UndirectedEdge]9,8\[UndirectedEdge]10,9\[UndirectedEdge]10};
g=Graph[vertices,edges,VertexLabels->"Name",GraphLayout->"SpringElectricalEmbedding"];
degreeList=VertexDegree[g];
maxDegree=Max[degreeList];
edgeColors=Association[];
usedColorsPerVertex=AssociationThread[vertices->Table[{},Length[vertices]]];
availableColors=Range[maxDegree+1];
Do[Module[{u=First[edge],v=Last[edge],forbiddenColors,chosenColor},forbiddenColors=usedColorsPerVertex[u]\[Union]usedColorsPerVertex[v];chosenColor=First[Complement[availableColors,forbiddenColors]];edgeColors[edge]=chosenColor;AppendTo[usedColorsPerVertex[u],chosenColor];AppendTo[usedColorsPerVertex[v],chosenColor];],{edge,edges}];
palette=ColorData[97,"ColorList"];
numColors=maxDegree+1;
colorFunc[colorIndex_]:=palette[[Mod[colorIndex-1,Length[palette]]+1]];
edgeStyles=Table[edge->Directive[Thick,colorFunc[edgeColors[edge]]],{edge,edges}];
coloredGraph=Graph[vertices,edges,VertexLabels->Placed["Name",Center],GraphLayout->"SpringElectricalEmbedding",EdgeStyle->edgeStyles,ImageSize->Large,PlotLabel->Style[StringForm["Edge Coloring of Ethernet Graph with `1` Colors (\[CapitalDelta] = `2`)", numColors, maxDegree],Bold,16]];
coloredGraph


Module[{n=8,N=5,states,initialState,transformations,inverses,xorMasks,forwardStates,rollbackStates,acknowledgments,showVector,showTransformation,nodes,step=1},SeedRandom[2025];nodes=Table["A"<>ToString[i],{i,0,N}];initialState=ConstantArray[0,n];states=AssociationThread[nodes->ConstantArray[initialState,Length[nodes]]];xorMasks=Table[RandomInteger[{0,1},n],{N}];applyXORMask[vec_,mask_]:=Mod[vec+mask,2];forwardStates=states;Do[forwardStates[nodes[[i+1]]]=applyXORMask[forwardStates[nodes[[i+1]]],xorMasks[[i]]];forwardStates[nodes[[i]]]=applyXORMask[forwardStates[nodes[[i]]],xorMasks[[i]]];,{i,1,N}];rollbackStates=forwardStates;Do[rollbackStates[nodes[[i]]]=applyXORMask[rollbackStates[nodes[[i]]],xorMasks[[i]]];rollbackStates[nodes[[i+1]]]=applyXORMask[rollbackStates[nodes[[i+1]]],xorMasks[[i]]];,{i,N,1,-1}];acknowledgments=AssociationThread[nodes,Table[If[i==0,False,True],{i,0,N}]];showVector[vec_]:=Row[(Style[ToString[#1],Bold]&)/@vec," "];showTransformation[i_]:=Row[{"Mask \[Delta]_",ToString[i],": ",showVector[xorMasks[[i]]]}];DynamicModule[{currentStep=1,forwardPhase=True},Column[{Style["5. Reversible Transactions Visualization",Bold,20],Spacer[10],Style["Initial State (All zero vector) at each node:",Bold,14],Grid[Table[{nodes[[i]],showVector[initialState]},{i,Length[nodes]}],Alignment->Left],Spacer[10],Dynamic[If[forwardPhase,Style["Forward Execution Phase: Applying Masks Along Chain",Bold,16,Darker[Green]],Style["Rollback Phase: Reverting Transformations",Bold,16,Darker[Red]]]],Spacer[5],Dynamic[Grid[Table[With[{node=nodes[[i]]},{node,If[forwardPhase,If[i<=currentStep+1,showVector[forwardStates[node]],Style["--",Gray]],If[i>=N-currentStep,showVector[rollbackStates[node]],Style["--",Gray]]]}],{i,Length[nodes]}],Alignment->Left]],Spacer[10],Dynamic[If[forwardPhase,If[currentStep<=N,showTransformation[currentStep],Style["Forward phase complete. Switch to rollback.",Italic]],If[currentStep>=1,showTransformation[currentStep],Style["Rollback phase complete.",Italic]]]],Spacer[10],Row[{Button["Prev",If[currentStep>1,currentStep--;If[forwardPhase&&currentStep==0,currentStep=1];If[!forwardPhase&&currentStep==0,currentStep=1];],Enabled->Dynamic[currentStep>1]],Spacer[20],Button["Next",If[forwardPhase,If[currentStep<N,currentStep++,forwardPhase=False;currentStep=N;],If[currentStep>1,currentStep--]],Enabled->Dynamic[If[forwardPhase,currentStep<N||True,currentStep>1]]],Spacer[40],Button[Dynamic[If[forwardPhase,"Switch to Rollback","Switch to Forward"]],forwardPhase=!forwardPhase;currentStep=If[forwardPhase,1,N];]}]}]]]


Module[{n=8,N=4,states,forwardStates,rollbackStates,masks,xorVec,applyTransformation,applyInverseTransformation,formatVec,visualizeStates,acknowledgments,step=0,maxStep,dyn},SeedRandom[1234];states=Table[ConstantArray[0,n],{i,0,N}];masks=Table[RandomInteger[{0,1},n],{i,1,N}];xorVec[v1_,v2_]:=Mod[v1+v2,2];applyTransformation[S_,mask_]:=xorVec[S,mask];applyInverseTransformation[S_,mask_]:=xorVec[S,mask];forwardStates=Table[Null,{N+1}];forwardStates[[1]]=states[[1]];Do[forwardStates[[i+1]]=applyTransformation[forwardStates[[i]],masks[[i]]],{i,1,N}];rollbackStates=Table[Null,{N+1}];rollbackStates[[N+1]]=forwardStates[[N+1]];Do[rollbackStates[[i]]=applyInverseTransformation[rollbackStates[[i+1]],masks[[i]]],{i,N,1,-1}];maxStep=2 N+2;formatVec[v_]:=StringJoin[ToString/@v];visualizeStates[currentStep_]:=Module[{displayStates,acknowledgments},displayStates=Table[Which[currentStep<=N+1,If[i<=currentStep-1,forwardStates[[i]],states[[i]]],currentStep>N+1,If[i>=N+2-(currentStep-(N+1)),rollbackStates[[i]],forwardStates[[i]]],True,states[[i]]],{i,1,N+1}];acknowledgments=Table[Which[currentStep<=N+1,i<=currentStep-1,currentStep>N+1,i>=N+2-(currentStep-(N+1)),True,False],{i,1,N+1}];Grid[Prepend[Table[{Style["Node A"<>ToString[i-1],Bold],Style[formatVec[displayStates[[i]]],FontFamily->"Courier",16],If[acknowledgments[[i]],Style["\:2714",Green,Bold,18],Style["\:2718",Red,Bold,18]]},{i,1,N+1}],{"Node","State Vector","Ack"}],Frame->All,ItemSize->{{8,16,3}}]];dyn=DynamicModule[{step=0},Column[{Style["Reversible Transactions Simulation",Bold,20],Dynamic[Column[{visualizeStates[step],Spacer[10],Style[Which[step==0,"Initial states before any transaction",step<=N+1,"Forward Execution: Applying transformations down the chain",step==N+2,"All forward transformations applied",step<=maxStep,"Rollback Execution: Applying inverse transformations up the chain",True,"Transaction fully rolled back"],Italic,14],Spacer[10],Row[{Button["Previous",If[step>0,step--],ImageSize->Medium],Spacer[20],Button["Next",If[step<maxStep,step++],ImageSize->Medium],Spacer[20],Style[Row[{"Step: ",Dynamic[step],"/",maxStep}],Bold]}]}]]}]];dyn]


Module[{n=8,N=3,S0,Sforward,Srollback,masks,showBitVector,showMask,forwardRows,rollbackRows},S0=ConstantArray[0,{N+1,n}];SeedRandom[1234];masks=RandomInteger[{0,1},{N,n}];xor[u_,v_]:=BitXor[u,v];Sforward=S0;Do[Sforward[[i]]=xor[Sforward[[i]],masks[[i]]];Sforward[[i+1]]=xor[Sforward[[i+1]],masks[[i]]],{i,N}];Srollback=Sforward;Do[Srollback[[i+1]]=xor[Srollback[[i+1]],masks[[i]]];Srollback[[i]]=xor[Srollback[[i]],masks[[i]]],{i,N,1,-1}];showBitVector[vec_List]:=Graphics[Table[{If[vec[[j]]==1,Darker[Blue],GrayLevel[0.85]],Rectangle[{(j-1)/n,0},{j/n,1}]},{j,n}],ImageSize->140,PlotRange->{{0,1},{0,1}},Axes->False];showMask[mask_List]:=Style["Mask: "<>StringJoin[ToString/@mask],11,Bold,Darker[Red]];forwardRows=Table[{"Link "<>ToString[i],showMask[masks[[i]]],showBitVector[S0[[i]]],"\[RightArrow]",showBitVector[Sforward[[i+1]]]},{i,1,N}];rollbackRows=Table[{"Link "<>ToString[i],showMask[masks[[i]]],showBitVector[Sforward[[i+1]]],"\[RightArrow]",showBitVector[S0[[i]]]},{i,N,1,-1}];DynamicModule[{step=0,max=N},Panel[Column[{Style["5. Reversible Transactions \[Dash] XOR Mask Example",17,Bold],Spacer[8],Style["Initial states (all 0):",Bold,13],Grid[Table[{"Node A"<>ToString[i],showBitVector[S0[[i+1]]]},{i,0,N}]],Spacer[15],Style["Forward execution",Bold,13],Dynamic[Grid[Take[forwardRows,step],Alignment->Left]],Row[{Button["Prev",If[step>0,step--]],Spacer[6],Button["Next",If[step<max,step++]]}],Spacer[20],Style["Rollback execution",Bold,13],Dynamic[Grid[Take[rollbackRows,step],Alignment->Left]],Row[{Button["Prev",If[step>0,step--]],Spacer[6],Button["Next",If[step<max,step++]]}]},FrameMargins->15,ImageSize->700]]]]


Module[{nodes={"Coordinator","Participant1","Participant2"},colors=Association["Coordinator"->LightBlue,"Participant1"->LightGreen,"Participant2"->LightGreen],edgeOpts={Arrowheads[0.03],Thick},styles,onePhaseGraph,twoPhaseGraph,fourPhaseGraph,onePhaseTimeline,twoPhaseTimeline,fourPhaseTimeline,timelineHeight=2,timelineSpacing=1,msgStyle={Black,Bold,FontSize->12}},styles=MapThread[#1->Style[#1,Background->#2,Frame->True,FrameStyle->Directive[Black,Thick],RoundingRadius->5,Padding->10]&,{nodes,Lookup[colors,nodes]}];onePhaseGraph=Rasterize[Graph[nodes,{DirectedEdge["Coordinator","Participant1","Commit"],DirectedEdge["Coordinator","Participant2","Commit"]},VertexLabels->styles,EdgeLabels->Placed[{"Commit","Commit"},Center],GraphLayout->{"LayeredDigraphEmbedding","Orientation"->LeftToRight},ImageSize->400,EdgeStyle->edgeOpts]];onePhaseTimeline=Graphics[{Style[Line[{{0,timelineHeight},{8,timelineHeight}}],Gray,Dashed],Style[Line[{{0,timelineHeight-timelineSpacing},{8,timelineHeight-timelineSpacing}}],Gray,Dashed],Style[Line[{{0,timelineHeight+timelineSpacing},{8,timelineHeight+timelineSpacing}}],Gray,Dashed],Text[Style["Coordinator",Bold,14],{-0.5,timelineHeight+timelineSpacing}],Text[Style["Participant1",Bold,14],{-0.5,timelineHeight}],Text[Style["Participant2",Bold,14],{-0.5,timelineHeight-timelineSpacing}],{Arrowheads[0.03],Blue,Arrow[{{1,timelineHeight+timelineSpacing},{3,timelineHeight}}]},Text[Style["Commit",msgStyle],{2,timelineHeight+0.5}],{Arrowheads[0.03],Blue,Arrow[{{1,timelineHeight+timelineSpacing},{3,timelineHeight-timelineSpacing}}]},Text[Style["Committed",Darker[Green],Bold,12],{7.5,timelineHeight}],Text[Style["Committed",Darker[Green],Bold,12],{7.5,timelineHeight-timelineSpacing}]},PlotRange->{{-1,9},{timelineHeight-2 timelineSpacing,timelineHeight+2 timelineSpacing}},ImageSize->450];twoPhaseGraph=Rasterize[Graph[nodes,{"Coordinator"\[DirectedEdge]"Participant1","Coordinator"\[DirectedEdge]"Participant2","Participant1"\[DirectedEdge]"Coordinator","Participant2"\[DirectedEdge]"Coordinator","Coordinator"\[DirectedEdge]"Participant1","Coordinator"\[DirectedEdge]"Participant2"},VertexLabels->styles,EdgeLabels->Placed[{"Prepare","Prepare","Ack","Ack","Commit","Commit"},Center],GraphLayout->{"LayeredDigraphEmbedding","Orientation"->LeftToRight},ImageSize->500,EdgeStyle->edgeOpts]];twoPhaseTimeline=Graphics[{Style[Line[{{0,timelineHeight},{12,timelineHeight}}],Gray,Dashed],Style[Line[{{0,timelineHeight-timelineSpacing},{12,timelineHeight-timelineSpacing}}],Gray,Dashed],Style[Line[{{0,timelineHeight+timelineSpacing},{12,timelineHeight+timelineSpacing}}],Gray,Dashed],Text[Style["Coordinator",Bold,14],{-0.5,timelineHeight+timelineSpacing}],Text[Style["Participant1",Bold,14],{-0.5,timelineHeight}],Text[Style["Participant2",Bold,14],{-0.5,timelineHeight-timelineSpacing}],{Arrowheads[0.03],Blue,Arrow[{{1,timelineHeight+timelineSpacing},{3,timelineHeight}}]},Text[Style["Prepare",msgStyle],{2,timelineHeight+0.5}],{Arrowheads[0.03],Blue,Arrow[{{1,timelineHeight+timelineSpacing},{3,timelineHeight-timelineSpacing}}]},{Arrowheads[0.03],Red,Dashed,Arrow[{{4,timelineHeight},{6,timelineHeight+timelineSpacing}}]},Text[Style["Ack",msgStyle],{5,timelineHeight+0.5}],{Arrowheads[0.03],Red,Dashed,Arrow[{{4,timelineHeight-timelineSpacing},{6,timelineHeight+timelineSpacing}}]},{Arrowheads[0.03],Blue,Arrow[{{7,timelineHeight+timelineSpacing},{9,timelineHeight}}]},Text[Style["Commit",msgStyle],{8,timelineHeight+0.5}],{Arrowheads[0.03],Blue,Arrow[{{7,timelineHeight+timelineSpacing},{9,timelineHeight-timelineSpacing}}]},Text[Style["Committed",Darker[Green],Bold,12],{11,timelineHeight}],Text[Style["Committed",Darker[Green],Bold,12],{11,timelineHeight-timelineSpacing}]},PlotRange->{{-1,13},{timelineHeight-2 timelineSpacing,timelineHeight+2 timelineSpacing}},ImageSize->550];fourPhaseGraph=Rasterize[Graph[nodes,{"Coordinator"\[DirectedEdge]"Participant1","Coordinator"\[DirectedEdge]"Participant2","Participant1"\[DirectedEdge]"Coordinator","Participant2"\[DirectedEdge]"Coordinator","Coordinator"\[DirectedEdge]"Participant1","Coordinator"\[DirectedEdge]"Participant2","Participant1"\[DirectedEdge]"Coordinator","Participant2"\[DirectedEdge]"Coordinator","Coordinator"\[DirectedEdge]"Participant1","Coordinator"\[DirectedEdge]"Participant2"},VertexLabels->styles,EdgeLabels->Placed[{"Prepare","Prepare","Ack","Ack","PreCommit","PreCommit","Ack2","Ack2","Commit","Commit"},Center],GraphLayout->{"LayeredDigraphEmbedding","Orientation"->LeftToRight},ImageSize->700,EdgeStyle->edgeOpts]];fourPhaseTimeline=Graphics[{Style[Line[{{0,timelineHeight},{18,timelineHeight}}],Gray,Dashed],Style[Line[{{0,timelineHeight-timelineSpacing},{18,timelineHeight-timelineSpacing}}],Gray,Dashed],Style[Line[{{0,timelineHeight+timelineSpacing},{18,timelineHeight+timelineSpacing}}],Gray,Dashed],Text[Style["Coordinator",Bold,14],{-0.5,timelineHeight+timelineSpacing}],Text[Style["Participant1",Bold,14],{-0.5,timelineHeight}],Text[Style["Participant2",Bold,14],{-0.5,timelineHeight-timelineSpacing}],Text[Style["Prepare",msgStyle],{2,timelineHeight+0.5}],{Arrowheads[0.03],Blue,Arrow[{{1,timelineHeight+timelineSpacing},{3,timelineHeight}}]},{Arrowheads[0.03],Blue,Arrow[{{1,timelineHeight+timelineSpacing},{3,timelineHeight-timelineSpacing}}]},Text[Style["Ack",msgStyle],{5,timelineHeight+0.5}],{Arrowheads[0.03],Red,Dashed,Arrow[{{4,timelineHeight},{6,timelineHeight+timelineSpacing}}]},{Arrowheads[0.03],Red,Dashed,Arrow[{{4,timelineHeight-timelineSpacing},{6,timelineHeight+timelineSpacing}}]},Text[Style["PreCommit",msgStyle],{8,timelineHeight+0.5}],{Arrowheads[0.03],Blue,Dotted,Arrow[{{7,timelineHeight+timelineSpacing},{9,timelineHeight}}]},{Arrowheads[0.03],Blue,Dotted,Arrow[{{7,timelineHeight+timelineSpacing},{9,timelineHeight-timelineSpacing}}]},Text[Style["Ack2",msgStyle],{11,timelineHeight+0.5}],{Arrowheads[0.03],Red,Dashed,Arrow[{{10,timelineHeight},{12,timelineHeight+timelineSpacing}}]},{Arrowheads[0.03],Red,Dashed,Arrow[{{10,timelineHeight-timelineSpacing},{12,timelineHeight+timelineSpacing}}]},Text[Style["Commit",msgStyle],{14,timelineHeight+0.5}],{Arrowheads[0.03],Blue,Arrow[{{13,timelineHeight+timelineSpacing},{15,timelineHeight}}]},{Arrowheads[0.03],Blue,Arrow[{{13,timelineHeight+timelineSpacing},{15,timelineHeight-timelineSpacing}}]},Text[Style["Committed",Darker[Green],Bold,12],{17.5,timelineHeight}],Text[Style["Committed",Darker[Green],Bold,12],{17.5,timelineHeight-timelineSpacing}]},PlotRange->{{-1,19},{timelineHeight-2 timelineSpacing,timelineHeight+2 timelineSpacing}},ImageSize->700];Column[{Style["5.2 Atomic Transactions on \[CapitalAE]-Link: Commit Protocol Visualizations",Bold,16],Spacer[10],Style["One-Phase Commit: Immediate, single-broadcast commit without acknowledgment (unsafe in failures).",Italic,12],onePhaseGraph,onePhaseTimeline,Spacer[20],Style["Two-Phase Commit: Prepare and Commit phases with acknowledgments to enforce consensus.",Italic,12],twoPhaseGraph,twoPhaseTimeline,Spacer[20],Style["Four-Phase Commit: Adds PreCommit and additional acknowledgments to enable safe abort and rollback.",Italic,12],fourPhaseGraph,fourPhaseTimeline},Spacings->2]]


Module[{coordinator="Coordinator",participant="Participant",tOnePhase=Range[0,3],tTwoPhase=Range[0,5],tFourPhase=Range[0,7],nodeRadius=0.4,yCoordNodes={1,0},drawNode,drawMessage,drawTimeline,drawOnePhaseCommit,drawTwoPhaseCommit,drawFourPhaseCommit,msgStyle=Directive[Black,Thick,Arrowheads[0.04]],labelStyle=Style[#1,FontSize->12,Bold]&,combinedGraphics},drawNode[node_,y_]:=Style[Disk[{0,y},nodeRadius],LightBlue,EdgeForm[Black]];drawNodeLabel[node_,y_]:=Text[labelStyle[node],{0,y-nodeRadius-0.2}];drawMessage[t_,from_,to_,msg_]:=Module[{yFrom,yTo,xPos=t},yFrom=If[from===coordinator,yCoordNodes[[1]],yCoordNodes[[2]]];yTo=If[to===coordinator,yCoordNodes[[1]],yCoordNodes[[2]]];{Arrow[{{xPos,yFrom-Sign[yFrom-yTo] nodeRadius},{xPos,yTo+Sign[yFrom-yTo] nodeRadius}}],Text[labelStyle[msg],{xPos+0.15,(yFrom+yTo)/2}]}];drawTimeline[timeRange_]:={Table[{GrayLevel[0.8],Dashed,Line[{{t,yCoordNodes[[1]]+nodeRadius},{t,yCoordNodes[[2]]-nodeRadius}}]},{t,timeRange}],Table[{Black,Thick,Line[{{timeRange[[1]]-0.5,y},{timeRange[[-1]]+0.5,y}}]},{y,yCoordNodes}]};drawOnePhaseCommit[]:=Module[{t=tOnePhase},Graphics[{drawTimeline[t],drawNode[coordinator,yCoordNodes[[1]]],drawNode[participant,yCoordNodes[[2]]],drawNodeLabel[coordinator,yCoordNodes[[1]]],drawNodeLabel[participant,yCoordNodes[[2]]],drawMessage[t[[2]],coordinator,participant,"Commit"],Text[Style["Commit",Green,Bold,14],{t[[3]],Mean[yCoordNodes]-0.2}]},PlotRange->{{t[[1]]-0.5,t[[-1]]+0.5},{-0.5,1.5}},ImageSize->400,Background->Lighter[Yellow,0.85],PlotLabel->Style["5.2.1 One-Phase Commit",16,Bold]]];drawTwoPhaseCommit[]:=Module[{t=tTwoPhase},Graphics[{drawTimeline[t],drawNode[coordinator,yCoordNodes[[1]]],drawNode[participant,yCoordNodes[[2]]],drawNodeLabel[coordinator,yCoordNodes[[1]]],drawNodeLabel[participant,yCoordNodes[[2]]],drawMessage[t[[2]],coordinator,participant,"Prepare?"],drawMessage[t[[3]],participant,coordinator,"Vote Commit"],drawMessage[t[[4]],coordinator,participant,"Commit"],Text[Style["Commit",Green,Bold,14],{t[[5]],Mean[yCoordNodes]-0.2}]},PlotRange->{{t[[1]]-0.5,t[[-1]]+0.5},{-0.5,1.5}},ImageSize->450,Background->Lighter[LightBlue,0.9],PlotLabel->Style["5.2.2 Two-Phase Commit",16,Bold]]];drawFourPhaseCommit[]:=Module[{t=tFourPhase},Graphics[{drawTimeline[t],drawNode[coordinator,yCoordNodes[[1]]],drawNode[participant,yCoordNodes[[2]]],drawNodeLabel[coordinator,yCoordNodes[[1]]],drawNodeLabel[participant,yCoordNodes[[2]]],drawMessage[t[[2]],coordinator,participant,"Prepare?"],drawMessage[t[[3]],participant,coordinator,"Vote Commit"],drawMessage[t[[4]],coordinator,participant,"Pre-Commit"],drawMessage[t[[5]],participant,coordinator,"Ack Pre-Commit"],drawMessage[t[[6]],coordinator,participant,"Commit"],Text[Style["Commit",Green,Bold,14],{t[[7]],Mean[yCoordNodes]-0.2}]},PlotRange->{{t[[1]]-0.5,t[[-1]]+0.5},{-0.5,1.5}},ImageSize->500,Background->Lighter[LightGreen,0.9],PlotLabel->Style["5.2.3 Four-Phase Commit",16,Bold]]];combinedGraphics=Grid[{{drawOnePhaseCommit[],drawTwoPhaseCommit[],drawFourPhaseCommit[]}},Spacings->{3,2}];combinedGraphics]


a={1,2,4,7,11,15,20,26,33,41};
x1=Range[0,Length[a]-1];
x2=Pick[x1,EvenQ/@x1];
b=Pick[a,EvenQ/@x1];
plt1=ListLinePlot[{Transpose[{x1,a}],Transpose[{x2,b}]},PlotMarkers->{{"\[EmptyCircle]",10},{"\[UpPointer]",12}},PlotStyle->{Black,Darker[Blue]},PlotLegends->{"a","b"},Frame->True,FrameLabel->{"Index","Value"},ImageSize->350,PlotLabel->"Replicating  test.py"];
\[Theta]={1,2,2,3};
\[Gamma]={2,10,5,0.6};
labels={"\[Theta]=1, \[Gamma]=2","\[Theta]=2, \[Gamma]=10","\[Theta]=2, \[Gamma]=5","\[Theta]=3, \[Gamma]=0.6"};
marks={"\[EmptyCircle]","\[DownPointer]","\:2715","\[FilledDiamond]"};
u[x_,\[Theta]_,\[Gamma]_]:=1-Exp[-(x^\[Theta]/(x+\[Gamma]))];
curves=Table[{labels[[i]],marks[[i]],Table[{x,u[x,\[Theta][[i]],\[Gamma][[i]]]},{x,0,9}]},{i,Length[\[Theta]]}];
plt2=ListLinePlot[curves[[All,3]],PlotMarkers->Thread[{curves[[All,2]],11}],PlotLegends->curves[[All,1]],PlotStyle->Thick,Frame->True,FrameLabel->{"Data size  (x)","System income  (u)"},ImageSize->350,PlotLabel->"Replicating  utility.py"];
srv={{20,20},{30,120},{50,250},{70,355},{80,220},{120,140},{150,300},{200,200},{220,300},{250,150},{280,70},{330,200},{350,30},{380,180},{400,400},{200,450},{450,60},{470,160},{475,300},{490,400}};
usr={{50,200},{150,200},{250,200},{350,200},{450,200},{50,400},{150,400},{250,400},{350,400},{450,400}};
SeedRandom[42];
rounds=10;
userSequence=RandomChoice[usr,rounds];
choiceSequence=ConstantArray[{0,0},rounds];
battery=10.;
energy[x_,y_]:=1/20 0.1 Sqrt[x^2+y^2];
utility[t_]:=t/20.;
rewardSeq=ConstantArray[0.,rounds];
Do[Module[{target,best,bestDist=\[Infinity]},target=userSequence[[r]];Do[With[{d=Norm[srv[[i]]-target]},If[d<bestDist,bestDist=d;best=srv[[i]]]],{i,Length[srv]}];choiceSequence[[r]]=best;rewardSeq[[r]]=2 utility[RandomInteger[{0,20}]]-energy@@best;battery-=energy@@best;],{r,rounds}];
pathCoords=Prepend[choiceSequence,{0,0}];
plt3=Graphics[{{Blue,PointSize[0.015],Point[srv]},{Black,PointSize[0.02],Point[usr]},{Red,Thick,Arrow/@Partition[pathCoords,2,1]},{Yellow,EdgeForm[Black],(Disk[#1,6]&)/@Rest[pathCoords]}},PlotRange->{{-10,510},{-10,510}},AspectRatio->1,Frame->True,FrameLabel->{"x (m)","y (m)"},ImageSize->350,PlotLabel->"Toy UAV path \[Dash] 10 greedy hops"];
avgReward=Mean[rewardSeq];
Column[{plt1,plt2,Column[{plt3,Style["Average reward (toy model): "<>ToString[NumberForm[avgReward,{4,3}]],12,Bold]}]},Spacings->2]


GF2Det[matrix_]:=Module[{m=Mod[matrix,2]},Mod[Det[m],2]]
GF2MatrixInverse[matrix_]:=Module[{n=Length[matrix],aug,i,j,pivotRow},aug=ArrayFlatten[{{Mod[matrix,2],IdentityMatrix[n]}}];For[i=1,i<=n,i++,pivotRow=i;While[pivotRow<=n&&aug[[pivotRow,i]]==0,pivotRow++];If[pivotRow>n,Return[$Failed]];If[pivotRow!=i,aug[[{i,pivotRow}]]=aug[[{pivotRow,i}]]];For[j=i+1,j<=n,j++,If[aug[[j,i]]==1,aug[[j]]=Mod[aug[[j]]+aug[[i]],2]]];];For[i=n,i>=1,i--,For[j=i-1,j>=1,j--,If[aug[[j,i]]==1,aug[[j]]=Mod[aug[[j]]+aug[[i]],2]]];];aug[[All,n+1;;2 n]]]
T={{1,0,0,0},{1,1,0,0},{0,1,1,0},{0,0,1,1}};
Print["Determinant mod 2: ",GF2Det[T]];
If[GF2Det[T]!=1,Print["Matrix T is NOT invertible over GF(2). Choose a different matrix."],d={1,0,1,1};GF2MatMul[A_,B_]:=Mod[A . B,2];r=GF2MatMul[T,d];Tinv=GF2MatrixInverse[T];If[Tinv===$Failed,Print["Failed to invert matrix T."],dRecovered=GF2MatMul[Tinv,r];Column[{Style["Original message d:",Bold],d,Style["Transformation matrix T:",Bold],MatrixForm[T],Style["Transmitted vector r = T\[CenterDot]d:",Bold],r,Style["Inverse matrix T^{-1}:",Bold],MatrixForm[Tinv],Style["Recovered message dRecovered = T^{-1}\[CenterDot]r:",Bold],dRecovered,Style["Recovery successful? ",Bold],If[dRecovered==d,Style["Yes, exact recovery.",Darker[Green]],Style["No, recovery failed.",Red]]}]]]


Module[{n=10000,side,coords,adjList,g,startNode=1,bfsQueue,visited,step=0,failedNodes={},failureStep=20,failureCount=50,maxSteps=200,dynamicBFS,nodeRadius=0.3,neighborsOffsets={{-1,-1},{0,-1},{1,-1},{-1,0},{1,0},{-1,1},{0,1},{1,1}},failRandomNodes},side=Ceiling[Sqrt[n]];coords=Association[Table[i->{Mod[i-1,side]+1,Quotient[i-1,side]+1},{i,n}]];adjList=Association[Table[i->Module[{x,y,neighbors},{x,y}=coords[i];neighbors=Select[Flatten[Table[With[{nx=x+dx,ny=y+dy},If[1<=nx<=side&&1<=ny<=side,(ny-1) side+nx,Nothing]],{dx,{-1,0,1}},{dy,{-1,0,1}}]],#1!=i&];neighbors],{i,n}]];failRandomNodes[]:=Module[{candidates},candidates=Complement[Range[n],failedNodes];If[Length[candidates]<failureCount,Return[]];failedNodes=Join[failedNodes,RandomSample[candidates,failureCount]];];visited=Association[Table[i->False,{i,n}]];bfsQueue={startNode};visited[startNode]=True;dynamicBFS=DynamicModule[{localStep=0,localQueue=bfsQueue,localVisited=visited,localFailed=failedNodes,newlyVisited={},toEnqueue={}},Panel[Column[{"Graph Virtual Machine: BFS Traversal and Failure Handling Simulation",Dynamic[Grid[{{"Step",localStep},{"Queue Length",Length[localQueue]},{"Visited Nodes",Count[Values[localVisited],True]},{"Failed Nodes",Length[localFailed]}},Alignment->Left]],Dynamic[Graphics[Module[{shownNodes,nodeColors,edges,shownEdges,failedSet=AssociationThread[localFailed->Table[True,{Length[localFailed]}]],maxDrawNodes=800},shownNodes=Take[Select[Keys[localVisited],localVisited[#1]&&!KeyExistsQ[failedSet,#1]&],UpTo[maxDrawNodes]];nodeColors=Association[Table[i->If[KeyExistsQ[failedSet,i],Red,If[MemberQ[localQueue,i],Blue,Green]],{i,shownNodes}]];edges=Flatten[Table[With[{nbrs=adjList[i]},Table[If[KeyExistsQ[failedSet,nbr]||!MemberQ[shownNodes,nbr],Nothing,Line[{coords[i],coords[nbr]}]],{nbr,nbrs}]],{i,shownNodes}]];shownEdges=edges;Graphics[{({LightGray,Circle[{#1,#2},nodeRadius]}&)@@@coords/@shownNodes,({nodeColors[#1],Disk[coords[#1],nodeRadius]}&)/@shownNodes,{Gray,Thin,shownEdges}},PlotRange->{{0,side+1},{0,side+1}},ImageSize->Large,Background->Black,Frame->True,FrameTicks->None,AspectRatio->1]],UpdateInterval->0.2]],Row[{Button["Next Step",If[localStep==failureStep,failRandomNodes[];localFailed=failedNodes];newlyVisited={};toEnqueue={};If[localQueue==={},MessageDialog["BFS complete or no more nodes to visit."],Module[{current=First[localQueue],neighbors},neighbors=Select[adjList[current],!localVisited[#1]&&!MemberQ[localFailed,#1]&];Do[localVisited[nbr]=True;AppendTo[newlyVisited,nbr];AppendTo[toEnqueue,nbr],{nbr,neighbors}];localQueue=Rest[localQueue];localQueue=Join[localQueue,toEnqueue];];];localStep++;],Button["Reset",localStep=0;localQueue={startNode};localVisited=Association[Table[i->False,{i,n}]];localVisited[startNode]=True;localFailed={};failedNodes={};]}]}]]];dynamicBFS]


Column[{Module[{nodes={"A","B","C","Service1","Service2","Service3"},edges={"A"\[UndirectedEdge]"Service1","B"\[UndirectedEdge]"Service2","C"\[UndirectedEdge]"Service3","A"\[UndirectedEdge]"B","Service1"\[UndirectedEdge]"Service2","Service2"\[UndirectedEdge]"Service3"},g,plotBefore,plotAfter},g=Graph[nodes,edges,VertexLabels->"Name",VertexSize->Medium];plotBefore=Graph[g,ImageSize->350,PlotLabel->Style["Initial Layout",Bold]];plotAfter=Graph[g,VertexCoordinates->{"A"->{0,0},"B"->{1,0},"C"->{5,2},"Service1"->{0,1},"Service2"->{1,1},"Service3"->{4,2}},ImageSize->350,PlotLabel->Style["Layout After AI Policy Translation",Bold]];Grid[{{Style["1. Policy Translation",14,Bold],\[SpanFromLeft]},{plotBefore,plotAfter}},Spacings->2]],Delimiter,Module[{data=RandomReal[1,{50,2}],clusters,plot},clusters=FindClusters[data,3];plot=ListPlot[clusters,PlotStyle->{Red,Green,Blue},PlotMarkers->"OpenMarkers",Frame->True,FrameLabel->{"Resource Axis 1","Resource Axis 2"},ImageSize->400,PlotLabel->Style["AI Suggestion: partition(k-means)",Bold]];Grid[{{Style["2. Optimization Hints",14,Bold]},{plot}}]],Delimiter,Module[{g,compromisedNode={5,5},gIsolated,plotBefore,plotAfter},g=GridGraph[{10,10},VertexLabels->None,VertexSize->Small];plotBefore=HighlightGraph[g,{Style[compromisedNode,Red,PointSize[Large]]},ImageSize->350,PlotLabel->Style["Fabric with Compromised Node",Bold]];gIsolated=EdgeDelete[g,compromisedNode\[UndirectedEdge]_];plotAfter=HighlightGraph[gIsolated,{Style[compromisedNode,Red,PointSize[Large]]},ImageSize->350,PlotLabel->Style["AI Action: Isolate Node",Bold]];Grid[{{Style["3. Security Monitoring & Isolation",14,Bold],\[SpanFromLeft]},{plotBefore,plotAfter}},Spacings->2]],Delimiter,Module[{g1,g2,barbellGraph,bottleneckEdge,plot},g1=CompleteGraph[7];g2=CompleteGraph[7];bottleneckEdge=First[VertexList[g1]]\[UndirectedEdge]First[VertexList[g2]];barbellGraph=Graph[Join[VertexList[g1],VertexList[g2]],Join[EdgeList[g1],EdgeList[g2],{bottleneckEdge}],GraphLayout->"SpringElectricalEmbedding",ImageSize->400];plot=HighlightGraph[barbellGraph,{Style[bottleneckEdge,Red,Thick,Opacity[1]]},PlotLabel->Style["AI Debugging: Bottleneck Detected",Bold]];Grid[{{Style["4. Graph Debugging",14,Bold]},{plot}}]]},Spacings->3]


Module[{gridSize=6,g,startNode=1,endNode,pathBefore,pathAfter,failedLinks,criticalNodes},g=GridGraph[{gridSize,gridSize},VertexLabels->None,VertexSize->0.3,EdgeStyle->{LightGray,Thin}];endNode=gridSize^2;SeedRandom[123];pathBefore=FindShortestPath[g,startNode,endNode];failedLinks=RandomSample[EdgeList[g],5];pathAfter=FindShortestPath[EdgeDelete[g,failedLinks],startNode,endNode];criticalNodes={startNode,endNode};HighlightGraph[g,{Style[UndirectedEdge@@@Partition[pathBefore,2,1],Gray,Dashed],Style[UndirectedEdge@@@Partition[pathAfter,2,1],Green,Thick],Style[failedLinks,Red,Dashed],Style[criticalNodes,Orange,PointSize[Large]]},VertexLabels->None,ImageSize->500,PlotLabel->Style["Self-Healing in an N2N Lattice",Bold,16],PlotLegends->Placed[LineLegend[{Green,Gray,Red},{"Healed Path","Original Path","Failed Link"}],{Left,Top}]]]


startDate={2025,1,1};
todayDate=Date[];
wednesdays=DateRange[startDate,todayDate,"Wednesday"];
numWednesdays=Length[wednesdays];
wedTable=Dataset[Table[Association["Label"->"Wednesday "<>ToString[i],"Date"->DateString[wednesdays[[i]],"ISODate"]],{i,numWednesdays}]];
Print["Number of Wednesdays since 2025-01-01 (inclusive): ",numWednesdays];
wedTable


Module[{metricsLabels={"Latency (\[Micro]s)","Failure Domain (nodes)","Scaling Capacity (nodes)"},kubernetesValues={20,32,1000},gvmValues={0.075,8,10000},configText,operationText,securityText,netVertices,netEdges,failedNodes,failedEdges,graphCoords,netGraph,styledGraph,kubColor=RGBColor[0.2,0.4,0.8],gvmColor=RGBColor[0.9,0.3,0.2]},configText=Grid[{{"Configuration:","Manual YAML, CNI plugins","Self-partitioning graph ops"},{"Operation:","Human-tuned schedulers","Fully autonomous"},{"Security:","Declarative + fragile","Dynamic + confined"}},Frame->All,Spacings->{2,1},Alignment->Left,Background->{None,{Lighter[Gray,0.9],None,None}}];operationText=Style["Configuration and Operation Comparison",Bold,14];netVertices=Range[25];graphCoords=Association[Table[i->{Mod[i-1,5]+RandomReal[{-0.1,0.1}],5-Quotient[i-1,5]+RandomReal[{-0.1,0.1}]},{i,netVertices}]];netEdges=Flatten[Table[{If[Mod[i,5]!=0,i\[UndirectedEdge]i+1,Sequence@@{}],If[i<=20,i\[UndirectedEdge]i+5,Sequence@@{}]},{i,netVertices}],1];failedNodes={7,8,12};failedEdges=Select[netEdges,MemberQ[failedNodes,#1[[1]]]||MemberQ[failedNodes,#1[[2]]]&];netGraph=Graph[netVertices,netEdges,VertexCoordinates->graphCoords,VertexSize->Medium,VertexLabels->Placed["Name",Center],EdgeStyle->Directive[Gray,Thin],VertexStyle->Directive[LightBlue],ImageSize->400,PlotRangePadding->Scaled[0.1],GraphHighlight->failedNodes,GraphHighlightStyle->Directive[Red,Thick]];styledGraph=Show[netGraph,Graph[failedNodes,failedEdges,VertexStyle->Red,EdgeStyle->{Red,Thick},VertexSize->Large],PlotLabel->Style["Hypothetical GVM Deployment on Mars\n(Resilient, Low-latency, Self-operating Network)",Bold,14],ImageSize->Large];(Row[{#1,Spacer[20],configText,Spacer[20],styledGraph}]&)[BarChart[{kubernetesValues,gvmValues},ChartLabels->Placed[metricsLabels,Below],ChartStyle->{kubColor,gvmColor},BarSpacing->0.4,ChartLegends->Placed[{"Kubernetes/Clos","GVM/IPU"},Above],PlotLabel->Style["Key Metric Comparison",Bold,14],ImageSize->450,Frame->True,FrameTicks->{{Automatic,None},{Automatic,None}},BaseStyle->{FontFamily->"Arial",FontSize->12},ScalingFunctions->{"Log10",None}]]]


Module[{n=4,randomInvertibleMatrix,T1,T2,T1inv,T2inv,v0,v1,v2,vRollback,snakeDiagram,gGraph,G,L,eigenValues,lambda2,fitoTimeline,reversibleTimeline,txtStyle=Directive[FontFamily->"Arial",FontSize->12]},randomInvertibleMatrix[dim_]:=Module[{m},While[True,m=RandomInteger[{0,1},{dim,dim}];If[Mod[Det[m],2]==1,Return[m]]]];f2MatMul[a_,b_]:=Mod[a . b,2];T1=randomInvertibleMatrix[n];T2=randomInvertibleMatrix[n];T1inv=Inverse[T1,Modulus->2];T2inv=Inverse[T2,Modulus->2];v0=RandomInteger[{0,1},{n,1}];v1=f2MatMul[T1,v0];v2=f2MatMul[T2,v1];vRollback=f2MatMul[T1inv,f2MatMul[T2inv,v2]];snakeDiagram=Graphics[{Thick,Blue,Circle[{0.5,0.5},0.4],Arrowheads[0.06],Green,Arrow[Circle[{0.5,0.5},0.4,{\[Pi]/4,(3 \[Pi])/2}]],Text[Style["Head(Tv)",Bold,Green],{0.5,1.1}],Red,Arrow[Circle[{0.5,0.5},0.4,{(3 \[Pi])/2,\[Pi]/4}]],Text[Style["Tail(T\:207b\.b9)",Bold,Red],{0.5,-0.1}]},ImageSize->250,PlotLabel->Style["Transaction Circulation Model",Bold]];gGraph=Graph[{1, 2, 3, 4}, {UndirectedEdge[1, 2], UndirectedEdge[2, 3], UndirectedEdge[3, 4], UndirectedEdge[4, 1], UndirectedEdge[1, 3], UndirectedEdge[2, 4]}, {GraphLayout -> "SpringElectricalEmbedding", VertexLabels -> {"Name"}}];L=GraphLaplacianMatrix[gGraph];eigenValues=Sort[Eigenvalues[N[L]]];lambda2=If[Length[eigenValues]>=2,eigenValues[[2]],0];G=Show[gGraph,EdgeStyle->Thick,ImageSize->Medium,PlotLabel->Style["Reversible Transaction Graph",Bold,14]];fitoTimeline=Graphics[{Text[Style["FITO: Forward-Only",Bold,12],{1.5,1}],Red,Thick,Arrowheads[0.05],Arrow[{{0,0.5},{4,0.5}}],Table[{Black,Line[{{t,0.4},{t,.6}}],Text[Style["Op"<>ToString[i],12],{t,.75}]},{i,1,4},{t,i-1}]},PlotRange->{{-0.5,4.5},{0,1.2}},ImageSize->300];reversibleTimeline=Graphics[{Text[Style["Daedaelus: Reversible",Bold,12],{1.5,1}],Blue,Thick,Arrowheads[0.05],Arrow[{{0,0.5},{2,0.5}}],Red,Dashed,Arrow[{{2,0.5},{0,0.5}}],Table[{Black,Line[{{t,0.4},{t,.6}}],Text[Style["Op"<>ToString[i],12],{t,.75}]},{i,1,2},{t,i-1}],Text[Style["Rollback Possible",Italic,Red],{1,.2}]},PlotRange->{{-0.5,4.5},{0,1.2}},ImageSize->300];Column[{Style["5.14 Rethinking Atomicity: Counterfactual Transactions",Bold,18,FontFamily->"Helvetica"],Spacer[10],Grid[{{Column[{Style["Mathematical Formulation over \|01d53d\:2082\:207f:",Bold,14],Grid[{{"Initial State v\:2080:",MatrixForm[v0]},{"Forward Transform T\:2081:",MatrixForm[T1]},{"Forward Transform T\:2082:",MatrixForm[T2]},{"Transformed v\:2082 = T\:2082\[CenterDot]T\:2081\[CenterDot]v\:2080:",MatrixForm[v2]},{"Reversed State:",Column[{MatrixForm[vRollback],Style["Perfect Recovery!",Green,Bold]},Alignment->Center]}},Frame->All,Spacings->{1,1},Alignment->Left,ItemStyle->txtStyle]}],Column[{Style["Transaction Models:",Bold,14],snakeDiagram,Spacer[10],G,Style[StringForm["Resilience Metric: \[Lambda]\:2082(G) = ``", NumberForm[lambda2, {3, 2}]],Bold,14,Darker[Green,.2]]},Alignment->Center]}},BaseStyle->{12,"Panel"}],Spacer[20],Style["Timeline Comparison: FITO vs Reversible Causality",Bold,14],Row[{fitoTimeline,Spacer[20],reversibleTimeline},Alignment->Center]},Spacings->2,Alignment->Center]]


Module[{frameSlices=8,sackColors={Lighter[Blue,.7],Lighter[Green,.6],Lighter[Orange,.6],Lighter[Red,.6]},pipeHeight=.5,sliceWidth=1,txY=3,rxY=1,layers={{"00","Information\n(Surprisal)"},{"01","Knowledge\n(Buffer Storage)"},{"10","Semantics\n(Meaning & Action)"},{"11","Understanding\n(Syntax)"}},serDesGraf,fourLayerGraf,decTopo,distTopo,antGraf,beeGraf,hlcGraf},drawRow[y_,lab_]:=Module[{rects,lbls},rects=Table[{EdgeForm[Black],FaceForm[LightGray],Rectangle[{(i-1) sliceWidth,y},{i sliceWidth,y+pipeHeight}]},{i,frameSlices}];lbls=Table[Text[Style[i,10,Bold],{(i-.5) sliceWidth,y+pipeHeight/2}],{i,frameSlices}];Join[{Text[Style[lab,14,Bold],{-1.4,y+pipeHeight/2}]},rects,lbls]];serDesGraf=Graphics[{drawRow[txY,"ETHERNET TX"],drawRow[rxY,"ETHERNET RX"],Arrowheads[.03],Blue,Table[Arrow[{{(i-.5) sliceWidth,txY+.7},{(i-.5) sliceWidth,rxY-.2}}],{i,frameSlices}]},PlotRange->{{-2,frameSlices+1},{0,txY+1.2}},ImageSize->500,Background->Lighter[Gray,.95],Axes->False,PlotLabel->Style["6.1  Bidirectional Shannon Channels",14,Bold]];fourLayerGraf=Graphics[Table[{EdgeForm[Black],FaceForm[sackColors[[i]]],Rectangle[{0,i-1},{4,i}],Text[Style[layers[[i,1]],16,White,Bold],{.5,i-.5},{-1,0}],Text[Style[layers[[i,2]],12],{2.6,i-.5}]},{i,4}],PlotRange->{{0,4},{0,4}},ImageSize->330,Background->Lighter[Gray,.9],Axes->False,PlotLabel->Style["6.2  Four Shannon-like Layers",14,Bold]];decTopo=Graph[Join[Table[i->30,{i,1,7}],Table[j->RandomInteger[{1,7}],{j,8,30}]],VertexLabels->"Name",ImageSize->230];distTopo=RandomGraph[{30,60},VertexLabels->"Name",ImageSize->230];antGraf:=Module[{square=Tuples[Range[0,2],2]+1,cw={{1,1},{2,1},{3,1},{3,2},{3,3},{2,3},{1,3},{1,2},{1,1}},ccw=Reverse[{{1,1},{2,1},{3,1},{3,2},{3,3},{2,3},{1,3},{1,2},{1,1}}]},Graphics[{LightGray,EdgeForm[Black],Table[(Rectangle[#1-.5,#1+.5]&)/@square],Blue,Thick,Arrow[cw],Red,Thick,Arrow[ccw],Text[Style["CW",12,Blue],{3.5,1.3}],Text[Style["CCW",12,Red],{3.5,2.7}]},PlotRange->{{.3,4.3},{.3,4.3}},ImageSize->260,PlotLabel->Style["6.6\[Dash]6.7  Race-Free ANT Clock",14,Bold]]];beeGraf:=Module[{out=Table[{x,1},{x,1,6}],back=Table[{x,1.2},{x,6,1,-1}]},Graphics[{Thick,Blue,Arrow[out],Thick,Red,Arrow[back],Text[Style["outbound",11,Blue],{6.8,1}],Text[Style["return",11,Red],{.3,1.25}]},PlotRange->{{0,7},{.7,1.6}},ImageSize->260,PlotLabel->Style["6.9  BEE Scout Path",14,Bold]]];hlcGraf:=Graph[{"Local","Send","Recv"},DirectedEdge@@@{{"Local","Send"},{"Send","Recv"}},VertexLabels->{"Local"->"Local Event","Send"->"Send Msg","Recv"->"Receive Msg"},ImageSize->280,PlotLabel->Style["6.36  Hybrid Logical Clock DAG",14,Bold]];Column[{Style["\[Section]6  Architecture  \[Dash]  Visual Companion",20,Bold,Blue],Spacer[6],serDesGraf,Spacer[6],fourLayerGraf,Spacer[6],Row[{Column[{"Decentralised",decTopo},Center],Spacer[10],Column[{"Distributed",distTopo},Center]}],Spacer[6],antGraf,Spacer[6],beeGraf,Spacer[6],hlcGraf},Spacings->2]]


Module[{routerGraph,preferredPath,deflectedPath,pheromoneLevels,abpStates,abpPlot,forwardSignal,backwardSignal,tsfvPlot,hlcLocal,hlcMessage,hlcUpdate,hlcGrid},routerGraph=Graph[{1, 2, 3, 4, 5, 6, 7}, {UndirectedEdge[1, 2], UndirectedEdge[2, 3], UndirectedEdge[3, 4], UndirectedEdge[4, 5], UndirectedEdge[3, 6], UndirectedEdge[6, 7]}, {VertexLabels -> {"Name"}, VertexCoordinates -> {{0, 0}, {1, 0}, {2, 0}, {3, 0}, {4, 0}, {2, -1}, {3, -1}}}];preferredPath={1,2,3,4,5};deflectedPath={1,2,3,6,7};pheromoneLevels=Association[1->0.5,2->0.7,3->0.9,4->0.3,5->0.1,6->0.6,7->0.8];Print[Graph[routerGraph,GraphHighlight->PathGraph[deflectedPath],GraphHighlightStyle->Directive[Red,Thick],PlotLabel->"Bufferless Deflection Routing with Forced Misrouting"]];abpStates=Mod[Range[0,20],2];abpPlot=ListLinePlot[abpStates,Filling->Bottom,PlotMarkers->Automatic,PlotRange->{0,1},AxesLabel->{"Time","ABP Bit State"},PlotLabel->"Alternating Bit Protocol State Evolution"];Print[abpPlot];forwardSignal=Accumulate[RandomReal[{0,1},20]];backwardSignal=Reverse[forwardSignal]+RandomReal[{-0.1,0.1},20];tsfvPlot=ListLinePlot[{forwardSignal,backwardSignal},PlotStyle->{Blue,Dashed},PlotLegends->{"|\[Psi](t)\:27e9 Forward Propagation","\:27e8\[Phi](t)| Backpropagation"},PlotLabel->"TSVF: Forward and Backward State Vectors",AxesLabel->{"Layer","Activation / Error"}];Print[tsfvPlot];hlcLocal={1000,3};hlcMessage={998,5};hlcUpdate=Module[{pt,ctr},pt=Max[hlcLocal[[1]],hlcMessage[[1]]];ctr=If[pt==hlcMessage[[1]],Max[hlcLocal[[2]],hlcMessage[[2]]]+1,0];{pt,ctr}];hlcGrid=Grid[{{"Local HLC",hlcLocal},{"Message HLC",hlcMessage},{"Updated HLC",hlcUpdate},{"Epistemic Note","Facts can become \[CurlyEpsilon]-common knowledge with bounded clock skew"}},Frame->All,ItemStyle->Directive[Bold,Medium]];Print[hlcGrid];]


Module[{nSlices=8,sliceLabels,txSlices,rxSlices,sackColors,sackLabels,layerColors,layerLabels,pipeGraph,sackGraph,topologyGraphs,antPath,beePath,hlcTimeline,drawPipeSlices,drawSackFeedback,drawFourLayers,drawBidirectionalChannels,drawANTBeeScouting,drawDatacenterTopologies,drawHybridLogicalClock},sliceLabels=Table["Slice "<>ToString[i],{i,nSlices}];sackColors={RGBColor[0.9,0.9,0.9],RGBColor[0.6,0.8,1],RGBColor[0.4,0.6,1],RGBColor[0.2,0.3,0.8]};sackLabels={"SACK 00 (Information)","SACK 01 (Knowledge)","SACK 10 (Semantics)","SACK 11 (Syntax)"};layerColors=sackColors;layerLabels=sackLabels;drawPipeSlices[]:=Module[{txPositions,rxPositions,txLines,rxLines,labels,pipelinePlot},txPositions=Table[{i,2},{i,nSlices}];rxPositions=Table[{i,0},{i,nSlices}];txLines=Line/@Partition[txPositions,2,1];rxLines=Line/@Partition[rxPositions,2,1];labels={Text[Style["ETHERNET TX",Bold,14],{nSlices+1,2}],Text[Style["ETHERNET RX",Bold,14],{nSlices+1,0}]};pipelinePlot=Graphics[{Blue,Thick,txLines,Red,Thick,rxLines,Black,Table[Text[Style["TX "<>sliceLabels[[i]],Blue,12,Italic],txPositions[[i]]+{0,0.2}],{i,nSlices}],Table[Text[Style["RX "<>sliceLabels[[i]],Red,12,Italic],rxPositions[[i]]-{0,0.3}],{i,nSlices}],labels},PlotRange->{{0,nSlices+2},{-1,3}},ImageSize->600,Axes->False];pipelinePlot];drawSackFeedback[pos_]:=Module[{txPos,rxPos,arrows,sackLabel,feedbackArrow},txPos={pos,2};rxPos={pos,0};sackLabel=If[pos==1,"SACK 1 (Feedback on Slice 1)","SACK 8 (Feedback on Slice 8)"];feedbackArrow=Style[Arrow[{rxPos,txPos}],Thick,Green];Graphics[{Blue,Disk[txPos,0.15],Text[Style["TX Slice "<>ToString[pos],Blue,12],txPos+{0,0.3}],Red,Disk[rxPos,0.15],Text[Style["RX Slice "<>ToString[pos],Red,12],rxPos-{0,0.4}],feedbackArrow,Black,Text[Style[sackLabel,Bold,14],{pos,2.5}]},PlotRange->{{pos-1,pos+1},{-1,3}},ImageSize->300,Axes->False]];drawFourLayers[]:=Module[{layerBoxes,yBase=0,nLayers=4,width=6,height=1.2,graphicsObjects={}},layerBoxes=Table[{layerColors[[i]],Rectangle[{0,yBase+(i-1) height},{width,yBase+i height}],Black,Text[Style[layerLabels[[i]],Bold,14],{width/2,yBase+(i-0.5) height}]},{i,nLayers}];Graphics[layerBoxes,PlotRange->{{-1,width+1},{yBase-1,yBase+nLayers height+1}},ImageSize->500,Axes->False]];drawBidirectionalChannels[]:=Module[{txY=3,rxY=0,sliceXPositions=Range[1,nSlices],sackPositions={1,3,5,7},graphicsObjects={},arrows={},labels={}},graphicsObjects=Join[Table[{Blue,Rectangle[{x-0.4,txY-0.4},{x+0.4,txY+0.4}],Black,Text[Style["TX "<>ToString[x],White,12],{x,txY}]},{x,nSlices}],Table[{Red,Rectangle[{x-0.4,rxY-0.4},{x+0.4,rxY+0.4}],Black,Text[Style["RX "<>ToString[x],White,12],{x,rxY}]},{x,nSlices}],Table[{Green,Arrow[{{x,txY-0.4},{x,rxY+0.4}}],Black,Text[Style["SACK "<>IntegerString[Floor[(x+1)/2],2,2],Bold,12],{x,(txY+rxY)/2}]},{x,sackPositions}]];Graphics[graphicsObjects,PlotRange->{{0,nSlices+1},{-1,txY+1}},ImageSize->700,Axes->False]];drawANTBeeScouting[]:=Module[{gridSize=7,gridPoints,antPathPoints,beePathPoints,antPathGraphics,beePathGraphics,antColor=Orange,beeColor=Purple},gridPoints=Flatten[Table[{x,y},{x,1,gridSize},{y,1,gridSize}],1];antPathPoints={{4,4},{5,4},{5,5},{6,5},{6,6}};beePathPoints={{1,1},{1,2},{1,3},{1,4},{1,5},{1,6},{1,7}};antPathGraphics={antColor,Thick,Arrow[antPathPoints]};beePathGraphics={beeColor,Thick,Arrow[beePathPoints]};Graphics[{LightGray,PointSize[Large],Point[gridPoints],antPathGraphics,beePathGraphics,Black,Text[Style["ANT Scout Path",antColor,Bold],{5,6.5}],Text[Style["BEE Scout Path",beeColor,Bold],{1,7.5}]},PlotRange->{{0,gridSize+1},{0,gridSize+2}},Frame->True,ImageSize->400]];drawDatacenterTopologies[]:=Module[{centralized,decentralized,distributed,g1,g2,g3,styleCentralized,styleDecentralized,styleDistributed},g1=Graph[StarGraph[10],VertexLabels->"Name",GraphStyle->"NameLabeled",ImageSize->250];g2=Graph[{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, {UndirectedEdge[1, 2], UndirectedEdge[1, 3], UndirectedEdge[1, 4], UndirectedEdge[5, 6], UndirectedEdge[5, 7], UndirectedEdge[8, 9], UndirectedEdge[8, 10], UndirectedEdge[1, 5], UndirectedEdge[5, 8]}, {ImageSize -> 300, VertexLabels -> {"Name"}}];g3=GridGraph[{4,4},VertexLabels->"Name",ImageSize->350];Grid[{{Style["Centralized Topology (Single Hub)",Bold,14],Style["Decentralized Topology (Multiple Hubs)",Bold,14],Style["Distributed Topology (Mesh)",Bold,14]},{g1,g2,g3}},Spacings->{3,2}]];drawHybridLogicalClock[]:=Module[{events={{1,0,"e1 (local event)"},{2,0,"e2 (local event)"},{3,1,"e3 (message receive)"},{4,0,"e4 (local event)"}},hlcGraphics},hlcGraphics=Graphics[{Blue,PointSize[Large],(Point[{#1[[1]],#1[[2]]}]&)/@events,Black,Table[Text[Style[events[[i,3]],Italic,12],events[[i,{1,2}]]+{0,0.3}],{i,Length[events]}],Red,Arrow[{{1,0},{2,0}}],Arrow[{{2,0},{3,1}}],Arrow[{{3,1},{4,0}}]},PlotRange->{{0,5},{-0.5,2}},Axes->True,AxesLabel->{"Physical Time (pt)","Counter (ctr)"},ImageSize->400];hlcGraphics];Grid[{{Style["1. Two Independent Metcalfe Channels",Bold,16]},{drawPipeSlices[]},{Style["2. SACK Feedback on First and Last Slice",Bold,16]},{Row[{drawSackFeedback[1],Spacer[50],drawSackFeedback[8]}]},{Style["3. Four Shannon-like Layers",Bold,16]},{drawFourLayers[]},{Style["4. Bidirectional Full-Duplex Shannon-Metcalfe Channel",Bold,16]},{drawBidirectionalChannels[]},{Style["5. ANT and BEE Scout Routing on 2D Grid",Bold,16]},{drawANTBeeScouting[]},{Style["6. Datacenter Topologies",Bold,16]},{drawDatacenterTopologies[]},{Style["7. Hybrid Logical Clock (HLC) Timeline",Bold,16]},{drawHybridLogicalClock[]}},Spacings->{0,3},Alignment->Center]]


Module[{slices=Range[8],txColor=RGBColor[0.2,0.4,0.8],rxColor=RGBColor[0.1,0.7,0.3],sackColors={RGBColor[0.3,0.5,0.9],RGBColor[0.3,0.7,0.4],RGBColor[0.9,0.5,0.2],RGBColor[0.9,0.3,0.3]},sackLabels={"00","01","10","11"},sackMeaning={"Information","Knowledge","Semantics","Syntax"},antPathCW,antPathCCW,beeOutbound,beeReturn,centralGraph,decentralGraph,distributedGraph,hlcEvents,hlcPlot},metcalfePlot=Graphics[{Table[{txColor,Rectangle[{i,3},{i+0.8,4}],Black,Text["TX Slice "<>ToString[i],{i+0.4,3.5}]},{i,slices}],Table[{rxColor,Rectangle[{i,1},{i+0.8,2}],Black,Text["RX Slice "<>ToString[i],{i+0.4,1.5}]},{i,slices}],Style[Text["6.1.1 Two Independent Metcalfe Channels (Max Flow, No Interaction)",{4.5,4.5}],Bold,14]},PlotRange->{{0.5,9},{0.5,4.5}},ImageSize->600];sackFeedbackPlot[n_]:=Graphics[{Table[{txColor,Rectangle[{i,3},{i+0.8,4}],Black,Text["TX Slice "<>ToString[i],{i+0.4,3.5}]},{i,slices}],Table[{rxColor,Rectangle[{i,1},{i+0.8,2}],Black,Text["RX Slice "<>ToString[i],{i+0.4,1.5}]},{i,slices}],{Red,Thick,Arrow[{{n+0.4,4.2},{n+0.4,4.8}}]},{Red,Style[Text["SACK"<>ToString[n],{n+0.4,5}],Bold,14]},Style[Text["6.1.2/6.1.3 Internal (SACK) Feedback on slice "<>ToString[n],{4.5,5.5}],Bold,14]},PlotRange->{{0.5,9},{0.5,6}},ImageSize->600];fourLevelsPlot=Graphics[{Table[{sackColors[[i]],Rectangle[{0,i-1},{4,i}],Black,Style[Text[sackMeaning[[i]]<>" (SACK "<>sackLabels[[i]]<>")",{2,i-0.5}],Bold,14]},{i,4}],Style[Text["6.2 Architectural Framework: Four Shannon-like Levels",{2,4.5}],Bold,14]},PlotRange->{{0,4},{0,4}},ImageSize->400,Axes->False];fullDuplexPlot=Graphics[{Table[{txColor,Rectangle[{i,4},{i+0.8,5}],Black,Text["TX Slice "<>ToString[i],{i+0.4,4.5}]},{i,slices}],Table[{rxColor,Rectangle[{i,1},{i+0.8,2}],Black,Text["RX Slice "<>ToString[i],{i+0.4,1.5}]},{i,slices}],Table[{Purple,Arrowheads[0.03],Arrow[{{i+0.4,4},{i+0.4,2}}]},{i,slices}],Table[Style[Text["SACK "<>sackLabels[[i]],{i 2-0.6,If[i<=2,5.4,0.8]}],Bold,12],{i,4}],Style[Text["6.3 Full-Duplex Bi-Pipelined Shannon-Metcalfe Channel",{4.5,6}],Bold,14]},PlotRange->{{0.5,8.5},{0.5,6}},ImageSize->700];antGridSize=3;antPoints=Flatten[Table[{x,y},{x,1,antGridSize},{y,1,antGridSize}],1];antEdgesCW={{1,2},{2,3},{3,6},{6,9},{9,8},{8,7},{7,4},{4,1}};antEdgesCCW=Reverse[antEdgesCW];antClockwise=Graph[UndirectedEdge@@@antEdgesCW,VertexCoordinates->antPoints,VertexSize->Medium,EdgeStyle->Blue,GraphStyle->"NameLabeled"];antCounterClockwise=Graph[UndirectedEdge@@@antEdgesCCW,VertexCoordinates->antPoints,VertexSize->Medium,EdgeStyle->Red,GraphStyle->"NameLabeled"];beeLength=6;beeOutboundPath=Table[{i,1},{i,1,beeLength}];beeReturnPath=Reverse[beeOutboundPath];beePlot=Graphics[{Blue,Thick,Arrow[beeOutboundPath],Red,Thick,Arrow[beeReturnPath],Black,PointSize[Large],Point/@beeOutboundPath,Style[Text["Outbound",{beeLength+0.5,1}],Blue,Bold],Style[Text["Return",{0.5,1}],Red,Bold],Style[Text["6.9 BEE Scouts: Radial Exploration & Return",{beeLength/2,1.5}],Bold,14]},PlotRange->{{0,beeLength+1},{0.5,1.8}},ImageSize->600];centralGraph=Graph[Table[i->0,{i,1,46}],VertexLabels->"Name",GraphLayout->"StarEmbedding",PlotLabel->"6.31 Centralized Topology"];decentralGraph=RandomGraph[{47,60},GraphLayout->"SpringElectricalEmbedding",PlotLabel->"6.31 Decentralized Topology"];distributedGraph=RandomGraph[{47,98},GraphLayout->"SpringElectricalEmbedding",PlotLabel->"6.31 Distributed Topology"];SeedRandom[1234];hlcEvents=Table[{i,RandomReal[{i 5,i 5+2}],RandomInteger[{0,2}]},{i,1,20}];hlcPlot=ListPlot[hlcEvents[[All,{1,2}]],PlotStyle->PointSize[Medium],AxesLabel->{"Event Index","HLC Physical Time"},PlotLabel->"6.36 Hybrid Logical Clock: Event Timestamps",ImageSize->600];Column[{metcalfePlot,sackFeedbackPlot[8],sackFeedbackPlot[1],fourLevelsPlot,fullDuplexPlot,GraphicsGrid[{{antClockwise,antCounterClockwise}},ImageSize->600,Spacings->{2,2}],beePlot,GraphicsRow[{centralGraph,decentralGraph,distributedGraph},ImageSize->800],hlcPlot},Spacings->3]]


Module[{ethernetGraphics,triangleGraph,tileGraph,closGraph,meshGraph,sampleGraph,A,D,L,eigvals,lambda2,edges,lambda2Values},ethernetGraphics=Graphics[{Style[Text["Ethernet Segment #1",{1,2}],Bold,14,Blue],Style[Text["Ethernet Segment #2",{5,2}],Bold,14,Blue],Thick,Blue,Line[{{0,1},{3,1}}],Style[Text["Coax Cable",{1.5,1.3}],Italic,12],Line[{{3.5,1},{7,1}}],Style[Text["Coax Cable",{5,1.3}],Italic,12],Red,Disk[{0,1},0.1],Style[Text["Terminator",{-0.5,1}],Bold,Red,12],Black,Rectangle[{3,0.8},{3.5,1.2}],Style[Text["TAP",{3.25,1.5}],Bold,Black,12],Orange,Rectangle[{3.75,0.8},{4.25,1.2}],Style[Text["Repeater",{4,1.5}],Bold,Orange,12],Style[Text["Station 1",{1,0.5}],Bold,Darker[Green]],Style[Text["Station 2",{6,0.5}],Bold,Darker[Green]]},PlotRange->{{-1,8},{0,3}},ImageSize->500,Axes->False];triangleGraph=Graph[{"Alice", "Bob", "Charlie"}, {UndirectedEdge["Alice", "Bob"], UndirectedEdge["Bob", "Charlie"], UndirectedEdge["Charlie", "Alice"]}, {GraphLayout -> "CircularEmbedding", PlotLabel -> "Minimum Triangle: Fault-Tolerant Chiplet XPU Links", VertexLabels -> {"Name"}, VertexSize -> {Large}}];tileGraph=Graph[Flatten[Table[i+3 (j-1),{i,3},{j,3}]],UndirectedEdge@@@Select[Subsets[Range[9],{2}],(Abs[#1[[1]]-#1[[2]]]==1&&Quotient[#1[[1]]-1,3]==Quotient[#1[[2]]-1,3])||Abs[#1[[1]]-#1[[2]]]==3&],VertexLabels->"Name",GraphLayout->"GridEmbedding",PlotLabel->"3\[Times]3 Logical Tile",VertexSize->Medium];sampleGraph=RandomGraph[{10,15}];edges=EdgeList[sampleGraph];lambda2Values=Table[Module[{subg,conn},subg=EdgeDelete[sampleGraph,Take[edges,k]];conn=If[VertexCount[subg]>1&&EdgeCount[subg]>0,Sort[Eigenvalues[N[LaplacianMatrix[subg]]]],{0}];SelectFirst[conn,#1>1/1000000000&,0]],{k,0,Length[edges]}];closGraph=Graph[Join[Table["Server"<>ToString[i]->"ToR"<>ToString[Ceiling[i/10]],{i,1,20}],Flatten[Table["ToR"<>ToString[i]->"Spine"<>ToString[j],{i,1,2},{j,1,4}],1]],GraphLayout->"SpringElectricalEmbedding",PlotLabel->"Simplified Clos Topology",ImageSize->Large];meshGraph=Graph[RegularGraph[8,40],PlotLabel->"Simplified 8-Regular Mesh Topology",ImageSize->Large];Column[{ethernetGraphics,triangleGraph,tileGraph,ListLinePlot[lambda2Values,PlotRange->All,AxesLabel->{"Number of Removed Edges","Algebraic Connectivity \[Lambda]\:2082"},PlotLabel->"Resilience Metric R(k): \[Lambda]\:2082 vs. Edge Removal",ImageSize->500],closGraph},Spacings->2]]


Module[{asyncGraph,fifoGraph,coGraph,rscGraph,fabrics={"NVLink v3","UALink (proj.)","Scale-Up ETH","InfiniBand HDR","Ethernet + IP + TCP"},headers={16,20,12,64,76},blockSizes={64,128,256,512,1024},overheadData,compFeatures,compValuesEthernet,compValuesInfiniBand},asyncGraph=Graph[DirectedEdge@@@{{"SendA","RecvB"},{"SendC","RecvD"},{"SendB","RecvC"}},VertexLabels->"Name",GraphStyle->"NameLabeled",ImageSize->300,PlotLabel->"Asynchronous (A) - No ordering constraints"];fifoGraph=Graph[DirectedEdge@@@{{"Send1","Recv1"},{"Send2","Recv2"},{"Send1","Send2"},{"Recv1","Recv2"}},VertexLabels->"Name",GraphStyle->"NameLabeled",ImageSize->300,PlotLabel->"FIFO: Per-channel ordering (send order \[DoubleRightArrow] receive order)"];coGraph=Graph[DirectedEdge@@@{{"Send1","Recv1"},{"Send2","Recv2"},{"Send1","Send2"},{"Recv1","Recv2"},{"Send1","Recv2"}},VertexLabels->"Name",GraphStyle->"NameLabeled",ImageSize->300,PlotLabel->"Causally Ordered (CO): causal ordering globally enforced"];rscGraph=Graph[DirectedEdge@@@{{"Send1","Recv1"},{"Send2","Recv2"},{"Send1","Recv1"},{"Send2","Recv2"}},VertexLabels->"Name",GraphStyle->"NameLabeled",ImageSize->300,PlotLabel->"RSC: Rendezvous (send immediately followed by receive)"];Print[Grid[{{asyncGraph,fifoGraph},{coGraph,rscGraph}},Spacings->{2,2}]];overheadData={{0.25,0.125,0.0625,0.03125,0.015625},{0.313,0.156,0.078,0.039,0.02},{0.125,0.063,0.031,0.016,0.008},{1,0.5,0.25,0.125,0.063},{1.438,0.578,0.289,0.145,0.071}};Print[BarChart[Transpose[overheadData],ChartLabels->Placed[ToString/@blockSizes,"Below"],ChartLegends->fabrics,PlotLabel->"8.2 Header Overhead vs Block Size",Frame->True,FrameLabel->{"Block Size (Bytes)","Header Overhead Ratio"},ImageSize->Large,PlotRange->{0,1.6}]];compFeatures={"Reliability","Latency","Jitter","Congestion Control","Packet Loss","RDMA Support","CPU Overhead","Primary Use"};compValuesEthernet={"Best-effort (via TCP)","Milliseconds typical","High","Optional (DCB/PFC)","Possible","RoCE (complex)","High (software stack)","General networking"};compValuesInfiniBand={"Hardware-enforced","Microseconds scale","Very low","Built-in","Avoided by design","Native","Low (hardware offload)","HPC, AI, low-latency clusters"};Print[Grid[Prepend[Transpose[{compFeatures,compValuesEthernet,compValuesInfiniBand}],{"Feature","Ethernet (traditional)","InfiniBand"}],Frame->All,Background->{None,{LightGray,White}},Spacings->{3,1},ItemStyle->Directive[FontFamily->"Arial",FontSize->12]]];]


commModelHierarchy:=Module[{models={"A (Asynchronous)","FIFO","CO (Causal Order)","RSC (Rendezvous/Synchronous)"},pos,edges,labels},pos=Association["A (Asynchronous)"->{0,0},"FIFO"->{1,1},"CO (Causal Order)"->{2,2},"RSC (Rendezvous/Synchronous)"->{3,3}];edges={"RSC (Rendezvous/Synchronous)"->"CO (Causal Order)","CO (Causal Order)"->"FIFO","FIFO"->"A (Asynchronous)"};Graph[models,DirectedEdge@@@List@@@edges,VertexCoordinates->Values[pos],VertexLabels->"Name",GraphStyle->"NameLabeled",EdgeStyle->Arrowheads[0.02],ImageSize->400,PlotLabel->Style["Communication Model Inclusion Hierarchy\nRSC \[Subset] CO \[Subset] FIFO \[Subset] A",Bold,14]]];
headerOverheadData={{"NVLink v3",16,{0.25,0.125,0.0625,0.03125,0.015625}},{"UALink (proj.)",20,{0.313,0.156,0.078,0.039,0.02}},{"Scale-Up Ethernet",8,{0.125,0.063,0.031,0.016,0.008}},{"InfiniBand HDR",64,{1,0.5,0.25,0.125,0.063}},{"Ethernet + IP + TCP",84,{1.438,0.578,0.289,0.145,0.071}}};
blockSizes={64,128,256,512,1024};
headerOverheadChart:=BarChart[Transpose[headerOverheadData[[All,3]]],ChartLabels->Placed[blockSizes,"Below"],ChartLegends->Placed[headerOverheadData[[All,1]],"Right"],BarSpacing->0.5,PlotRange->{0,1.5},Frame->True,FrameLabel->{"Block Size (Bytes)","Header Overhead (Fraction)"},PlotLabel->Style["Header Overhead vs. Block Size for Link Fabrics",Bold,14],ImageSize->600];
featureComparisonData={{"Reliability",{"Best-effort (TCP)","Hardware-enforced"}},{"Latency",{"Milli-second typical","Micro-second typical"}},{"Jitter",{"High","Very low"}},{"Congestion Control",{"Optional (DCB/PFC)","Built-in"}},{"Packet Loss",{"Possible","Avoided by design"}},{"RDMA Support",{"RoCE (complex)","Native"}},{"CPU Overhead",{"High (software stack)","Low (hardware offload)"}},{"Use Case",{"General networking","HPC, AI clusters"}}};
featureComparisonChart:=Grid[Prepend[({#1[[1]],Style[#1[[2,1]],Red],Style[#1[[2,2]],Blue]}&)/@featureComparisonData,{Style["Feature",Bold,14],Style["Ethernet",Bold,14,Red],Style["InfiniBand",Bold,14,Blue]}],Frame->All,Background->{None,{LightYellow,LightCyan}},Spacings->{3,2},Alignment->Left];
Column[{Style["1. Communication Model Hierarchy",Bold,16],commModelHierarchy,Style["2. Header Overhead vs. Block Size",Bold,16],headerOverheadChart,Style["3. Feature Comparison: Ethernet vs InfiniBand",Bold,16],featureComparisonChart},Spacings->3]


Module[{vertices,edges,g,crownCycleVertices,crownCycleEdges},vertices=Flatten[Table[{"s"<>ToString[i],"r"<>ToString[i]},{i,0,3}]];edges=Flatten[Table[{"s"<>ToString[i]\[DirectedEdge]"r"<>ToString[i],"r"<>ToString[i]\[DirectedEdge]"s"<>ToString[Mod[i+1,4]]},{i,0,3}]];crownCycleVertices=vertices;crownCycleEdges=edges;g=Graph[edges,VertexLabels->Placed["Name",Center],DirectedEdges->True,VertexSize->Medium,GraphStyle->"NameLabeled",PlotLabel->Style["Crown Criterion: Alternating Send/Receive Dependency Cycle",Bold,14],ImageSize->600];Show[g,GraphHighlight->crownCycleVertices,GraphHighlightStyle->{Red,Thick}]]
Module[{blockSizes={64,128,256,512,1024},fabrics={"NVLink v3"->{25.0,12.5,6.3,3.1,1.6},"UALink (proj.)"->{31.3,15.6,7.8,3.9,2.0},"Scale-Up ETH"->{12.5,6.3,3.1,1.6,0.8},"InfiniBand HDR"->{100,50,25,12.5,6.3},"Ethernet + IP + TCP"->{143.8,57.8,28.9,14.5,7.1}},colors,plots},colors=ColorData[97,"ColorList"];plots=Table[ListLinePlot[Transpose[{blockSizes,fabrics[[i,2]]}],PlotMarkers->Automatic,Joined->True,PlotStyle->{colors[[i]],Thick},PlotRange->All,AxesLabel->{"Block Size (Bytes)","Header Overhead (%)"},ScalingFunctions->{"Log10",None},PlotLegends->None],{i,Length[fabrics]}];Show[plots,PlotRange->All,Frame->True,FrameLabel->{"Block Size (Bytes, log scale)","Header Overhead (%)"},GridLines->Automatic,PlotLabel->Style["Header Overhead vs Block Size for Various Link Fabrics",Bold,14],ImageSize->Large,PlotLegends->Placed[SwatchLegend[colors,fabrics[[All,1]]],Below]]]
Module[{nodes={"NIC_Alice","NIC_Bob","Switch1","Switch2"},edges={"NIC_Alice"<->"Switch1","NIC_Bob"<->"Switch2","Switch1"<->"Switch2"},pos,graph},pos=Association["NIC_Alice"->{0,1},"NIC_Bob"->{3,1},"Switch1"->{1,0},"Switch2"->{2,0}];graph=Graph[edges,VertexLabels->"Name",VertexSize->Medium,DirectedEdges->False,GraphStyle->"NameLabeled"];Show[Graph[graph,VertexCoordinates->pos,PlotLabel->Style["RoCE Deployment: NICs and Switches in Lossless Fabric",Bold,14],ImageSize->Large],Graphics[{Red,Thick,Dashed,Arrow[{{0.5,0.6},{1,0.2}}],Text[Style["PFC / Lossless Fabric Required",Red,Italic,12],{0.5,0.75}]}],Graphics[{Blue,Thick,Arrowheads[0.03],Arrow[{{1.5,0.1},{2,0.1}}],Text[Style["Congestion Control & Flow Control",Blue,Italic,12],{1.75,0.3}]}]]]


hopByHopGraph=Graph[{"Switch 1", "Switch 2", "Switch 3", "Switch 4"}, {UndirectedEdge["Switch 1", "Switch 2"], UndirectedEdge["Switch 2", "Switch 3"], UndirectedEdge["Switch 3", "Switch 4"]}, {EdgeStyle -> {Red}, GraphStyle -> "NameLabeled", ImageSize -> Medium, PlotLabel -> Style["ATM Hop-by-Hop Flow Control\n(Local Backpressure)", Bold, 14], VertexLabels -> {"Name"}}];
rateBasedGraph=Graph[{"Source", "Switch 1", "Switch 2", "Switch 3", "Destination"}, {DirectedEdge["Source", "Switch 1"], DirectedEdge["Switch 1", "Switch 2"], DirectedEdge["Switch 2", "Switch 3"], DirectedEdge["Switch 3", "Destination"], DirectedEdge["Destination", "Source"]}, {EdgeStyle -> {Blue}, GraphStyle -> "NameLabeled", ImageSize -> Medium, PlotLabel -> Style["ATM Rate-Based Flow Control\n(End-to-End Feedback)", Bold, 14], VertexLabels -> {"Name"}}];
channelCapacity=100 10^9;
packetSizeBytes=64;
packetSizeBits=packetSizeBytes 8;
ackSizeBytes=8;
ackSizeBits=ackSizeBytes 8;
distance_m=1.6;
propagationSpeed=3 10^8;
oneWayDelay_s=distance_m/propagationSpeed;
roundTripDelay_s=2 oneWayDelay_s;
tp=packetSizeBits/channelCapacity;
T=roundTripDelay_s+ackSizeBits/channelCapacity;
multiplexFactor=1/(1+T/tp);
throughputText=Grid[{{"Packet size (bits):",packetSizeBits},{"Channel capacity (bps):",channelCapacity},{"One-way delay (s):",NumberForm[oneWayDelay_s,{4,10}]},{"Round-trip delay (s):",NumberForm[roundTripDelay_s,{4,10}]},{"Packet transmit time (s):",NumberForm[tp,{4,10}]},{"Timeout T (s):",NumberForm[T,{4,10}]},{"Multiplexing factor M:",NumberForm[multiplexFactor,{3,3}]},{"Effective throughput:",NumberForm[(multiplexFactor channelCapacity)/10^9,{3,3}],"Gb/s"}},Frame->All,ItemStyle->Directive[Bold,12]];
sliceSizeBits=64;
sliceTransmitTime=sliceSizeBits/channelCapacity;
slicesPerPacket=packetSizeBits/sliceSizeBits;
sliceTimes=Table[sliceTransmitTime i,{i,0,slicesPerPacket-1}];
ackLatency=2/10^9;
pipelinePlot=Graphics[{Style[LightGreen,Opacity[0.6]],Table[Rectangle[{sliceTimes[[i]],1},{sliceTimes[[i]]+sliceTransmitTime,2}],{i,slicesPerPacket}],Style[Red,PointSize[Large]],Table[Point[{sliceTimes[[i]]+ackLatency,1.5}],{i,slicesPerPacket}],Text["Packet sliced into 8-byte slices",{0,2.5}],Text["Each slice has sub-ACK arriving shortly after",{0,0.5}]},PlotRange->{{0,Max[sliceTimes]+5 sliceTransmitTime},{0,3}},Axes->True,AxesLabel->{"Time (s)",""},ImageSize->Large];
features={"Reliability","Latency","Jitter","Congestion Control","Packet Loss","RDMA Support","CPU Overhead","Primary Use Case"};
ethernetVals={"Best-effort (via TCP)","Millisecond-scale (typical)","High","Optional (DCB/PFC)","Possible","RoCE (complex)","High (software stack)","General networking"};
infinibandVals={"Hardware-enforced","Microsecond-scale","Very low","Built-in","Avoided by design","Native","Low (hardware offload)","HPC, AI, low-latency clusters"};
featureComparisonTable=Grid[Prepend[MapThread[{#1,#2,#3}&,{features,ethernetVals,infinibandVals}],{"Feature","Ethernet (traditional)","InfiniBand"}],Frame->All,Background->{None,{LightGray,White}},Spacings->{2,1},ItemStyle->Directive[FontFamily->"Arial",FontSize->12],Alignment->Left,Dividers->All,BaseStyle->Directive[Bold]];
Column[{Style["9.2 ATM Flow Control Models",Bold,16],Row[{hopByHopGraph,Spacer[20],rateBasedGraph}],Style["9.3 Metcalfe Throughput Model Example",Bold,16],throughputText,Style["9.4 Packet Subdivision into 8-byte Slices & Sub-ACK Pipelining",Bold,16],pipelinePlot,Style["9.5 Ethernet vs InfiniBand Feature Comparison",Bold,16],featureComparisonTable},Spacings->3,Alignment->Center]


Module[{atmNodes,atmEdges,atmGraph,ethernetLossProb=0.05,infinibandLossProb=0.001,ethernetPacketCount=100,infinibandPacketCount=100,ethernetDrops,infinibandDrops,throughputMetcalfe,P=512,C=100 10^9,A=64,d=4/10^9,tTx,Tvals,Mvals,effCapacityVals,sliceSize=64,Tslice,slicePipelineUtilization},atmNodes={"Source","Switch1","Switch2","Destination"};atmEdges=DirectedEdge@@@{{"Source","Switch1"},{"Switch1","Switch2"},{"Switch2","Destination"}};atmGraph=Graph[atmEdges,VertexLabels->"Name",GraphStyle->"NameLabeled",EdgeStyle->Arrowheads[Medium],ImageSize->Large,PlotLabel->Style["ATM Flow Control: Hop-by-Hop (local backpressure) vs Rate-Based (end-to-end feedback)",Bold,14]];ethernetDrops=RandomChoice[{1-ethernetLossProb,ethernetLossProb}->{False,True},ethernetPacketCount];infinibandDrops=RandomChoice[{1-infinibandLossProb,infinibandLossProb}->{False,True},infinibandPacketCount];ethernetLossGraphic=BarChart[{Count[ethernetDrops,True],Count[ethernetDrops,False]},ChartLabels->{"Dropped","Delivered"},ChartStyle->{Red,Green},PlotLabel->Style["Ethernet Packet Loss (Simulated)",Bold,14],ImageSize->Medium];infinibandLossGraphic=BarChart[{Count[infinibandDrops,True],Count[infinibandDrops,False]},ChartLabels->{"Dropped","Delivered"},ChartStyle->{Red,Green},PlotLabel->Style["InfiniBand Packet Loss (Simulated)",Bold,14],ImageSize->Medium];tTx=P/C;Tvals=Range[0.1/10^8,3/10^8,0.1/10^9];Mvals=1/(1+Tvals/tTx);effCapacityVals=Mvals (1-0.01) C;throughputMetcalfe=ListLinePlot[Transpose[{Tvals 10^9,effCapacityVals/10^9}],PlotRange->All,Frame->True,FrameLabel->{"Timeout + RTT (ns)","Effective Capacity (Gbps)"},PlotLabel->Style["Metcalfe Throughput Model: Effect of Timeout/RTT on Capacity",Bold,14],ImageSize->Large];Tslice=sliceSize/C;slicePipelineUtilization=Table[1/(1+Tvals[[i]]/(Tslice window)),{i,Length[Tvals]},{window,{1,4,8}}];slicePlot=ListLinePlot[Table[Transpose[{Tvals 10^9,(slicePipelineUtilization[[All,w]] C)/10^9}],{w,1,3}],PlotLegends->{"1 slice (stop-and-wait)","4 slices","8 slices"},Frame->True,FrameLabel->{"Timeout + RTT (ns)","Effective Capacity (Gbps)"},PlotLabel->Style["Throughput Improvement with Packet Slicing and Sub-ACKs",Bold,14],ImageSize->Large];Column[{atmGraph,Grid[{{ethernetLossGraphic,infinibandLossGraphic}}],throughputMetcalfe,slicePlot},Spacings->3]]


alohaComparisonData={{"Feature","ALOHA","Slotted ALOHA"},{"Time structure","Any time","Slot-aligned"},{"Collision probability","High","Lower"},{"Efficiency (max)","\[Tilde]18% (1/2e)","\[Tilde]37% (1/e)"},{"Implementation complexity","Simple","Needs synchronization"},{"Analogy","Random shouting","Timed shouting"}};
alohaComparisonTable:=Grid[Map[If[#1===alohaComparisonData[[1]],Style[#1,Bold,14],#1]&,alohaComparisonData,{2}],Frame->All,Background->{None,{LightYellow,LightCyan}},Alignment->Center,Spacings->{3,2}];
alohaVisual:=Module[{alohaPackets,slottedPackets,drawPacket},drawPacket[{start_,dur_},y_,col_]:=Rectangle[{start,y-0.4},{start+dur,y+0.4},RoundingRadius->0.1];alohaPackets={{0.1,0.8},{0.7,0.9},{1.4,0.6},{1.8,0.7},{2.2,0.9}};slottedPackets={{0,1},{1,1},{2,1},{3,1},{4,1}};GraphicsGrid[{{Graphics[{LightBlue,EdgeForm[Black],Table[drawPacket[p,1.5,LightBlue],{p,alohaPackets}],Red,Style[Text["Collisions (overlaps)",1.5 {1,0.8}],Bold,14],Black,Style[Text["ALOHA: Uncoordinated Transmission",1.5 {1.5,2.5}],Bold,16]},PlotRange->{{0,3},{0,3}},ImageSize->400],Graphics[{LightGreen,EdgeForm[Black],Table[drawPacket[p,1.5,LightGreen],{p,slottedPackets}],Black,Style[Text["Slotted ALOHA: Slot-aligned Transmissions",1.5 {2,2.5}],Bold,16]},PlotRange->{{0,5},{0,3}},ImageSize->400]}},Spacings->{3,2}]];
throughputFormula:=Grid[{{Style["Throughput Formula Components",Bold,14,Blue]},{"Effective Capacity (E):",Row[{Style["S/P \[Times] 1/(1 + C T / P) \[Times] (1 - L) \[Times] C",Italic]," where: ",Style["C",Bold]," = channel capacity (bits/s), ",Style["P",Bold]," = packet length (bits), ",Style["S",Bold]," = payload bits, ",Style["L",Bold]," = packet loss probability, ",Style["T",Bold]," = transmitter timeout (RTT + ACK time)"}]},{"Multiplexing factor M:",Style["M = 1 / (1 + T/T_p), with T_p = P/C",Italic]},{"Explanation:","Throughput is limited by stop-and-wait delays unless multiple packets or slices are pipelined."}},Alignment->Left,Spacings->{2,2}];
Column[{Style["1. ALOHA vs Slotted ALOHA Comparison Table",Bold,16],alohaComparisonTable,Style["2. Visual Comparison of ALOHA vs Slotted ALOHA Transmission",Bold,16],alohaVisual,Style["3. Throughput Formula and Key Parameters",Bold,16],throughputFormula},Spacings->3]


packetSlicingGraphics:=Module[{sliceCount=8,sliceWidth=0.8,sliceHeight=1,ackArrowHeight=0.7,sliceColors,ackColors},sliceColors=Table[Blend[{LightBlue,Blue},i/sliceCount],{i,1,sliceCount}];ackColors=Table[Blend[{LightRed,Red},i/sliceCount],{i,1,sliceCount}];Graphics[{Table[{sliceColors[[i]],EdgeForm[Black],Rectangle[{i-1,1},{i-1+sliceWidth,1+sliceHeight}],Black,Text[Style[ToString[i],Bold,14],{i-1+sliceWidth/2,1+sliceHeight/2}]},{i,1,sliceCount}],Table[{ackColors[[i]],Arrowheads[0.03],Arrow[{{i-1+sliceWidth/2,1},{i-1+sliceWidth/2,1-ackArrowHeight}}]},{i,1,sliceCount}],Text[Style["64-byte Packet split into eight 8-byte slices",Bold,16,DarkBlue],{sliceCount/2,2.5}],Text[Style["Sub-ACKs acknowledge slices, allowing pipelined transmissions.",Italic,12],{sliceCount/2,-0.2}],Text[Style["Throughput improves by keeping multiple slices in flight during RTT.",Italic,12],{sliceCount/2,-0.7}]},PlotRange->{{-1,sliceCount},{-1,3}},ImageSize->600,Axes->False]];
conveyorBeltGraphics:=Module[{beltLength=8,classicalBeltY=2.5,quantumBeltY=0},Graphics[{Text[Style["Classical Time Flow (Conveyor Belt)",Bold,14,DarkGreen],{beltLength/2,3.8}],Brown,Thick,Rectangle[{0,classicalBeltY-0.3},{beltLength,classicalBeltY+0.3}],Arrowheads[0.04],Arrow[{{0,classicalBeltY},{beltLength,classicalBeltY}}],Table[{Blue,Disk[{i-0.5,classicalBeltY},0.2],Black,Text[Style[ToString[i],Bold,12],{i-0.5,classicalBeltY+0.4}]},{i,1,beltLength}],Text[Style["Indefinite Causal Order (Quantum)",Bold,14,DarkRed,Italic],{beltLength/2,1.8}],Brown,Thick,Line[{{0,quantumBeltY},{4,quantumBeltY},{5,quantumBeltY+1},{beltLength,quantumBeltY+1}}],Line[{{4,quantumBeltY},{5,quantumBeltY-1},{beltLength,quantumBeltY-1}}],Red,Disk[{1,quantumBeltY},0.2],Text[Style["A",Bold,12],{1,quantumBeltY+0.4}],Disk[{3,quantumBeltY},0.2],Text[Style["B",Bold,12],{3,quantumBeltY+0.4}],Disk[{6,quantumBeltY+1},0.2],Text[Style["C",Bold,12],{6,quantumBeltY+1.4}],Disk[{6,quantumBeltY-1},0.2],Text[Style["D",Bold,12],{6,quantumBeltY-1.4}]},PlotRange->{{-1,beltLength+1},{-2,4.5}},ImageSize->600,Axes->False]];
logicalVsIndefinite:=Module[{timelineLength=6,lamportEvents,indefiniteEvents,overlaps},lamportEvents=Table[{i+0.5,2.5},{i,0,timelineLength-1}];indefiniteEvents=Table[{i+0.5,1},{i,0,timelineLength-1}];Graphics[{Text[Style["Lamport Logical Time (Deterministic order)",Bold,14,DarkBlue],{timelineLength/2,3.5}],Black,Thick,Arrowheads[0.03],Arrow[{{0,2.5},{timelineLength,2.5}}],Table[{Blue,Disk[lamportEvents[[i]],0.2],Black,Text[Style["E"<>ToString[i],Bold,12],lamportEvents[[i]]+{0,0.4}]},{i,1,Length[lamportEvents]}],Text[Style["Indefinite Causal Order (Quantum superposition)",Bold,14,DarkMagenta],{timelineLength/2,-0.5}],Black,Thick,Line[{{0,1},{timelineLength,1}}],Table[{Magenta,Disk[indefiniteEvents[[i]],0.25],Black,Text[Style["F"<>ToString[i],Bold,12],indefiniteEvents[[i]]+{0,0.4}]},{i,1,Length[indefiniteEvents]}],Red,Dashed,Arrowheads[0.02],Arrow[{indefiniteEvents[[3]],indefiniteEvents[[2]]+{0,0.3}}],Arrow[{indefiniteEvents[[2]],indefiniteEvents[[3]]+{0,0.3}}],Text[Style["Superposition: F2 and F3 have no definite order",Italic,12,Red],{timelineLength/2,1.8}]},PlotRange->{{-0.5,timelineLength+0.5},{-1,4}},ImageSize->600,Axes->False]];
tiktyktikCommonKnowledge:=Module[{stages,yStart=6,yStep=-1,aliceX=1.5,bobX=6.5},stages={"1. Alice sends (Bob unaware)","2. Bob receives (Alice unsure)","3. Bob sends ACK1","4. Alice receives ACK1 (Knows Bob got packet)","5. Alice sends ACK2 (Completes 2nd round trip)","6. Bob receives ACK2 (Mutual knowledge achieved)"};Graphics[{Text[Style["TIKTYKTIK Protocol: Common Knowledge Build-up",Bold,16,DarkCyan],{4,yStart+1.5}],Blue,Disk[{aliceX,yStart+0.5},0.3],Text[Style["Alice",Bold,14],{aliceX,yStart+1}],Purple,Disk[{bobX,yStart+0.5},0.3],Text[Style["Bob",Bold,14],{bobX,yStart+1}],Table[Text[Style[stages[[i]],12],{4,yStart+yStep (i-1)}],{i,1,Length[stages]}],Arrowheads[0.03],Table[With[{y=yStart+yStep (i-1)},If[OddQ[i],{Blue,Arrow[{{aliceX+0.3,y},{bobX-0.3,y}}]},{Purple,Arrow[{{bobX-0.3,y},{aliceX+0.3,y}}]}]],{i,1,Length[stages]}]},PlotRange->{{0,8},{yStart+yStep Length[stages]-1,yStart+2}},ImageSize->600,Axes->False]];
Column[{packetSlicingGraphics,conveyorBeltGraphics,logicalVsIndefinite,tiktyktikCommonKnowledge},Spacings->4]


Module[{archTree,perfReliabPanel,conceptTable,topologySketch,marketSummary,titleStyle=Style[#1,Bold,18,FontFamily->"Arial"]&,subtitleStyle=Style[#1,Bold,14,FontFamily->"Arial"]&,textStyle=Style[#1,FontSize->12,FontFamily->"Arial"]&,keyPointStyle=Style[#1,FontSize->11,FontFamily->"Arial",Italic]&,boxStyle=Directive[EdgeForm[Black],LightYellow],arrowStyle={Black,Arrowheads[0.03],Thick}},archTree=Graph[{"Open Atomic Ethernet Requirements", "Core Technical Architecture", "Open Software Stack", "Research & Validation", "Ecosystem & Governance", "Lossless / Near-Zero-Loss Data Plane", "In-NIC Atomic Verbs", "Deterministic Scheduling", "Reference-Free Causal Ordering", "Self-Stabilizing Control Plane", "Composable Security & Isolation", "Open-Source Reference NIC RTL", "Portable Verbs Library", "Self-Healing Membership Service", "Lightweight Management Telemetry", "Formal Proofs for Atomic Commit", "Tail-latency & Failure-injection Benchmark", "Hybrid Quantum/Classical Shim", "Public Problem-Statement Registry", "Sub-groups", "External Expert Engagement", "Dedicated Business-Case Work-stream"}, {DirectedEdge["Open Atomic Ethernet Requirements", "Core Technical Architecture"], DirectedEdge["Open Atomic Ethernet Requirements", "Open Software Stack"], DirectedEdge["Open Atomic Ethernet Requirements", "Research & Validation"], DirectedEdge["Open Atomic Ethernet Requirements", "Ecosystem & Governance"], DirectedEdge["Core Technical Architecture", "Lossless / Near-Zero-Loss Data Plane"], DirectedEdge["Core Technical Architecture", "In-NIC Atomic Verbs"], DirectedEdge["Core Technical Architecture", "Deterministic Scheduling"], DirectedEdge["Core Technical Architecture", "Reference-Free Causal Ordering"], DirectedEdge["Core Technical Architecture", "Self-Stabilizing Control Plane"], DirectedEdge["Core Technical Architecture", "Composable Security & Isolation"], DirectedEdge["Open Software Stack", "Open-Source Reference NIC RTL"], DirectedEdge["Open Software Stack", "Portable Verbs Library"], DirectedEdge["Open Software Stack", "Self-Healing Membership Service"], DirectedEdge["Open Software Stack", "Lightweight Management Telemetry"], DirectedEdge["Research & Validation", "Formal Proofs for Atomic Commit"], DirectedEdge["Research & Validation", "Tail-latency & Failure-injection Benchmark"], DirectedEdge["Research & Validation", "Hybrid Quantum/Classical Shim"], DirectedEdge["Ecosystem & Governance", "Public Problem-Statement Registry"], DirectedEdge["Ecosystem & Governance", "Sub-groups"], DirectedEdge["Ecosystem & Governance", "External Expert Engagement"], DirectedEdge["Ecosystem & Governance", "Dedicated Business-Case Work-stream"]}, {GraphLayout -> "LayeredDigraphEmbedding", ImageSize -> 700, PlotLabel -> titleStyle["Open Atomic Ethernet: Core Requirements"], VertexLabels -> {Placed["Name", Center]}, VertexStyle -> {boxStyle}}];perfReliabPanel=Grid[{{subtitleStyle["Performance Targets"],"",subtitleStyle["Reliability & Resilience"]},{textStyle["Latency: < 100 ns store-and-forward, < 50 ns cut-through"],"",textStyle["Loss/Corruption Handling: per-hop FEC optional, end-to-end CRC > 2^32"]},{textStyle["Throughput: Scale from 200 Gb/s to 1.6 Tb/s per lane"],"",textStyle["Membership: Fast liveness voting, virtual synchrony support"]},{textStyle["Transaction RTT: Sender \[RightArrow] Receiver ack < 300 ns (in-rack worst-case)"],"",textStyle["Rollback Support: Speculative packets discard/commit hardware tag"]},{textStyle["Energy: <2 pJ/bit at 200 Gb/s, target sub-pJ with advanced PHY"],"",textStyle["Graceful Degradation: Congestion telemetry, buffer health monitoring"]},{textStyle["Clocking: Distributed low-skew clock (photonic/electrical)"],"",textStyle["Security: Inline MACsec-lite, key-roll w/o traffic pause"]}},Frame->All,ItemSize->{{30,300,350}},Alignment->Left,Background->{None,{{LightGray,None}}},Spacings->{1,2}];conceptTable=Grid[{{subtitleStyle["Aspect"],subtitleStyle["Traditional Ethernet"],subtitleStyle["Open Atomic Ethernet"]},{"Protocol Model","Source-Destination, asynchronous, timeout/retry","Bipartite Token Coherence, reversible, no retries"},{"Transaction Semantics","Best-effort, possible drops & duplicates","Exactly-once semantics, atomic commit/rollback"},{"Error Handling","Timeouts, retransmissions, exponential backoff","Logical reversibility, failure recovery via transaction reversal"},{"Topology Control","Fixed physical routing, spanning trees","Dynamic logical & virtual trees, app-programmable"},{"Security Model","MAC/IP based, vulnerable to byzantine attacks","Port-based local addressing, built-in isolation & side-channel detection"},{"Latency","Subject to retries, congestion, unpredictable delays","Deterministic, bounded latency with mesochronous scheduling"},{"Scalability","Fragmented, multiple overlays","Unified Ethernet for chiplets, racks, AI accelerators"}},Frame->All,Alignment->Left,ItemStyle->Directive[FontFamily->"Arial",FontSize->12],Background->{None,{{LightYellow,None}}}];topologySketch=Graphics[{LightBlue,EdgeForm[Black],Rectangle[{0,0},{10,2}],Text[Style["Physical Layer: Chiplet & Rack Interconnect",Bold,14],{5,1}],Black,Dashed,Table[Line[{{x,0},{x,2}}],{x,1,9,2}],Green,EdgeForm[Black],Rectangle[{1,3},{9,5}],Text[Style["Logical Layer: Configurable Trees & Links",Bold,14],{5,4}],Black,Dashed,Table[Line[{{x,3},{x+1,5}}],{x,1,7,2}],Orange,EdgeForm[Black],Rectangle[{2,6},{8,8}],Text[Style["Virtual Layer: Application-controlled Trees",Bold,14],{5,7}],Black,Dashed,Line[{{2,6},{8,8}}],Line[{{8,6},{2,8}}],Text[Style["Dynamic, Secure, Self-Healing",Italic,12],{5,6.5}]},ImageSize->700,PlotRange->{{-1,11},{-1,10}},Background->White,Axes->False];marketSummary=Column[{titleStyle["Market & Innovation Highlights"],keyPointStyle["\[Bullet] Emergence of XPU & SmartNIC revolution"],keyPointStyle["\[Bullet] FPGA NIC implementations for protocol experimentation"],keyPointStyle["\[Bullet] Strong need for ultra-low latency AI inference at the edge"],keyPointStyle["\[Bullet] Shift from best-effort to lossless, deterministic network protocols"],keyPointStyle["\[Bullet] Dynamic network topologies driven by application needs"],keyPointStyle["\[Bullet] Formal methods underpin infrastructure verification"],keyPointStyle["\[Bullet] Collaborative ecosystem involving academic and industry leaders"]},Spacings->1.5];Column[{archTree,Spacer[20],Style["Performance and Reliability Targets",Bold,16],perfReliabPanel,Spacer[20],Style["Conceptual Comparison: Traditional vs Open Atomic Ethernet",Bold,16],conceptTable,Spacer[20],topologySketch,Spacer[20],marketSummary},Spacings->3]]


Off[ExampleData::obsolete];
$stockImages=Association["Lena"->ExampleData[{"TestImage","Lena"}],"Mandrill"->ExampleData[{"TestImage","Mandrill"}],"Peppers"->ExampleData[{"TestImage","Peppers"}]];
ClearAll[$peakPositions1D];
$peakPositions1D[data_List,thr_]:=Module[{f},f=If[ValueQ[FindPeakPositions],FindPeakPositions[#1,Threshold->thr]&,Function[d,Flatten[Position[Partition[d,3,1],{a_,b_,c_}/;b>a&&b>c&&b-Mean[{a,c}]>thr]]+1]];f[data]];
ClearAll[calculateProfile,findPeaks,findValleys];
calculateProfile[img_Image,{x_,y_,w_,h_}]:=Module[{crop},crop=ImageTake[img,{y,y+h-1},{x,x+w-1}];Mean[ImageData[ColorConvert[crop,"Grayscale"]]]];
findPeaks[profile_List,mult_?NumericQ]:=Module[{mad=Median[Abs[profile-Median[profile]]]},({#1-.5,#1+.5}&)/@$peakPositions1D[profile,mult mad]];
findValleys[profile_List,mult_?NumericQ]:=Module[{mad=Median[Abs[profile-Median[profile]]]},({#1-.5,#1+.5}&)/@$peakPositions1D[-profile,mult mad]];
ClearAll[LaunchGVMFabricAnalyzer];
Options[LaunchGVMFabricAnalyzer]={"InitialPeakMAD"->1.,"InitialValleyMAD"->1.};
LaunchGVMFabricAnalyzer[OptionsPattern[]]:=Manipulate[Module[{img=$stockImages[stockKey],dims=ImageDimensions[$stockImages[stockKey]],roi,prof,peaks,valleys,intRange,imageView,plot},roi={Round[x],Round[y],Round[w],Round[h]};prof=calculateProfile[img,roi];peaks=findPeaks[prof,peakMAD];valleys=findValleys[prof,valleyMAD];intRange=With[{mn=Min[prof],mx=Max[prof]},If[mn==mx,{mn-1,mx+1},{mn,mx}]];imageView=Show[img,Graphics[Evaluate[{EdgeForm[{Directive[Opacity[0.8],Yellow],Thick}],FaceForm[None],Rectangle[{roi[[1]],dims[[2]]-(roi[[2]]+roi[[4]])},{roi[[1]]+roi[[3]],dims[[2]]-roi[[2]]}]}]],ImageSize->300,PlotLabel->Style["Observable State of the Ether",14,FontFamily->"Courier"]];plot=ListLinePlot[Transpose[{prof,Range[Length[prof]]}],PlotRange->{intRange,{1,Length[prof]}},ScalingFunctions->{None,"Reverse"},AspectRatio->1,ImageSize->300,PlotTheme->"Scientific",GridLines->Automatic,Frame->True,FrameLabel->{"Information Balance","Causal Path Index"},PlotLabel->Style["Token Balance Profile",14,FontFamily->"Courier"],PlotStyle->Directive[Thick,Gray],Epilog->Join[({Opacity[0.2],Darker[Green],Rectangle[{intRange[[1]],#1[[1]]},{intRange[[2]],#1[[2]]}]}&)/@peaks,({Opacity[0.2],Darker[Blue],Rectangle[{intRange[[1]],#1[[1]]},{intRange[[2]],#1[[2]]}]}&)/@valleys],PlotLegends->PointLegend[{Darker[Green],Darker[Blue]},{"Forward Progress (Peak)","Reverse Progress (Valley)"}]];Grid[{{imageView,plot}},Spacings->{2,0},Frame->True,FrameStyle->LightGray]],Delimiter,Style["Fabric Analysis Console",Bold,16],{{stockKey,First[Keys[$stockImages]],"Observed Fabric:"},Keys[$stockImages],ControlType->PopupMenu},OpenerView[{"Scout Parameters (ROI)",Column[{Control[{{x,1,"x"},1,Dynamic[ImageDimensions[$stockImages[stockKey]][[1]]-w+1],1}],Control[{{y,1,"y"},1,Dynamic[ImageDimensions[$stockImages[stockKey]][[2]]-h+1],1}],Control[{{w,32,"width"},1,Dynamic[ImageDimensions[$stockImages[stockKey]][[1]]],1}],Control[{{h,32,"height"},1,Dynamic[ImageDimensions[$stockImages[stockKey]][[2]]],1}]}]}],OpenerView[{"Hazard Detection Thresholds",Column[{Control[{{valleyMAD,OptionValue["InitialValleyMAD"],"Valley MAD"},0.1,5.0,0.1,Appearance->"Labeled"}],Control[{{peakMAD,OptionValue["InitialPeakMAD"],"Peak MAD"},0.1,5.0,0.1,Appearance->"Labeled"}]}]}],ControlPlacement->Left,TrackedSymbols->{stockKey,x,y,w,h,valleyMAD,peakMAD}];
LaunchGVMFabricAnalyzer[]


ClearAll[getPosition,safeWD,numericQ,toDegrees];
getPosition[str_String]:=Module[{pos},pos=Quiet[Check[GeoPosition[str],$Failed]];If[pos===$Failed,pos=Quiet[Check[With[{r=Interpreter["Location"][str]},Which[Head[r]===GeoPosition,r,Head[r]===Entity,EntityValue[r,"Position"],True,$Failed]],$Failed]]];If[pos===$Failed,pos=Quiet[Check[GeoPosition[CityData[str,"Coordinates"]],$Failed]]];pos];
safeWD[ent_,prop_]:=Quiet[Check[WeatherData[ent,prop],Missing[]]];
numericQ[x_]:=NumericQ[x]||QuantityQ[x];
toDegrees[q_]:=Which[QuantityQ[q],QuantityMagnitude[UnitConvert[q,"Degrees"]],NumericQ[q],q,True,Missing[]];
DynamicModule[{loc="Chicago",latlon=Missing[],nowDegC=Missing[],nowCond=Missing[],ts24=Missing[],hi=Association[],data=Association[],astro=Association[],error=False},Column[{Row[{InputField[Dynamic[loc],String,FieldSize->28,ContinuousAction->True],Spacer[5],Button["Update",error=False;Module[{pos=getPosition[StringTrim[loc]],vals,pairs},If[pos===$Failed,error=True;Return[]];latlon=Normal[pos];nowDegC=With[{t=safeWD[pos,"Temperature"]},If[QuantityQ[t],Round[QuantityMagnitude[UnitConvert[t,"DegreesCelsius"]]],Missing[]]];nowCond=safeWD[pos,"Conditions"];ts24=safeWD[pos,{"Temperature",{Now,Now+Quantity[24,"Hours"]}}];ts24=If[Head[ts24]===TimeSeries,UnitConvert[ts24,"DegreesCelsius"],Missing[]];vals=If[Head[ts24]===TimeSeries,Normal[ts24][[All,2]],{}];pairs=If[Head[ts24]===TimeSeries,Normal[ts24],{}];hi=Association["HiTemp"->If[FailureQ[Quiet[Max[vals]]],Missing[],Round[Max[vals]]],"LoTemp"->If[FailureQ[Quiet[Min[vals]]],Missing[],Round[Min[vals]]],"HiTime"->If[vals==={},Missing[],Lookup[pairs,Max[vals]]],"LoTime"->If[vals==={},Missing[],Lookup[pairs,Min[vals]]]];KeyValueMap[Module[{raw=safeWD[pos,#1]},If[raw=!=Missing[],AssociateTo[data,#2[[1]]->#2[[2]][raw]]]]&,Association["UVIndex"->{"UV",Identity},"VisibilityDistance"->{"VisKm",Function[q,Round[QuantityMagnitude[UnitConvert[q,"Kilometers"]]]]},"WindSpeed"->{"WindKmH",Function[q,Round[QuantityMagnitude[UnitConvert[q,("Kilometers")/("Hours")]]]]},"WindDirection"->{"WindDeg",toDegrees},"RelativeHumidity"->{"Humidity%",Function[q,Round[QuantityMagnitude[UnitConvert[q,"Percent"]]]]},"Pressure"->{"PressurehPa",Function[q,Round[QuantityMagnitude[UnitConvert[q,"Hectopascals"]]]]},"CloudCover"->{"Cloud%",Function[q,Round[QuantityMagnitude[UnitConvert[q,"Percent"]]]]},"PrecipitationProbability"->{"Precip%",Function[p,Round[p 100]]}]];astro=Association["Sunrise"->safeWD[pos,"SunriseTime"],"Sunset"->safeWD[pos,"SunsetTime"]];]],Spacer[6],Dynamic[If[error,Style["location not found",Red],Spacer[0]]]}],Divider[],Dynamic[If[MissingQ[nowDegC],Style["(press Update)",Italic,Gray],Grid[{{Style["Current Weather",14,Bold,Darker[Blue]]},{Row[{nowDegC," \[Degree]C"}]},{If[MissingQ[nowCond],"\[LongDash]",nowCond]},{"High:  "<>If[MissingQ[hi["HiTemp"]],"\[LongDash]",ToString[hi["HiTemp"]]<>" \[Degree]C"]<>"  @ "<>If[MissingQ[hi["HiTime"]],"\[LongDash]",DateString[hi["HiTime"],{"Hour12",":","Minute"," AMPM"}]]},{"Low:   "<>If[MissingQ[hi["LoTemp"]],"\[LongDash]",ToString[hi["LoTemp"]]<>" \[Degree]C"]<>"  @ "<>If[MissingQ[hi["LoTime"]],"\[LongDash]",DateString[hi["LoTime"],{"Hour12",":","Minute"," AMPM"}]]},{"Lat/Lon: "<>If[ListQ[latlon],Row[{NumberForm[latlon[[1]],{6,4}],"\[Degree], ",NumberForm[latlon[[2]],{6,4}],"\[Degree]"}],"\[LongDash]"]},{"Local: "<>DateString[Now,{"TimeShort","  ","DayNameShort"}]}},Alignment->Left,Spacings->{2,.6}]]],Spacer[10],Dynamic[If[Head[ts24]===TimeSeries,Column[{Style["Next 24 h temperature",12,Bold,Gray],ListLinePlot[ts24,PlotRange->All,PlotMarkers->Automatic,InterpolationOrder->1,AxesLabel->{"Time","\[Degree]C"},ImageSize->Medium]}],""]],Spacer[10],Dynamic[Module[{rows={}},KeyValueMap[AppendTo[rows,{#1<>":",#2}]&,KeySort[DeleteMissing[KeyTake[data,{"UV","Humidity%","Cloud%","PressurehPa","VisKm","WindKmH","Precip%"}]]]];If[KeyExistsQ[data,"WindDeg"],Module[{deg=data["WindDeg"],lbl={"N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSW","SW","WSW","W","WNW","NW","NNW"}},AppendTo[rows,{"Direction:",lbl[[Mod[Round[deg/22.5],16,1]]]<>" ("<>ToString[deg]<>"\[Degree])"}]]];Grid[Prepend[rows,{Style["Highlights",12,Bold,Gray]}],Alignment->{Left,Right},Frame->{None,{None,{2->GrayLevel[.9]}}},Spacings->{2,1}]]],Spacer[10],Dynamic[If[DeleteMissing[astro]===Association[],"",Grid[{{Style["Sunrise & Sunset",12,Bold,Gray]},{"Sunrise:",If[MissingQ[astro["Sunrise"]],"\[LongDash]",DateString[astro["Sunrise"],{"Hour12",":","Minute"," AMPM"}]]},{"Sunset:",If[MissingQ[astro["Sunset"]],"\[LongDash]",DateString[astro["Sunset"],{"Hour12",":","Minute"," AMPM"}]]}},Alignment->Left,Spacings->{2,.8}]]]},Spacings->2]]


ClearAll["Global`*"];
isPrimeQ=PrimeQ;
timed[tag_,expr_]:=Module[{t0=AbsoluteTime[],val,dt},val=expr;dt=AbsoluteTime[]-t0;Print[Row[{tag," finished in ",NumberForm[dt,{6,3}]," s."}]];val];
getPrimeFactors[n_Integer?Positive]:=FactorInteger[n][[All,1]];
rad124[n_Integer?Positive]:=rad124[n]=Times@@getPrimeFactors[n];
solvePE124[]:=timed["PE-124 (Original)",Module[{pairs},pairs=Table[{n,rad124[n]},{n,10^5}];Print["answer (10 000th): ",First[SortBy[pairs,{Last,First}][[10000]]]]]];
solvePE95[]:=timed["PE-95 (Original)",Module[{limit=10^6,sigma=Developer`ToPackedArray[DivisorSigma[1,Range[10^6]]-Range[10^6]],mark=ConstantArray[0,10^6],longestLen=0,longestMin=0,bag,list,n,idx,pos,cycLen},Do[If[mark[[n]]=!=0,Continue[]];bag=Internal`Bag[];idx=n;While[1<idx<=limit&&mark[[idx]]==0,mark[[idx]]=-1;Internal`StuffBag[bag,idx];idx=sigma[[idx]];];list=Internal`BagPart[bag,All];If[idx<=limit&&mark[[idx]]==-1,pos=FirstPosition[list,idx][[1]];cycLen=Length[list]-pos+1;If[cycLen>longestLen,longestLen=cycLen;longestMin=Min[Take[list,{pos,-1}]];];];mark[[list]]=1;,{n,2,limit}];Print["smallest element of longest chain: ",longestMin];]];
solvePE357[]:=timed["PE-357 (Original)",Module[{nMax=100000000,sum=0,n,divs},Do[n=2 k;If[PrimeQ[n+1]&&Mod[n,4]==0,divs=Rest[Most[Divisors[n]]];If[AllTrue[divs,PrimeQ[#1+n/#1]&],sum+=n]],{k,1,nMax/2-1,2}];Print["sum: ",sum];]];
solvePE124WithVisuals[]:=Module[{pairs,sortedPairs},Print[Style["--- Solving Project Euler 124 with Visuals ---","Section",Bold]];Print["Step 1: Calculate rad(n), the product of distinct prime factors."];Print[TableForm[Table[{n,getPrimeFactors[n],rad124[n]},{n,1,15}],TableHeadings->{None,{"n","Prime Factors","rad(n)"}}]];pairs=Table[{n,rad124[n]},{n,10^5}];Print["Step 2: Create pairs of {n, rad(n)} for n up to 100,000. (Sample shown)"];Print[Short[pairs,5]];sortedPairs=SortBy[pairs,{Last,First}];Print["Step 3: Sort the pairs first by rad(n), then by n. (Sample shown)"];Print[Short[sortedPairs,5]];Print[Style["Final Answer:",Bold]];Print["The 10,000th element in the sorted list is {n, rad(n)} = ",sortedPairs[[10000]]];Print["So the answer is n = ",First[sortedPairs[[10000]]]];Print[Style["Visualization:",Bold]];Print[ListPlot[Take[pairs,1000],PlotLabel->"rad(n) vs. n for n=1 to 1000",AxesLabel->{"n","rad(n)"},PlotTheme->"Scientific",ImageSize->Medium,PlotStyle->Opacity[0.5]]];];
solvePE95WithVisuals[]:=timed["PE-95 (Visual)",Module[{limit=10^6,sigma,mark=ConstantArray[0,10^6],longestLen=0,longestChain={},bag,list,n,idx,pos,currentChain},Print[Style["--- Solving Project Euler 95 with Visuals ---","Section",Bold]];sigma=Developer`ToPackedArray[DivisorSigma[1,Range[limit]]-Range[limit]];Print["Step 1: Pre-calculate array of proper divisor sums, \[Sigma](n)-n. (First 25 shown)"];Print[TableForm[Take[sigma,25],TableHeadings->{Range[25],{"\[Sigma](n)-n"}}]];Print["Step 2: Search for amicable chains. New longest chains will be printed as they are found."];Do[If[mark[[n]]=!=0,Continue[]];bag=Internal`Bag[];idx=n;While[1<idx<=limit&&mark[[idx]]==0,mark[[idx]]=-1;Internal`StuffBag[bag,idx];idx=sigma[[idx]];];list=Internal`BagPart[bag,All];If[idx<=limit&&mark[[idx]]==-1,pos=FirstPosition[list,idx];If[Head[pos]===List,pos=pos[[1]];currentChain=Take[list,{pos,-1}];If[Length[currentChain]>longestLen,longestLen=Length[currentChain];longestChain=currentChain;Print["Found new longest chain of length ",longestLen,": ",longestChain];];];];mark[[list]]=1;,{n,2,limit}];Print[Style["Final Answer:",Bold]];Print["The longest chain found has length: ",Length[longestChain]];Print["The smallest element of this chain is: ",Min[longestChain]];Print[Style["Visualization:",Bold]];Print[GraphPlot[Rule@@@Partition[longestChain,2,1,1],VertexLabeling->True,PlotLabel->"Longest Amicable Chain Found",ImageSize->Large]];]];
solvePE357WithVisuals[]:=timed["PE-357 (Visual)",Module[{nMax=100000,sum=0,n,divs,test,qualifyingNumbers={}},Print[Style["--- Solving Project Euler 357 with Visuals (up to n=100,000) ---","Section",Bold]];Print["Searching for numbers 'n' where for every divisor 'd', d + n/d is prime."];Do[n=2 k;If[!PrimeQ[n+1],Continue[]];divs=Rest[Most[Divisors[n]]];test=AllTrue[divs,PrimeQ[#1+n/#1]&];If[test,sum+=n;AppendTo[qualifyingNumbers,n];Print[Style[Row[{"Found qualifying number: n = ",n}],Bold,Green],"\n  Divisors: ",Most[Divisors[n]],"\n  Checks (d+n/d): ",(#1+n/#1&)/@Most[Divisors[n]],"\n  Current Sum: ",sum]],{k,1,nMax/2-1}];Print[Style["Final Answer:",Bold]];Print["The sum of all qualifying numbers up to ",nMax," is: ",sum];Print[Style["Visualization:",Bold]];Print[ListPlot[qualifyingNumbers,PlotLabel->"Distribution of Qualifying Numbers",AxesLabel->{"Index","Qualifying Number n"},PlotTheme->"Detailed",ImageSize->Medium]];]];
solvePE124WithVisuals[];
Print["\n",TextString[LineSeparator],"\n"];
solvePE95WithVisuals[];
Print["\n",TextString[LineSeparator],"\n"];
solvePE357WithVisuals[];


ClearAll[isPrimeQ,timed,getPrimeFactors,rad124,solvePE124,solvePE95,solvePE357];
isPrimeQ=PrimeQ;
timed[tag_,expr_]:=Module[{t0=AbsoluteTime[],val,dt},val=expr;dt=AbsoluteTime[]-t0;Print[Row[{tag," finished in ",NumberForm[dt,{6,3}]," s."}]];val];
getPrimeFactors[n_Integer?Positive]:=FactorInteger[n][[All,1]];
rad124[n_Integer?Positive]:=rad124[n]=Times@@getPrimeFactors[n];
solvePE124[]:=timed["PE-124",Module[{pairs},pairs=Table[{n,rad124[n]},{n,10^5}];Print["answer (10 000th): ",First[SortBy[pairs,{Last,First}][[10000]]]]]];
solvePE95[]:=timed["PE-95",Module[{limit=10^6,sigma=Developer`ToPackedArray[DivisorSigma[1,Range[10^6]]-Range[10^6]],mark=ConstantArray[0,10^6],longestLen=0,longestMin=0,bag,list,n,idx,pos,cycLen},Do[If[mark[[n]]=!=0,Continue[]];bag=Internal`Bag[];idx=n;While[1<idx<=limit&&mark[[idx]]==0,mark[[idx]]=-1;Internal`StuffBag[bag,idx];idx=sigma[[idx]];];list=Internal`BagPart[bag,All];If[idx<=limit&&mark[[idx]]==-1,pos=FirstPosition[list,idx][[1]];cycLen=Length[list]-pos+1;If[cycLen>longestLen,longestLen=cycLen;longestMin=Min[Take[list,{pos,-1}]]];];mark[[list]]=1;,{n,2,limit}];Print["smallest element of longest chain: ",longestMin];]];
solvePE357[]:=timed["PE-357",Module[{nMax=100000000,sum=0,n,divs},Do[n=2 k;If[PrimeQ[n+1]&&Mod[n,4]==0,divs=Rest[Most[Divisors[n]]];If[AllTrue[divs,PrimeQ[#1+n/#1]&],sum+=n]],{k,1,nMax/2-1,2}];Print["sum: ",sum];]];
solvePE124[];
solvePE95[];


BeginPackage["DaedaelusSignals`"];
FetchOHLCV::usage="FetchOHLCV[ticker, start, end] fetches OHLCV data. This function establishes the foundational record; as described in the Daedalus framework, each transaction must carry a known, bounded amount of entropy, ensuring every interaction is atomic and unambiguous.";
AddSMA::usage="AddSMA[data, n] appends an n-period Simple Moving Average column (\"SMAn\") to the dataset. This is a reversible transformation applied to the data vector.";
AddRSI::usage="AddRSI[data, n] appends an n-period Relative Strength Index column (\"RSIn\") to the dataset. This is another reversible transformation applied to the data vector.";
PlotVolumeChart::usage="PlotVolumeChart[data] creates a bar chart visualizing the volume signal, providing clear, unambiguous feedback on market activity. Each bar represents a discrete, self-contained unit of transactional volume.";
PlotSMAChart::usage="PlotSMAChart[data, n] plots the closing price and its n-period SMA.";
PlotRSIChart::usage="PlotRSIChart[data, n] plots the n-period RSI with standard overbought/oversold lines at 70/30.";
PlotIndicators::usage="PlotIndicators[data, nSMA, nRSI] produces a two-panel dashboard: price+SMA on top, RSI below, to provide a consolidated view of the derived signals.";
Begin["`Private`"];
FetchOHLCV[ticker_String,start_DateObject,end_DateObject]:=Module[{ts,raw},ts=FinancialData[ticker,"OHLCV",{start,end}];raw=Normal[ts];raw/. {date_,{o_,h_,l_,c_,v_}}:>Association["Ticker"->ticker,"Date"->date,"Open"->o,"High"->h,"Low"->l,"Close"->c,"Volume"->v]];
RelativeStrengthIndex[vec_List,n_Integer?Positive]:=Module[{d,up,dn,g,l,rs},d=Differences[vec];up=Clip[d,{0,\[Infinity]}];dn=-Clip[d,{-\[Infinity],0}];g=MovingAverage[up,n];l=MovingAverage[dn,n];rs=g/Replace[l,0.->$MachineEpsilon];Join[ConstantArray[Missing[],n],100-100/(1+rs)]];
AddRSI[data_List,n_Integer?Positive]:=Module[{cl,rsi},cl=QuantityMagnitude[Lookup[data,"Close"]];rsi=RelativeStrengthIndex[cl,n];MapThread[Append[#1,"RSI"<>ToString[n]->#2]&,{data,rsi}]];
AddSMA[data_List,n_Integer?Positive]:=Module[{cl,sma},cl=QuantityMagnitude[Lookup[data,"Close"]];sma=MovingAverage[cl,n];sma=Join[ConstantArray[Missing[],n-1],sma];MapThread[Append[#1,"SMA"<>ToString[n]->#2]&,{data,sma}]];
PlotVolumeChart[data_List]:=Module[{vol=({#Date,QuantityMagnitude[#Volume]}&)/@data,ticker},ticker=Lookup[data[[1]],"Ticker",""];BarChart[vol,AspectRatio->1/3,ImageSize->Large,PlotLabel->Style[ticker<>" Volume",16,Bold],ChartStyle->Blue]];
PlotSMAChart[data_List,n_Integer]:=Module[{dates,closes,sma},dates=Lookup[data,"Date"];closes=QuantityMagnitude/@Lookup[data,"Close"];sma=Lookup[data,"SMA"<>ToString[n]];DateListPlot[{Transpose[{dates,closes}],Transpose[{dates,sma}]},PlotLegends->{"Close","SMA "<>ToString[n]},Frame->True,ImageSize->Large,PlotLabel->"Price + SMA "<>ToString[n],GridLines->{None,Automatic}]];
PlotRSIChart[data_List,n_Integer]:=Module[{dates,rsi},dates=Lookup[data,"Date"];rsi=Lookup[data,"RSI"<>ToString[n]];DateListPlot[Transpose[{dates,rsi}],PlotRange->{0,100},Frame->True,ImageSize->Large,PlotLabel->"RSI "<>ToString[n],GridLines->{None,{30,70}},GridLinesStyle->Directive[Dashed,Gray]]];
PlotIndicators[data_List,nSMA_Integer,nRSI_Integer]:=Column[{PlotSMAChart[data,nSMA],PlotRSIChart[data,nRSI]},Spacings->2];
End[];
Protect@@Names["DaedaelusSignals`*"];
EndPackage[];
Needs["DaedaelusSignals`"];
data=FetchOHLCV["AAPL",DateObject[{2024,1,1}],DateObject[]];
data2=AddRSI[AddSMA[data,20],14];
Last[data2]
PlotVolumeChart[data2]
PlotIndicators[data2,20,14]
Dataset[data2]


dataQ={{"Q1",390000,375000},{"Q2",675000,693000},{"Q3",350000,346000},{"Q4",950000,925000}};
quarters=dataQ[[All,1]];
qBudget=dataQ[[All,2]];
qActual=dataQ[[All,3]];
delta=qBudget-qActual;
BarChart[delta,ChartLabels->quarters,ChartStyle->"Pastel",AxesLabel->{"Quarter","Budget \[Dash] Actual"},PlotLabel->"Quarterly Budget vs Actual Delta",ImageSize->Large]
data1={{"1-May-12",58.13},{"30-Apr-12",53.98},{"27-Apr-12",67.00},{"26-Apr-12",89.70},{"25-Apr-12",99.00},{"24-Apr-12",130.28},{"23-Apr-12",166.70},{"20-Apr-12",234.98},{"19-Apr-12",345.44},{"18-Apr-12",443.34},{"17-Apr-12",543.70},{"16-Apr-12",580.13},{"13-Apr-12",605.23},{"12-Apr-12",622.77},{"11-Apr-12",626.20},{"10-Apr-12",628.44},{"9-Apr-12",636.23},{"5-Apr-12",633.68},{"4-Apr-12",624.31},{"3-Apr-12",629.32},{"2-Apr-12",618.63},{"30-Mar-12",599.55},{"29-Mar-12",609.86},{"28-Mar-12",617.62},{"27-Mar-12",614.48},{"26-Mar-12",606.98}};
stock1=data1/. {d_String,v_}:>{DateObject[DateList[{d,{"Day","-","MonthNameShort","-","YearShort"}}]],v};
DateListPlot[stock1,Joined->True,PlotMarkers->Automatic,AxesLabel->{"Date","Close Price"},PlotLabel->"Stock Close Prices (Apr\[Dash]May 2012)",ImageSize->Large]
data2={{"24-Apr-07",93.24},{"25-Apr-07",95.35},{"26-Apr-07",98.84},{"27-Apr-07",99.92},{"30-Apr-07",99.80},{"1-May-07",99.47},{"2-Jul-07",121.26},{"3-Jul-07",127.17},{"5-Jul-07",132.75},{"6-Jul-07",132.30},{"9-Jul-07",130.33},{"10-Jul-07",132.35},{"11-Jul-07",132.39},{"12-Jul-07",134.07},{"13-Jul-07",137.73},{"16-Jul-07",138.10},{"17-Jul-07",138.91},{"18-Jul-07",138.12},{"19-Jul-07",140.00},{"20-Jul-07",143.75},{"23-Jul-07",143.70},{"24-Jul-07",134.89},{"25-Jul-07",137.26},{"26-Jul-07",146.00},{"27-Jul-07",143.85},{"30-Jul-07",141.43},{"31-Jul-07",131.76},{"1-Aug-07",135.00},{"2-Aug-07",136.49},{"3-Aug-07",131.85},{"6-Aug-07",135.25},{"7-Aug-07",135.03},{"8-Aug-07",134.01},{"9-Aug-07",126.39},{"10-Aug-07",125.00},{"13-Aug-07",127.79},{"14-Aug-07",124.03},{"15-Aug-07",119.90},{"16-Aug-07",117.05},{"17-Aug-07",122.06},{"20-Aug-07",122.22},{"21-Aug-07",127.57},{"22-Aug-07",132.51},{"23-Aug-07",131.07},{"24-Aug-07",135.30},{"27-Aug-07",132.25},{"28-Aug-07",126.82},{"29-Aug-07",134.08},{"30-Aug-07",136.25},{"31-Aug-07",138.48},{"4-Sep-07",144.16},{"5-Sep-07",136.76},{"6-Sep-07",135.01},{"7-Sep-07",131.77},{"10-Sep-07",136.71},{"11-Sep-07",135.49},{"12-Sep-07",136.85},{"13-Sep-07",137.20},{"14-Sep-07",138.81},{"17-Sep-07",138.41},{"18-Sep-07",140.92},{"19-Sep-07",140.77},{"20-Sep-07",140.31},{"21-Sep-07",144.15},{"24-Sep-07",148.28},{"25-Sep-07",153.18},{"26-Sep-07",152.77},{"27-Sep-07",154.50},{"28-Sep-07",153.47},{"1-Oct-07",156.34},{"2-Oct-07",158.45},{"3-Oct-07",157.92},{"4-Oct-07",156.24},{"5-Oct-07",161.45},{"8-Oct-07",167.91}};


engText=ToLowerCase[Import["https://raw.githubusercontent.com/GT-CSE6240/proj2/master/data/eng.txt","Text"]];
frnText=ToLowerCase[Import["https://raw.githubusercontent.com/GT-CSE6240/proj2/master/data/frn.txt","Text"]];
chars=Characters[engText]\[Union]Characters[frnText];
charToIdx=AssociationThread[chars->Range[Length[chars]]];
cCount=Length[chars];
maxLen=5;step=3;
makeSeqs[text_]:=Module[{chs=Characters[text],n},n=Length[chs];Table[chs[[i;;i+maxLen-1]],{i,1,n-maxLen,step}]];
engSeqs=makeSeqs[engText];
frnSeqs=makeSeqs[frnText];
vectorize[seqs_]:=Table[Table[UnitVector[cCount,charToIdx[seqs[[i,j]]]],{j,maxLen}],{i,Length[seqs]}];
Xeng=vectorize[engSeqs];
Xfrn=vectorize[frnSeqs];
SeedRandom[1337];
split80[data_]:=Module[{r=RandomSample[data],n},n=Round[0.8 Length[r]];{Take[r,n],Drop[r,n]}];
{XengTrain,XengTest}=split80[Xeng];
{XfrnTrain,XfrnTest}=split80[Xfrn];
lstmNet=NetChain[{LongShortTermMemoryLayer[128],LinearLayer[cCount],SoftmaxLayer[]}];
YengTrainIdx=charToIdx/@Last/@engSeqs[[1;;Length[XengTrain]]];
YfrnTrainIdx=charToIdx/@Last/@frnSeqs[[1;;Length[XfrnTrain]]];
engNet=NetTrain[lstmNet,XengTrain->YengTrainIdx,BatchSize->128,MaxTrainingRounds->5];
frnNet=NetTrain[lstmNet,XfrnTrain->YfrnTrainIdx,BatchSize->128,MaxTrainingRounds->5];
engTest=RandomSample[engSeqs,Min[100,Length[engSeqs]]];
frnTest=RandomSample[frnSeqs,Min[100,Length[frnSeqs]]];
testSeqs=Join[engTest,frnTest];
trueLabels=Join[ConstantArray[1,Length[engTest]],ConstantArray[0,Length[frnTest]]];
scoreSeq[net1_,net2_,seq_]:=Module[{ll1=0.,ll2=0.,window,idx,d1,d2},window=ConstantArray[ConstantArray[0.,cCount],maxLen];Do[idx=charToIdx[ch];d1=net1[window];ll1+=Log[d1[[idx]]];d2=net2[window];ll2+=Log[d2[[idx]]];window=Append[Rest[window],UnitVector[cCount,idx]],{ch,seq}];Exp[ll1]-Exp[ll2]];
scores=(scoreSeq[engNet,frnNet,#1]&)/@testSeqs;
thresholds=Sort[DeleteDuplicates[scores]];
nPos=Count[trueLabels,1];nNeg=Count[trueLabels,0];
roc=Table[{Count[Transpose[{trueLabels,scores}],{0,s_}/;s>t]/nNeg,Count[Transpose[{trueLabels,scores}],{1,s_}/;s>t]/nPos},{t,thresholds}];
fprs=roc[[All,1]];tprs=roc[[All,2]];
auc=Total[1/2 (Most[tprs]+Rest[tprs]) Differences[fprs]];
ListLinePlot[roc,AxesLabel->{"False Positive Rate","True Positive Rate"},PlotRange->{{0,1},{0,1}},PlotLabel->Row[{"ROC Curve    AUC = ",NumberForm[auc,{4,3}]}],GridLines->Automatic]


Print["Fetching and preprocessing data..."];
engText=ToLowerCase[Import["https://raw.githubusercontent.com/GT-CSE6240/proj2/master/data/eng.txt","Text"]];
frnText=ToLowerCase[Import["https://raw.githubusercontent.com/GT-CSE6240/proj2/master/data/frn.txt","Text"]];
allChars=Characters[engText]\[Union]Characters[frnText];
vocabSize=Length[allChars];
charToIdx=AssociationThread[allChars->Range[vocabSize]];
Print["Shared vocabulary size: ",vocabSize];
charFreqVector[text_]:=Module[{counts},counts=Counts[Characters[text]];Normalize[Lookup[counts,allChars,0],Total]];
Print["Computing frequency vectors for training..."];
engFreq=charFreqVector[engText];
frnFreq=charFreqVector[frnText];
classify[text_]:=Module[{vec,engSim,frnSim},vec=charFreqVector[text];engSim=vec . engFreq;frnSim=vec . frnFreq;If[engSim>frnSim,"English","French"]];
Print["Preparing test substrings..."];
maxlen=20;
engTestSubs=RandomSample[StringPartition[engText,maxlen,1],100];
frnTestSubs=RandomSample[StringPartition[frnText,maxlen,1],100];
combinedSubs=Join[engTestSubs,frnTestSubs];
trueLabels=Join[ConstantArray["English",100],ConstantArray["French",100]];
Print["Classifying test samples..."];
predictedLabels=classify/@combinedSubs;
correct=Count[Transpose[{trueLabels,predictedLabels}],{x_,x_}];
accuracy=N[correct/Length[combinedSubs]];
Print["Classification accuracy: ",PercentForm[accuracy,3]];
Print["Confusion Matrix:"];
confMatrixData={{"Actual \\ Predicted","English","French"},{"English",Count[Transpose[{trueLabels,predictedLabels}],{"English","English"}],Count[Transpose[{trueLabels,predictedLabels}],{"English","French"}]},{"French",Count[Transpose[{trueLabels,predictedLabels}],{"French","English"}],Count[Transpose[{trueLabels,predictedLabels}],{"French","French"}]}};
confMatrix=Grid[confMatrixData,Frame->All,Alignment->Center,Background->{None,{LightBlue}}];
confMatrix


data1=Table[Sin[x]+0.2 RandomReal[],{x,0,2 \[Pi],0.1}];
data2=Table[Cos[x]+0.2 RandomReal[],{x,0,2 \[Pi],0.1}];
ListPlot[Transpose[{data1,data2}],PlotStyle->PointSize[Medium],AxesLabel->{"predictions","targets"},PlotLabel->"Scatter: predictions vs targets"]
sharpeRatio[perf_List]:=Mean[perf]/StandardDeviation[perf];
pl=Accumulate[RandomVariate[NormalDistribution[0,1],200]];
ListLinePlot[pl,AxesLabel->{"Time","Cumulative P/L"},PlotLabel->Row[{"Sharpe = ",NumberForm[sharpeRatio[Differences[pl]],3]}]]
minMaxNormalize[data_List]:=Rescale[data,{Min[data],Max[data]},{0,1}];
standardize[data_List]:=Standardize[data];
x=RandomVariate[NormalDistribution[5,2],100];
Show[ListLinePlot[x,PlotLabel->"raw data"],ListLinePlot[minMaxNormalize[x],PlotStyle->Red,PlotLabel->"min\[Dash]max \[RightArrow] [0,1]"],ListLinePlot[standardize[x],PlotStyle->Blue,PlotLabel->"standardize \[RightArrow] mean 0, std 1"]]
gaussianize[data_List]:=Module[{r},r=(Ordering[Ordering[data]]-0.5)/Length[data];(InverseCDF[NormalDistribution[0,1],#1]&)/@r];
y=RandomReal[{0,1},200];
ListLinePlot[{Sort[y],Sort[gaussianize[y]]},PlotLegends->{"sorted uniform","gaussianized"},AxesLabel->{"Index","Value"}]
orthogonalize[v_List,u_List]:=Module[{proj},proj=(v . u u)/u . u;v-proj];
u={1,2};
v={3,1};
Graphics[{Thick,Blue,Arrow[{{0,0},v}],Thick,Green,Arrow[{{0,0},u}],Thick,Red,Arrow[{{0,0},orthogonalize[v,u]}]},Axes->True,PlotLabel->"blue = v, green = u, red = v \[Perpendicular] u"]


(* ::Input::Initialization:: *)
This Mathematica code is a collection of five distinct demonstrations, each visualizing a fundamental concept from statistics, data analysis, or linear algebra. The output is a series of plots corresponding to each demonstration.

Description of Demonstrations
\[Application] Prediction vs. Target Scatter Plot
It begins by generating two correlated, noisy datasets to simulate model predictions and actual target values. It then creates a scatter plot to visualize the relationship between them.

\[Application] Sharpe Ratio & P/L Simulation
This section simulates a financial profit-and-loss (P/L) timeline as a random walk. It calculates the Sharpe ratio, a key metric for risk-adjusted return, and displays the P/L evolution as a line plot.

\[Application] Data Normalization Techniques
It demonstrates and compares two standard data preprocessing methods: min-max normalization (scaling to a [0, 1] range) and standardization (scaling to a mean of 0 and a standard deviation of 1). The results are shown in an overlaid line plot.

\[Application] Gaussianization of Data
This part implements a quantile transform to convert a uniform random distribution into a normal (Gaussian) distribution. A line plot compares the sorted data before and after the transformation, showing the characteristic S-curve of a cumulative normal distribution.

\[Application] Vector Orthogonalization
Finally, it demonstrates the Gram-Schmidt process by taking two vectors, u and v, and calculating a new vector that is orthogonal to u. A vector plot visualizes the original vectors and the resulting orthogonal vector as arrows.

This collection of examples serves as a practical showcase of the foundational mathematical tools used in modeling complex systems. Understanding these concepts of statistical analysis, data transformation, and vector space operations is a prerequisite for developing the more advanced models of system dynamics, such as the Graph Virtual Machine and the learning processes described in the Daedaelus framework.


pred=RandomVariate[NormalDistribution[],100];
targ=pred+0.5 RandomVariate[NormalDistribution[0,1],100];
ListPlot[Transpose[{pred,targ}],PlotStyle->PointSize[Medium],AxesLabel->{"predictions","targets"},PlotLabel->"pred vs targ"]
u=RandomReal[{0,1},200];
gU=(InverseCDF[NormalDistribution[0,1],#1]&)/@u;
pU=(Sign[#1] Abs[#1]^1.5&)/@gU;
Histogram[{u,gU,pU},ChartLegends->{"uniform","gaussianized","gauss^1.5"},PlotLabel->"Transformations"]
uVec={1,2};
vVec={3,1};
orthogonalComponent[v_,u_]:=v-(v . u u)/u . u;
Graphics[{Thick,Blue,Arrow[{{0,0},vVec}],Thick,Green,Arrow[{{0,0},uVec}],Thick,Red,Arrow[{{0,0},orthogonalComponent[vVec,uVec]}]},Axes->True,PlotLabel->"blue = v, green = u, red = v\[UpTee]u"]


Manipulate[Module[{d2,pts,colors,scintillatePts,pearson,spearman,bg=Black},d2=Switch[type,"Linear",d1+RandomReal[{-noise,noise},100],"Monotonic (Non-Linear)",d1^3+RandomReal[{-noise,noise},100],"Uncorrelated",RandomReal[1,100]];pts=Transpose[{d1,d2}];colors=Table[Blend[{Cyan,Blue,Pink,Yellow,GrayLevel[0.3]},Mod[i/Length[pts]+RandomReal[{-0.03,0.03}],1]],{i,Length[pts]}];scintillatePts=Table[{Glow[colors[[i]]],Opacity[0.22],Disk[pts[[i]],0.025],Opacity[1],EdgeForm[None],Style[Disk[pts[[i]],0.012],colors[[i]]]},{i,Length[pts]}];pearson=pearsonCorrelation[d1,d2];spearman=spearmanCorrelation[d1,d2];Grid[{{Style[type<>" Data",Bold,16,White],\[SpanFromLeft]},{Graphics[{{bg,Rectangle[{0,0},{1,1}]},scintillatePts},PlotRange->{{0,1},{Min[d2]-0.1,Max[d2]+0.1}},ImageSize->400,Axes->True,AxesStyle->White,Frame->True,FrameStyle->White,AxesLabel->{Style["d1",14,White],Style["d2",14,White]},Background->bg],Column[{Row[{Style["Pearson:  ",16,Cyan],Style[NumberForm[pearson,{3,2}],16,White]}],Row[{Style["Spearman: ",16,Cyan],Style[NumberForm[spearman,{3,2}],16,White]}]},Spacings->1]}},Alignment->Center,Spacings->2,Background->Black]],{{type,"Linear","Data Structure"},{"Linear","Monotonic (Non-Linear)","Uncorrelated"}},{{noise,0.1,"Noise"},0,1,Appearance->"Labeled"},ControlPlacement->Top,TrackedSymbols:>{type,noise},Initialization:>(pearsonCorrelation[p_List,t_List]:=Correlation[p,t];spearmanCorrelation[p_List,t_List]:=Module[{n=Length[p],rp,rt,dsq},rp=Ordering[Ordering[p]];rt=Ordering[Ordering[t]];dsq=(rp-rt)^2;1-(6 Total[dsq])/(n (n^2-1))];SeedRandom[123];d1=Sort[RandomReal[1,100]];),FrameMargins->-5.3,ControlPlacement->Top]


Module[{starCount=2500,sceneR=10,lineY=4,presentBox={0.8,0.8},swirlShift=-2,swirlR=5,stars,timeline,swirl,frame,labels,quote},stars={White,PointSize[Tiny],Point[RandomPoint[Disk[{0,0},sceneR],starCount]]};timeline=Module[{ticks=Range[-8,8,2],years},years=1950+(ticks+8) 25;Flatten[{White,Thickness[.004],Line[{{-8,lineY},{8,lineY}}],Table[{Line[{{x,lineY-.2},{x,lineY+.2}}],If[EvenQ[i],Text[Style[ToString[years[[i+1]]],9,White],{x,lineY-.6}]]},{i,0,Length[ticks]-1},{x,{ticks[[i+1]]}}],Table[Text[Style[If[EvenQ[k],"cause","effect"],9,White],{ticks[[k+1]],lineY+0.8}],{k,0,Length[ticks]-1}],{Cyan,Rectangle[{-(presentBox[[1]]/2),lineY+.25},{presentBox[[1]]/2,lineY+.25+presentBox[[2]]}]},Text[Style["Present",13,White],{0,lineY+1.3}],Text[Style["Past",11,White],{-8,lineY-1}],Text[Style["Future",11,White],{8,lineY-1}]}]];swirl=Module[{a=.05,b=.045,\[Theta]max=24,d\[Theta]=.05,\[Phi]list},\[Phi]list=Range[0,2 \[Pi]-\[Pi]/8,\[Pi]/8];Table[Line[Table[With[{r=a Exp[b \[Theta]]},r {Cos[\[Theta]+\[Phi]],Sin[\[Theta]+\[Phi]]}],{\[Theta],0,\[Theta]max,d\[Theta]}]],{\[Phi],\[Phi]list}]];frame={White,Opacity[.5],Circle[{0,0},swirlR]};labels=Table[With[{\[Theta]=(2 \[Pi] k)/8,tag=If[EvenQ[k],"cause","effect"]},Text[Style[tag,10,White],(swirlR+1) {Cos[\[Theta]],Sin[\[Theta]]}]],{k,0,7}];quote={Text[Style["People assume that time is a strict progression of cause to effect, but actually, from a non-linear,\n non-subjective viewpoint, it's more like a big ball of wibbly-wobbly\[Ellipsis] timey-wimey\[Ellipsis] stuff.",12,White,LineSpacing->{1.2,0},TextJustification->.5],{0,-7.3},Center],Text[Style["\[LongDash] The Doctor",11,White,Italic],{0,-8.2}]};Graphics[{Black,Rectangle[{-sceneR,-sceneR},{sceneR,sceneR}],stars,timeline,Translate[swirl,{0,swirlShift}],Translate[frame,{0,swirlShift}],Translate[labels,{0,swirlShift}],quote},PlotRange->{{-sceneR,sceneR},{-sceneR,sceneR}},Background->Black,ImageSize->600]]


ClearAll[rule184EvolutionFast];
rule184EvolutionFast[initial_List,steps_Integer?NonNegative]:=CellularAutomaton[184,initial,steps];
initialFreeway={0,0,1,0,0,1,1,0,1,1,1,0,0,0,1};
iterations=10;
Print["Rule 184 evolution (",iterations," steps):"];
Scan[Print[Row[#1]]&,rule184EvolutionFast[initialFreeway,iterations]];
ClearAll[simulateNSFast];
laneLength=1000;
tMax=3000;
tAvgStart=2000;
vMax=5;
pRandomSlow=0.5;
simulateNSFast[nCars_Integer?Positive,L_:laneLength,T_:tMax,T0_:tAvgStart,vmax_:vMax,p_:pRandomSlow]:=Module[{pos,vel,totalSpeed=0.,len=nCars,gaps,newStep,sorted,sortedPos,sortedVel,\[Delta],t},SeedRandom[2025];pos=RandomSample[Range[0,L-1],nCars];vel=RandomInteger[{0,vmax},nCars];newStep[{sortedPos_,sortedVel_}]:=Module[{gapsLocal,nv,newPV},gapsLocal=Mod[RotateLeft[sortedPos]-sortedPos-1,L];newPV=MapThread[Function[{x,v,g},nv=Min[v+1,vmax];nv=Min[nv,g];If[nv>0&&RandomReal[]<p,nv--];{Mod[x+nv,L],nv}],{sortedPos,sortedVel,gapsLocal}];Transpose[newPV]];Do[If[t>=T0,totalSpeed+=Total[vel]];sorted=Ordering[pos];sortedPos=pos[[sorted]];sortedVel=vel[[sorted]];{pos,vel}=newStep[{sortedPos,sortedVel}],{t,0,T-1}];totalSpeed/(nCars (T-T0))];
densities=Range[10,1000,10];
velocities=ParallelTable[simulateNSFast[n],{n,densities}];
d=densities;v=velocities;
Print["\nAverage velocities  \:27e8v\:27e9  after ",tAvgStart," steps:"];
Do[Print["  n = ",d[[k]],"  \[DoubleRightArrow]  ",NumberForm[v[[k]],{3,2}]],{k,Length[d]}];
ListLinePlot[Transpose[{d,v}],AxesLabel->{"Vehicles on 1\[ThinSpace]km","Average velocity (cells/step)"},PlotMarkers->Automatic,PlotLabel->"Nagel\[Dash]Schreckenberg Fundamental Diagram"]


ClearAll["Global`*"];SeedRandom[123];
DarkGreen=Darker[Green,.3];
DarkRed=Darker[Red,.3];
n=400;
ages=RandomInteger[{18,60},n];
salaries=RandomInteger[{15000,150000},n];
sigmoid[z_]:=1/(1+Exp[-z]);
p=sigmoid[0.18 (ages-40)+0.00002 (salaries-60000)];
labels=Boole[Thread[RandomReal[{0,1},n]<p]];
data=Transpose[{ages,salaries}];
trainIdx=RandomSample[Range[n],Round[.75 n]];
testIdx=Complement[Range[n],trainIdx];
trainX=data[[trainIdx]];trainY=labels[[trainIdx]];
testX=data[[testIdx]];testY=labels[[testIdx]];
\[Mu]=Mean/@Transpose[trainX];
\[Sigma]=StandardDeviation/@Transpose[trainX];
standardise[v_]:=MapThread[(#1-#2)/#3&,{v,\[Mu],\[Sigma]}];
trainXz=standardise/@trainX;
testXz=standardise/@testX;
k=5;
classifier=Classify[Thread[trainXz->trainY],Method->{"NearestNeighbors","NeighborsNumber"->k},PerformanceGoal->"Quality"];
trainPred=classifier/@trainXz;
testPred=classifier/@testXz;
cfm[truth_,pred_]:=Module[{c=Counts[Thread[{truth,pred}]]},{{Lookup[c,{0,0},0],Lookup[c,{0,1},0]},{Lookup[c,{1,0},0],Lookup[c,{1,1},0]}}];
Grid[{{"Training CM",MatrixForm[cfm[trainY,trainPred]]},{"Test CM",MatrixForm[cfm[testY,testPred]]}},Frame->All]
ageRange=MinMax[ages]+{-2,2};
salRange=MinMax[salaries]+{-5000,5000};
decision[a_,s_]:=classifier[standardise[{a,s}]];
plotSet[{ptsX_,ptsY_},title_]:=Show[ContourPlot[decision[x,y],{x,Sequence@@ageRange},{y,Sequence@@salRange},PlotPoints->75,MaxRecursion->0,AspectRatio->1,ColorFunction->(Blend[{{0,RGBColor[1,.85,.85]},{1,RGBColor[.85,1,.85]}},#1]&),Contours->{0.5},ContourStyle->Thick,FrameLabel->{"Age","Estimated Salary (USD)"},PlotLabel->title],Graphics[MapThread[{If[#2==1,DarkGreen,DarkRed],Point[#1]}&,{ptsX,ptsY}]],ImageSize->400];
trainPlot=plotSet[{trainX,trainY},"K-NN \[LongDash] Training"];
testPlot=plotSet[{testX,testY},"K-NN \[LongDash] Test"];
trainPlot
testPlot


(* ::Input::Initialization:: *)
This Mathematica code demonstrates a complete machine learning workflow for a K-Nearest Neighbors (K-NN) classifier. It involves synthesizing data, training a model, evaluating its performance, and visualizing the result.

The script executes the following steps:

 1. Data Synthesis: It programmatically generates a dataset of 400 samples, each with two features (age and salary) and a binary class label (0 or 1). The labels are assigned based on a sigmoid function, creating a non-linear but coherent relationship between the features and the class.

 2. Data Preparation: The data is split into training (75%) and test (25%) sets. The features are then standardized to have a mean of zero and unit variance, a crucial step for distance-based algorithms like K-NN.

 3. Model Training: A K-NN classifier (with k=5) is trained on the prepared training data using Mathematica's built-in Classify function.

 4. Evaluation: The model's performance is numerically evaluated by generating confusion matrices for both the training and test datasets.

 5. Visualization: The primary output is a visualization of the classifier's decision boundary. It generates a ContourPlot where the background is shaded to show the regions predicted for each class. The actual data points are then overlaid on this background, colored according to their true class.

The image you provided shows the visualization for the training set, clearly illustrating how the K-NN algorithm creates a complex, non-linear boundary to classify the data points. This process of modeling and visualizing a system's decision-making process is a core aspect of achieving the observability required to build robust and verifiable systems.


diffusionCoefficient=0.2;
domainStart=-90;
domainEnd=90;
simulationTime=800;
nestPositionX=25;
nestPositionY=10;
nestSpread=10;
foodPositionX=-25;
foodPositionY=-10;
foodSpread=10;
stigmergyFactor=2;
gaussian2D[centerX_,centerY_,spread_,x_,y_]:=(1/(spread Sqrt[2 \[Pi]]))^2 Exp[-(((x-centerX)^2+(y-centerY)^2)/(2 spread^2))];
nestDistribution=10 gaussian2D[nestPositionX,nestPositionY,nestSpread,x,y];
foodDistribution=10 gaussian2D[foodPositionX,foodPositionY,foodSpread,x,y];
eqScout1=\!\(
\*SubscriptBox[\(\[PartialD]\), \(t\)]\(scoutPopulation1[x, y, t]\)\)==diffusionCoefficient (\!\(
\*SubscriptBox[\(\[PartialD]\), \({x, 2}\)]\(scoutPopulation1[x, y, t]\)\)+\!\(
\*SubscriptBox[\(\[PartialD]\), \({y, 2}\)]\(scoutPopulation1[x, y, t]\)\))+stigmergyFactor (\!\(
\*SubscriptBox[\(\[PartialD]\), \(x\)]\((scoutPopulation2[x, y, t]\ 
\*SubscriptBox[\(\[PartialD]\), \(x\)]scoutPopulation2[x, y, t])\)\)+\!\(
\*SubscriptBox[\(\[PartialD]\), \(y\)]\((scoutPopulation2[x, y, t]\ 
\*SubscriptBox[\(\[PartialD]\), \(y\)]scoutPopulation2[x, y, t])\)\));
icScout1=scoutPopulation1[x,y,0]==gaussian2D[nestPositionX,nestPositionY,nestSpread,x,y];
bcScout1={\!\(
\*SubscriptBox[\(\[PartialD]\), \(x\)]\(scoutPopulation1[x, y, t]\)\)==0/. x->domainStart,\!\(
\*SubscriptBox[\(\[PartialD]\), \(x\)]\(scoutPopulation1[x, y, t]\)\)==0/. x->domainEnd,\!\(
\*SubscriptBox[\(\[PartialD]\), \(y\)]\(scoutPopulation1[x, y, t]\)\)==0/. y->domainStart,\!\(
\*SubscriptBox[\(\[PartialD]\), \(y\)]\(scoutPopulation1[x, y, t]\)\)==0/. y->domainEnd};
eqScout2=\!\(
\*SubscriptBox[\(\[PartialD]\), \(t\)]\(scoutPopulation2[x, y, t]\)\)==diffusionCoefficient (\!\(
\*SubscriptBox[\(\[PartialD]\), \({x, 2}\)]\(scoutPopulation2[x, y, t]\)\)+\!\(
\*SubscriptBox[\(\[PartialD]\), \({y, 2}\)]\(scoutPopulation2[x, y, t]\)\))+\!\(
\*SubscriptBox[\(\[PartialD]\), \(x\)]\((stigmergyFactor\ scoutPopulation1[x, y, t]\ 
\*SubscriptBox[\(\[PartialD]\), \(x\)]scoutPopulation2[x, y, t])\)\)+\!\(
\*SubscriptBox[\(\[PartialD]\), \(y\)]\((stigmergyFactor\ scoutPopulation1[x, y, t]\ 
\*SubscriptBox[\(\[PartialD]\), \(y\)]scoutPopulation2[x, y, t])\)\)+scoutPopulation1[x,y,t] (nestDistribution-foodDistribution)-scoutPopulation2[x,y,t] (foodDistribution+nestDistribution);
icScout2=scoutPopulation2[x,y,0]==gaussian2D[nestPositionX,nestPositionY,nestSpread,x,y]-gaussian2D[foodPositionX,foodPositionY,foodSpread,x,y];
bcScout2={\!\(
\*SubscriptBox[\(\[PartialD]\), \(x\)]\(scoutPopulation2[x, y, t]\)\)==0/. x->domainStart,\!\(
\*SubscriptBox[\(\[PartialD]\), \(x\)]\(scoutPopulation2[x, y, t]\)\)==0/. x->domainEnd,\!\(
\*SubscriptBox[\(\[PartialD]\), \(y\)]\(scoutPopulation2[x, y, t]\)\)==0/. y->domainStart,\!\(
\*SubscriptBox[\(\[PartialD]\), \(y\)]\(scoutPopulation2[x, y, t]\)\)==0/. y->domainEnd};
solution=NDSolve[Flatten[{{eqScout1,icScout1},bcScout1,{eqScout2,icScout2},bcScout2}],{scoutPopulation1,scoutPopulation2},{x,domainStart,domainEnd},{y,domainStart,domainEnd},{t,0,simulationTime},Method->{"MethodOfLines","SpatialDiscretization"->{"TensorProductGrid","MaxPoints"->81}}];
Manipulate[ContourPlot[Evaluate[scoutPopulation1[x,y,t]/. solution],{x,domainStart,domainEnd},{y,domainStart,domainEnd},PlotRange->All,Mesh->30,ImageSize->Large,PlotLabel->"Scout Population 1 (Explorer) Density"],{t,0,simulationTime,Appearance->"Labeled"}]
Manipulate[ContourPlot[Evaluate[scoutPopulation2[x,y,t]/. solution],{x,domainStart,domainEnd},{y,domainStart,domainEnd},PlotRange->All,Mesh->30,ImageSize->Large,PlotLabel->"Scout Population 2 (Forager) Density"],{t,0,simulationTime,Appearance->"Labeled"}]
Manipulate[Plot3D[Evaluate[scoutPopulation1[x,y,t]/. solution],{x,domainStart,domainEnd},{y,domainStart,domainEnd},Mesh->30,PlotRange->All,ImageSize->Large,PlotLabel->"Scout Population 1 (Explorer) Density"],{t,0,simulationTime,Appearance->"Labeled"}]
Manipulate[Plot3D[Evaluate[scoutPopulation2[x,y,t]/. solution],{x,domainStart,domainEnd},{y,domainStart,domainEnd},Mesh->30,PlotRange->All,ImageSize->Large,PlotLabel->"Scout Population 2 (Forager) Density"],{t,0,simulationTime,Appearance->"Labeled"}]


(* ::Input::Initialization:: *)
This Mathematica code simulates the emergent behavior of two interacting scout populations (e.g., "Explorers" and "Foragers") in a 2D environment containing a "nest" and a "food source." The simulation is based on a system of coupled partial differential equations (PDEs) that model how the populations evolve over time.

The model incorporates three key mechanisms inspired by the collective behavior of social insects:

 1. Diffusion: The natural tendency for the scout populations to spread out over the 2D space.

 2. Stigmergy: A form of indirect communication where the movement of one population is influenced by the density gradient (i.e., "pheromone trail") left by the other.

 3. Attraction/Repulsion: The populations are drawn to or repelled from the predefined nest and food locations.

The script uses Mathematica's NDSolve to numerically solve these PDEs. The results are then presented in a series of interactive Manipulate plots, including both 2D contour plots and 3D surface plots of the population densities. A time slider allows the user to watch the entire evolution, observing how the scouts initially spread from the nest and eventually form complex patterns as they interact.

This simulation is a direct implementation of the biologically-inspired scouting and discovery principles that are foundational to the Daedaelus architecture. It formally models how complex, coordinated behavior can emerge from simple, local rules and indirect communication\[LongDash]the same principles that underpin the Graph Virtual Machine (GVM) and the proposed address-free routing protocols on an N2N Lattice.


Manipulate[Module[{gClos,gDirect,lap,numTreesClos,numTreesDirect,vizClos,vizDirect,spineCount},spineCount=Ceiling[nodeCount/xpuValency];gClos=Graph[Flatten[Table["Leaf"<>ToString[i]\[UndirectedEdge]"Spine"<>ToString[j],{i,1,nodeCount},{j,1,Min[xpuValency,spineCount]}]],VertexLabels->"Name",GraphLayout->"BipartiteEmbedding"];gDirect=RandomGraph[DegreeGraphDistribution[Table[xpuValency,nodeCount]],VertexLabels->"Name",GraphLayout->"SpringEmbedding"];lap[g_]:=DiagonalMatrix[VertexDegree[g]]-AdjacencyMatrix[g];countTrees[g_]:=If[ConnectedGraphQ[g],With[{eigs=Eigenvalues[N[lap[g]]/. 0->Sequence[]]},Round[Times@@eigs/nodeCount]],0];numTreesClos=countTrees[gClos];numTreesDirect=countTrees[gDirect];vizClos=GraphPlot[gClos,PlotLabel->"Sliced Clos (leaves\[RightArrow]spines)\n"<>"Valency \[RightArrow] "<>ToString[xpuValency]<>", Spines \[RightArrow] "<>ToString[spineCount]<>"\nSpanning Trees \[TildeTilde] "<>ToString[numTreesClos]];vizDirect=GraphPlot[gDirect,PlotLabel->"Direct Mesh (degree = "<>ToString[xpuValency]<>")\n"<>"Spanning Trees \[TildeTilde] "<>ToString[numTreesDirect]];Grid[{{vizClos,vizDirect}},Spacings->{2,2}]],{{xpuValency,4,"XPU Valency"},1,10,1,Appearance->"Labeled"},{{nodeCount,20,"Node Count"},10,100,1,Appearance->"Labeled"},Button["Regenerate Direct Mesh",gDirect=RandomGraph[DegreeGraphDistribution[Table[xpuValency,nodeCount]]]],TrackedSymbols:>{xpuValency,nodeCount}]


(* ::Input::Initialization:: *)
This Mathematica code creates an interactive `Manipulate` dashboard that quantitatively compares the topological resilience of two network architectures: a traditional Sliced Clos (leaf-spine) network and a Direct Mesh.

The simulation's primary goal is to demonstrate the superior path redundancy of a direct-connect mesh. Resilience is measured by calculating the total number of spanning trees for each graph, a powerful indicator of a network's robustness against link failures. This calculation is performed using Kirchhoff's Matrix Tree Theorem, which leverages the eigenvalues of the graph's Laplacian matrix.

The interactive dashboard allows you to adjust the Node Count and XPU Valency (connections per node) and observe the impact on each topology. The code generates and displays two plots side-by-side:

 1.  Sliced Clos Plot: Shows a bipartite graph of "leaf" nodes connected to a smaller set of "spine" nodes, typical of a switched datacenter fabric.
 2.  Direct Mesh Plot: Shows a random regular graph where all nodes are interconnected directly, representing the switchless N2N Lattice of the Daedaelus architecture.

The visualization makes it clear that for the same number of nodes and connections, the Direct Mesh topology has an astronomically higher number of spanning trees, proving it is fundamentally more resilient and less susceptible to network partitions. This serves as a "code as proof" demonstration of the advantages of the decentralized graph topology upon which the Graph Virtual Machine (GVM) operates.
